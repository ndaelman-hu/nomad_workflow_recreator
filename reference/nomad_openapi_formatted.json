{
  "openapi": "3.1.0",
  "info": {
    "title": "NOMAD API",
    "description": "Please visit the [API section of the NOMAD documentation](https://nomad-lab.eu/prod/v1/docs/api.html)\nfor a introduction and examples.",
    "version": "v1, NOMAD 1.3.16"
  },
  "servers": [
    {
      "url": "/prod/v1/api/v1"
    }
  ],
  "paths": {
    "/auth/token": {
      "post": {
        "tags": [
          "auth"
        ],
        "summary": "Get an access token",
        "description": "This API uses OAuth as an authentication mechanism. This operation allows you to\nretrieve an *access token* by posting username and password as form data.\n\nThis token can be used on subsequent API calls to authenticate\nyou. Operations that support or require authentication will expect the *access token*\nin an HTTP Authorization header like this: `Authorization: Bearer <access token>`.\n\nOn the OpenAPI dashboard, you can use the *Authorize* button at the top.\n\nYou only need to provide `username` and `password` values. You can ignore the other\nparameters.",
        "operationId": "get_token_auth_token_post",
        "requestBody": {
          "required": true,
          "content": {
            "application/x-www-form-urlencoded": {
              "schema": {
                "$ref": "#/components/schemas/Body_get_token_auth_token_post"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Token"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The provided credentials were not recognized.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "auth"
        ],
        "summary": "Get an access token",
        "description": "**[DEPRECATED]** This endpoint is **no longer recommended**.\nPlease use the **POST** endpoint instead.\n\nThis was a convenience alternative to the **POST** version, allowing retrieval of\nan *access token* by providing a username and password via query parameters.\n\n**Why is this deprecated?**\n    Query parameters expose credentials in URLs, which can be logged or cached.",
        "operationId": "get_token_via_query_auth_token_get",
        "deprecated": true,
        "parameters": [
          {
            "name": "username",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Username"
            }
          },
          {
            "name": "password",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Password"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Token"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The provided credentials were not recognized.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/signature_token": {
      "get": {
        "tags": [
          "auth"
        ],
        "summary": "Get a signature token",
        "description": "Generates and returns a signature token for the authenticated user. Authentication\nhas to be provided with another method, e.g. access token.",
        "operationId": "get_signature_token_auth_signature_token_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SignatureToken"
                }
              }
            }
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      }
    },
    "/auth/app_token": {
      "get": {
        "tags": [
          "auth"
        ],
        "summary": "Get an app token",
        "description": "Generates and returns an app token with the requested expiration time for the\nauthenticated user. Authentication has to be provided with another method,\ne.g. access token.\n\nThis app token can be used like the access token (see `/auth/token`) on subsequent API\ncalls to authenticate you using the HTTP header `Authorization: Bearer <app token>`.\nIt is provided for user convenience as a shorter token with a user-defined (probably\nlonger) expiration time than the access token.",
        "operationId": "get_app_token_auth_app_token_get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "expires_in",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "maximum": 2592000,
              "exclusiveMinimum": 0,
              "title": "Expires In"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AppToken"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/datasets/": {
      "get": {
        "tags": [
          "datasets"
        ],
        "summary": "Get a list of datasets",
        "description": "Retrieves all datasets that match the given criteria.",
        "operationId": "get_datasets_datasets__get",
        "parameters": [
          {
            "name": "dataset_id",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "title": "Dataset Id"
            }
          },
          {
            "name": "dataset_name",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "title": "Dataset Name"
            }
          },
          {
            "name": "user_id",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "title": "User Id"
            }
          },
          {
            "name": "dataset_type",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "title": "Dataset Type"
            }
          },
          {
            "name": "doi",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "title": "Doi"
            }
          },
          {
            "name": "prefix",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "title": "Prefix"
            }
          },
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The page size, e.g. the maximum number of items contained in one response.\nA `page_size` of 0 will return no results.",
              "default": 10,
              "title": "Page Size"
            },
            "description": "The page size, e.g. the maximum number of items contained in one response.\nA `page_size` of 0 will return no results."
          },
          {
            "name": "order_by",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The results are ordered by the values of this field. If omitted, default\nordering is applied.",
              "title": "Order By"
            },
            "description": "The results are ordered by the values of this field. If omitted, default\nordering is applied."
          },
          {
            "name": "order",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/Direction"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The ordering direction of the results based on `order_by`. Its either\nascending `asc` or descending `desc`. Default is `asc`.",
              "default": "asc",
              "title": "Order"
            },
            "description": "The ordering direction of the results based on `order_by`. Its either\nascending `asc` or descending `desc`. Default is `asc`."
          },
          {
            "name": "page_after_value",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "This attribute defines the position after which the page begins, and is used\nto navigate through the total list of results.\n\nWhen requesting the first page, no value should be provided for\n`page_after_value`. Each response will contain a value `next_page_after_value`,\nwhich can be used to obtain the next page (by setting `page_after_value` in\nyour next request to this value).\n\nThe field is encoded as a string, and the format of `page_after_value` and\n`next_page_after_value` depends on which API method is used.\n\nSome API functions additionally allows a simplified navigation, by specifying\nthe page number in the key `page`. It is however always possible to use\n`page_after_value` and `next_page_after_value` to iterate through the results.",
              "title": "Page After Value"
            },
            "description": "This attribute defines the position after which the page begins, and is used\nto navigate through the total list of results.\n\nWhen requesting the first page, no value should be provided for\n`page_after_value`. Each response will contain a value `next_page_after_value`,\nwhich can be used to obtain the next page (by setting `page_after_value` in\nyour next request to this value).\n\nThe field is encoded as a string, and the format of `page_after_value` and\n`next_page_after_value` depends on which API method is used.\n\nSome API functions additionally allows a simplified navigation, by specifying\nthe page number in the key `page`. It is however always possible to use\n`page_after_value` and `next_page_after_value` to iterate through the results."
          },
          {
            "name": "page",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The number of the page (1-based). When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used.",
              "title": "Page"
            },
            "description": "The number of the page (1-based). When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used."
          },
          {
            "name": "page_offset",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The number of skipped entries. When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page_offset` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used.",
              "title": "Page Offset"
            },
            "description": "The number of skipped entries. When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page_offset` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DatasetsResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "datasets"
        ],
        "summary": "Create a new dataset",
        "description": "Create a new dataset.",
        "operationId": "post_datasets_datasets__post",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DatasetCreate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DatasetResponse"
                }
              }
            }
          },
          "400": {
            "description": "The chosen dataset name is already taken. Datesets of the same user must have a\nunique name.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/datasets/{dataset_id}": {
      "get": {
        "tags": [
          "datasets"
        ],
        "summary": "Get a list of datasets",
        "description": "Retrieves the dataset with the given id.",
        "operationId": "get_dataset_datasets__dataset_id__get",
        "parameters": [
          {
            "name": "dataset_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique dataset id of the dataset to retrieve.",
              "title": "Dataset Id"
            },
            "description": "The unique dataset id of the dataset to retrieve."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DatasetResponse"
                }
              }
            }
          },
          "404": {
            "description": "Dataset not found. The given id does not match any dataset.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "datasets"
        ],
        "summary": "Delete a dataset",
        "description": "Delete an dataset.",
        "operationId": "delete_dataset_datasets__dataset_id__delete",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "dataset_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique dataset id of the dataset to delete.",
              "title": "Dataset Id"
            },
            "description": "The unique dataset id of the dataset to delete."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DatasetResponse"
                }
              }
            }
          },
          "404": {
            "description": "Dataset not found. The given id does not match any dataset.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "400": {
            "description": "The dataset already has a DOI and cannot be changed anymore.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "401": {
            "description": "The dataset can only be edited by the user who created the dataset.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/datasets/{dataset_id}/action/doi": {
      "post": {
        "tags": [
          "datasets"
        ],
        "summary": "Assign a DOI to a dataset",
        "description": "Assign a DOI to a dataset.",
        "operationId": "assign_doi_datasets__dataset_id__action_doi_post",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "dataset_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique dataset id of the dataset to delete.",
              "title": "Dataset Id"
            },
            "description": "The unique dataset id of the dataset to delete."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DatasetResponse"
                }
              }
            }
          },
          "404": {
            "description": "Dataset not found. The given id does not match any dataset.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "400": {
            "description": "The dataset is empty. No DOI can be assigned at this moment. Add some published\ncontents to the dataset first.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "401": {
            "description": "The dataset can only be edited by the user who created the dataset.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/entries/query": {
      "post": {
        "tags": [
          "entries/metadata"
        ],
        "summary": "Search entries and retrieve their metadata",
        "description": "Executes a *query* and returns a *page* of the results with *required* result data\nas well as *statistics* and *aggregated* data.\n\nThis is the basic search operation to retrieve metadata for entries that match\ncertain search criteria (`query` and `owner`). All parameters (including `query`, `owner`)\nare optional. Look at the body schema or parameter documentation for more details.\n\nBy default the *empty* search (that returns everything) is performed. Only a small\npage of the search results are returned at a time; use `pagination` in subsequent\nrequests to retrieve more data. Each entry has a lot of different *metadata*, use\n`required` to limit the data that is returned.\n\nThe `statistics` and `aggregations` keys will further allow to return statistics\nand aggregated data over all search results.",
        "operationId": "post_entries_metadata_query_entries_query_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Metadata"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MetadataResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The given owner requires authorization,\nbut no or bad authentication credentials are given.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      }
    },
    "/entries": {
      "get": {
        "tags": [
          "entries/metadata"
        ],
        "summary": "Search entries and retrieve their metadata",
        "description": "Executes a *query* and returns a *page* of the results with *required* result data.\nThis is a version of `/entries/query`. Queries work a little different, because\nwe cannot put complex queries into URL parameters.\n\nIn addition to the `q` parameter (see parameter documentation for details), you can use all NOMAD\nsearch quantities as parameters, e.g. `?atoms=H&atoms=O`. Those quantities can be\nused with additional operators attached to their names, e.g. `?n_atoms__gte=3` for\nall entries with more than 3 atoms. Operators are `all`, `any`, `none`, `gte`,\n`gt`, `lt`, `lte`.",
        "operationId": "get_entries_metadata_entries_get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "owner",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/Owner"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The `owner` allows to limit the scope of the search based on entry ownership.\nThis is useful if you only want to search among all publicly downloadable\nentries or only among your own entries, etc.\n\nThese are the possible owner values and their meaning:\n\n* `admin`: No restriction. Only usable by an admin user.\n* `all`: Published entries (with or without embargo), or entries that belong to you\n    or are shared with you.\n* `public`: Published entries without embargo.\n* `shared`: Entries that belong to you or are shared with you.\n* `staging`: Unpublished entries that belong to you or are shared with you.\n* `user`: Entries that belong to you.\n* `visible`: Published entries without embargo, or unpublished entries that belong to\n    you or are shared with you.",
              "default": "public",
              "title": "Owner"
            },
            "description": "The `owner` allows to limit the scope of the search based on entry ownership.\nThis is useful if you only want to search among all publicly downloadable\nentries or only among your own entries, etc.\n\nThese are the possible owner values and their meaning:\n\n* `admin`: No restriction. Only usable by an admin user.\n* `all`: Published entries (with or without embargo), or entries that belong to you\n    or are shared with you.\n* `public`: Published entries without embargo.\n* `shared`: Entries that belong to you or are shared with you.\n* `staging`: Unpublished entries that belong to you or are shared with you.\n* `user`: Entries that belong to you.\n* `visible`: Published entries without embargo, or unpublished entries that belong to\n    you or are shared with you."
          },
          {
            "name": "json_query",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "To pass a query string in the format of JSON e.g. '{{\"results.material.elements\": [\"H\", \"O\"]}}'.",
              "title": "Json Query"
            },
            "description": "To pass a query string in the format of JSON e.g. '{{\"results.material.elements\": [\"H\", \"O\"]}}'."
          },
          {
            "name": "q",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "description": "Since we cannot properly offer forms for all parameters in the OpenAPI dashboard,\nyou can use the parameter `q` and encode a query parameter like this\n`atoms__H` or `n_atoms__gt__3`. Multiple usage of `q` will combine parameters with\nlogical *and*.",
              "default": [],
              "title": "Q"
            },
            "description": "Since we cannot properly offer forms for all parameters in the OpenAPI dashboard,\nyou can use the parameter `q` and encode a query parameter like this\n`atoms__H` or `n_atoms__gt__3`. Multiple usage of `q` will combine parameters with\nlogical *and*."
          },
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The page size, e.g. the maximum number of items contained in one response.\nA `page_size` of 0 will return no results.",
              "default": 10,
              "title": "Page Size"
            },
            "description": "The page size, e.g. the maximum number of items contained in one response.\nA `page_size` of 0 will return no results."
          },
          {
            "name": "order_by",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The results are ordered by the values of this field. You can order\nby any indexed scalar value, or one following two special fields:\n\n - `_score`: Sorts by relevance score.\n - `_doc`: Use when sorting does not matter, gives the best performance.\n\nIf omitted, default ordering is applied.",
              "title": "Order By"
            },
            "description": "The results are ordered by the values of this field. You can order\nby any indexed scalar value, or one following two special fields:\n\n - `_score`: Sorts by relevance score.\n - `_doc`: Use when sorting does not matter, gives the best performance.\n\nIf omitted, default ordering is applied."
          },
          {
            "name": "order",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/Direction"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The ordering direction of the results based on `order_by`. Its either\nascending `asc` or descending `desc`. Default is `asc`.",
              "default": "asc",
              "title": "Order"
            },
            "description": "The ordering direction of the results based on `order_by`. Its either\nascending `asc` or descending `desc`. Default is `asc`."
          },
          {
            "name": "page_after_value",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "This attribute defines the position after which the page begins, and is used\nto navigate through the total list of results.\n\nWhen requesting the first page, no value should be provided for\n`page_after_value`. Each response will contain a value `next_page_after_value`,\nwhich can be used to obtain the next page (by setting `page_after_value` in\nyour next request to this value).\n\nThe field is encoded as a string, and the format of `page_after_value` and\n`next_page_after_value` depends on which API method is used.\n\nSome API functions additionally allows a simplified navigation, by specifying\nthe page number in the key `page`. It is however always possible to use\n`page_after_value` and `next_page_after_value` to iterate through the results.",
              "title": "Page After Value"
            },
            "description": "This attribute defines the position after which the page begins, and is used\nto navigate through the total list of results.\n\nWhen requesting the first page, no value should be provided for\n`page_after_value`. Each response will contain a value `next_page_after_value`,\nwhich can be used to obtain the next page (by setting `page_after_value` in\nyour next request to this value).\n\nThe field is encoded as a string, and the format of `page_after_value` and\n`next_page_after_value` depends on which API method is used.\n\nSome API functions additionally allows a simplified navigation, by specifying\nthe page number in the key `page`. It is however always possible to use\n`page_after_value` and `next_page_after_value` to iterate through the results."
          },
          {
            "name": "page",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "For simple, index-based pagination, this should contain the number of the\nrequested page (1-based). When provided in a request, this attribute can be\nused instead of `page_after_value` to jump to a particular results page.\n\nHowever, you can only retrieve up to the 10.000th entry with a page number.\nOnly one, `page`, `page_offset` or `page_after_value`, can be used.",
              "title": "Page"
            },
            "description": "For simple, index-based pagination, this should contain the number of the\nrequested page (1-based). When provided in a request, this attribute can be\nused instead of `page_after_value` to jump to a particular results page.\n\nHowever, you can only retrieve up to the 10.000th entry with a page number.\nOnly one, `page`, `page_offset` or `page_after_value`, can be used."
          },
          {
            "name": "page_offset",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Return the page that follows the given number of entries. Overwrites\n`page` and `page_after_value`.\n\nHowever, you can only retrieve up to the 10.000th entry.\nOnly one, `page`, `page_offset` or `page_after_value`, can be used.",
              "title": "Page Offset"
            },
            "description": "Return the page that follows the given number of entries. Overwrites\n`page` and `page_after_value`.\n\nHowever, you can only retrieve up to the 10.000th entry.\nOnly one, `page`, `page_offset` or `page_after_value`, can be used."
          },
          {
            "name": "include",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "description": "Quantities to include for each result. Only those quantities will be\nreturned. At least one id quantity (e.g. `entry_id`) will always be included.",
              "title": "Include"
            },
            "description": "Quantities to include for each result. Only those quantities will be\nreturned. At least one id quantity (e.g. `entry_id`) will always be included."
          },
          {
            "name": "exclude",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "description": "Quantities to exclude for each result. Only all other quantities will\nbe returned. The entity's id quantity (e.g. `entry_id`) cannot be excluded.",
              "title": "Exclude"
            },
            "description": "Quantities to exclude for each result. Only all other quantities will\nbe returned. The entity's id quantity (e.g. `entry_id`) cannot be excluded."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MetadataResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The given owner requires authorization,\nbut no or bad authentication credentials are given.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/entries/rawdir/query": {
      "post": {
        "tags": [
          "entries/raw"
        ],
        "summary": "Search entries and get their raw files metadata",
        "description": "Will perform a search and return a *page* of raw file metadata for entries fulfilling\nthe query. This allows you to get a complete list of all rawfiles with their full\npath in their respective upload and their sizes. The first returned files for each\nentry, is their respective *mainfile*.\n\nEach entry on NOMAD has a set of raw files. These are the files in their original form,\ni.e. as provided by the uploader. More specifically, an entry has a *mainfile*, identified as\nparseable. For CMS entries, the mainfile is usually the main output file of the code. All other\nfiles in the same directory are considered the entries *auxiliary* no matter their role\nor if they were actually parsed by NOMAD.\n\nThis operation supports the usual `owner`, `query`, and `pagination` parameters.",
        "operationId": "post_entries_rawdir_query_entries_rawdir_query_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntriesRawDir"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntriesRawDirResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The given owner requires authorization,\nbut no or bad authentication credentials are given.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      }
    },
    "/entries/rawdir": {
      "get": {
        "tags": [
          "entries/raw"
        ],
        "summary": "Search entries and get their raw files metadata",
        "description": "Will perform a search and return a *page* of raw file metadata for entries fulfilling\nthe query. This allows you to get a complete list of all rawfiles with their full\npath in their respective upload and their sizes. The first returned files for each\nentry, is their respective *mainfile*.\n\nEach entry on NOMAD has a set of raw files. These are the files in their original form,\ni.e. as provided by the uploader. More specifically, an entry has a *mainfile*, identified as\nparseable. For CMS entries, the mainfile is usually the main output file of the code. All other\nfiles in the same directory are considered the entries *auxiliary* no matter their role\nor if they were actually parsed by NOMAD.\n\nThis operation supports the usual `owner`, `query`, and `pagination` parameters.",
        "operationId": "get_entries_rawdir_entries_rawdir_get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "owner",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/Owner"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The `owner` allows to limit the scope of the search based on entry ownership.\nThis is useful if you only want to search among all publicly downloadable\nentries or only among your own entries, etc.\n\nThese are the possible owner values and their meaning:\n\n* `admin`: No restriction. Only usable by an admin user.\n* `all`: Published entries (with or without embargo), or entries that belong to you\n    or are shared with you.\n* `public`: Published entries without embargo.\n* `shared`: Entries that belong to you or are shared with you.\n* `staging`: Unpublished entries that belong to you or are shared with you.\n* `user`: Entries that belong to you.\n* `visible`: Published entries without embargo, or unpublished entries that belong to\n    you or are shared with you.",
              "default": "public",
              "title": "Owner"
            },
            "description": "The `owner` allows to limit the scope of the search based on entry ownership.\nThis is useful if you only want to search among all publicly downloadable\nentries or only among your own entries, etc.\n\nThese are the possible owner values and their meaning:\n\n* `admin`: No restriction. Only usable by an admin user.\n* `all`: Published entries (with or without embargo), or entries that belong to you\n    or are shared with you.\n* `public`: Published entries without embargo.\n* `shared`: Entries that belong to you or are shared with you.\n* `staging`: Unpublished entries that belong to you or are shared with you.\n* `user`: Entries that belong to you.\n* `visible`: Published entries without embargo, or unpublished entries that belong to\n    you or are shared with you."
          },
          {
            "name": "json_query",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "To pass a query string in the format of JSON e.g. '{{\"results.material.elements\": [\"H\", \"O\"]}}'.",
              "title": "Json Query"
            },
            "description": "To pass a query string in the format of JSON e.g. '{{\"results.material.elements\": [\"H\", \"O\"]}}'."
          },
          {
            "name": "q",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "description": "Since we cannot properly offer forms for all parameters in the OpenAPI dashboard,\nyou can use the parameter `q` and encode a query parameter like this\n`atoms__H` or `n_atoms__gt__3`. Multiple usage of `q` will combine parameters with\nlogical *and*.",
              "default": [],
              "title": "Q"
            },
            "description": "Since we cannot properly offer forms for all parameters in the OpenAPI dashboard,\nyou can use the parameter `q` and encode a query parameter like this\n`atoms__H` or `n_atoms__gt__3`. Multiple usage of `q` will combine parameters with\nlogical *and*."
          },
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The page size, e.g. the maximum number of items contained in one response.\nA `page_size` of 0 will return no results.",
              "default": 10,
              "title": "Page Size"
            },
            "description": "The page size, e.g. the maximum number of items contained in one response.\nA `page_size` of 0 will return no results."
          },
          {
            "name": "order_by",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The results are ordered by the values of this field. You can order\nby any indexed scalar value, or one following two special fields:\n\n - `_score`: Sorts by relevance score.\n - `_doc`: Use when sorting does not matter, gives the best performance.\n\nIf omitted, default ordering is applied.",
              "title": "Order By"
            },
            "description": "The results are ordered by the values of this field. You can order\nby any indexed scalar value, or one following two special fields:\n\n - `_score`: Sorts by relevance score.\n - `_doc`: Use when sorting does not matter, gives the best performance.\n\nIf omitted, default ordering is applied."
          },
          {
            "name": "order",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/Direction"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The ordering direction of the results based on `order_by`. Its either\nascending `asc` or descending `desc`. Default is `asc`.",
              "default": "asc",
              "title": "Order"
            },
            "description": "The ordering direction of the results based on `order_by`. Its either\nascending `asc` or descending `desc`. Default is `asc`."
          },
          {
            "name": "page_after_value",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "This attribute defines the position after which the page begins, and is used\nto navigate through the total list of results.\n\nWhen requesting the first page, no value should be provided for\n`page_after_value`. Each response will contain a value `next_page_after_value`,\nwhich can be used to obtain the next page (by setting `page_after_value` in\nyour next request to this value).\n\nThe field is encoded as a string, and the format of `page_after_value` and\n`next_page_after_value` depends on which API method is used.\n\nSome API functions additionally allows a simplified navigation, by specifying\nthe page number in the key `page`. It is however always possible to use\n`page_after_value` and `next_page_after_value` to iterate through the results.",
              "title": "Page After Value"
            },
            "description": "This attribute defines the position after which the page begins, and is used\nto navigate through the total list of results.\n\nWhen requesting the first page, no value should be provided for\n`page_after_value`. Each response will contain a value `next_page_after_value`,\nwhich can be used to obtain the next page (by setting `page_after_value` in\nyour next request to this value).\n\nThe field is encoded as a string, and the format of `page_after_value` and\n`next_page_after_value` depends on which API method is used.\n\nSome API functions additionally allows a simplified navigation, by specifying\nthe page number in the key `page`. It is however always possible to use\n`page_after_value` and `next_page_after_value` to iterate through the results."
          },
          {
            "name": "page",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "For simple, index-based pagination, this should contain the number of the\nrequested page (1-based). When provided in a request, this attribute can be\nused instead of `page_after_value` to jump to a particular results page.\n\nHowever, you can only retrieve up to the 10.000th entry with a page number.\nOnly one, `page`, `page_offset` or `page_after_value`, can be used.",
              "title": "Page"
            },
            "description": "For simple, index-based pagination, this should contain the number of the\nrequested page (1-based). When provided in a request, this attribute can be\nused instead of `page_after_value` to jump to a particular results page.\n\nHowever, you can only retrieve up to the 10.000th entry with a page number.\nOnly one, `page`, `page_offset` or `page_after_value`, can be used."
          },
          {
            "name": "page_offset",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Return the page that follows the given number of entries. Overwrites\n`page` and `page_after_value`.\n\nHowever, you can only retrieve up to the 10.000th entry.\nOnly one, `page`, `page_offset` or `page_after_value`, can be used.",
              "title": "Page Offset"
            },
            "description": "Return the page that follows the given number of entries. Overwrites\n`page` and `page_after_value`.\n\nHowever, you can only retrieve up to the 10.000th entry.\nOnly one, `page`, `page_offset` or `page_after_value`, can be used."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntriesRawDirResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The given owner requires authorization,\nbut no or bad authentication credentials are given.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/entries/raw/query": {
      "post": {
        "tags": [
          "entries/raw"
        ],
        "summary": "Search entries and download their raw files",
        "description": "This operation will perform a search and stream a .zip file with the raw files of the\nfound entries.\n\nEach entry on NOMAD has a set of raw files. These are the files in their original form,\ni.e. as provided by the uploader. More specifically, an entry has a *mainfile*, identified as\nparseable. For CMS entries, the mainfile is usually the main output file of the code. All other\nfiles in the same directory are considered the entries *auxiliary* no matter their role\nor if they were actually parsed by NOMAD.\n\nAfter performing a search (that uses the same parameters as in all search operations),\nNOMAD will iterate through all results and create a .zip-file with all the entries'\nmain and auxiliary files. The files will be organized in the same directory structure\nthat they were uploaded in. The respective upload root directories are further prefixed\nwith the `upload_id` of the respective uploads. The .zip-file will further contain\na `manifest.json` with `upload_id`, `entry_id`, and `mainfile` of each entry.",
        "operationId": "post_entries_raw_query_entries_raw_query_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntriesRaw"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A zip file with the requested raw files. The file is streamed.\nThe content length is not known in advance.",
            "content": {
              "application/zip": {}
            }
          },
          "401": {
            "description": "Unauthorized. The given owner requires authorization,\nbut no or bad authentication credentials are given.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      }
    },
    "/entries/raw": {
      "get": {
        "tags": [
          "entries/raw"
        ],
        "summary": "Search entries and download their raw files",
        "description": "This operation will perform a search and stream a .zip file with the raw files of the\nfound entries.\n\nEach entry on NOMAD has a set of raw files. These are the files in their original form,\ni.e. as provided by the uploader. More specifically, an entry has a *mainfile*, identified as\nparseable. For CMS entries, the mainfile is usually the main output file of the code. All other\nfiles in the same directory are considered the entries *auxiliary* no matter their role\nor if they were actually parsed by NOMAD.\n\nAfter performing a search (that uses the same parameters as in all search operations),\nNOMAD will iterate through all results and create a .zip-file with all the entries'\nmain and auxiliary files. The files will be organized in the same directory structure\nthat they were uploaded in. The respective upload root directories are further prefixed\nwith the `upload_id` of the respective uploads. The .zip-file will further contain\na `manifest.json` with `upload_id`, `entry_id`, and `mainfile` of each entry.",
        "operationId": "get_entries_raw_entries_raw_get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "owner",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/Owner"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The `owner` allows to limit the scope of the search based on entry ownership.\nThis is useful if you only want to search among all publicly downloadable\nentries or only among your own entries, etc.\n\nThese are the possible owner values and their meaning:\n\n* `admin`: No restriction. Only usable by an admin user.\n* `all`: Published entries (with or without embargo), or entries that belong to you\n    or are shared with you.\n* `public`: Published entries without embargo.\n* `shared`: Entries that belong to you or are shared with you.\n* `staging`: Unpublished entries that belong to you or are shared with you.\n* `user`: Entries that belong to you.\n* `visible`: Published entries without embargo, or unpublished entries that belong to\n    you or are shared with you.",
              "default": "public",
              "title": "Owner"
            },
            "description": "The `owner` allows to limit the scope of the search based on entry ownership.\nThis is useful if you only want to search among all publicly downloadable\nentries or only among your own entries, etc.\n\nThese are the possible owner values and their meaning:\n\n* `admin`: No restriction. Only usable by an admin user.\n* `all`: Published entries (with or without embargo), or entries that belong to you\n    or are shared with you.\n* `public`: Published entries without embargo.\n* `shared`: Entries that belong to you or are shared with you.\n* `staging`: Unpublished entries that belong to you or are shared with you.\n* `user`: Entries that belong to you.\n* `visible`: Published entries without embargo, or unpublished entries that belong to\n    you or are shared with you."
          },
          {
            "name": "json_query",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "To pass a query string in the format of JSON e.g. '{{\"results.material.elements\": [\"H\", \"O\"]}}'.",
              "title": "Json Query"
            },
            "description": "To pass a query string in the format of JSON e.g. '{{\"results.material.elements\": [\"H\", \"O\"]}}'."
          },
          {
            "name": "q",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "description": "Since we cannot properly offer forms for all parameters in the OpenAPI dashboard,\nyou can use the parameter `q` and encode a query parameter like this\n`atoms__H` or `n_atoms__gt__3`. Multiple usage of `q` will combine parameters with\nlogical *and*.",
              "default": [],
              "title": "Q"
            },
            "description": "Since we cannot properly offer forms for all parameters in the OpenAPI dashboard,\nyou can use the parameter `q` and encode a query parameter like this\n`atoms__H` or `n_atoms__gt__3`. Multiple usage of `q` will combine parameters with\nlogical *and*."
          },
          {
            "name": "compress",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "By default the returned zip file is not compressed. This allows to enable compression.\nCompression will reduce the rate at which data is provided, often below\nthe rate of the compression. Therefore, compression is only sensible if the\nnetwork connection is limited.",
              "default": false,
              "title": "Compress"
            },
            "description": "By default the returned zip file is not compressed. This allows to enable compression.\nCompression will reduce the rate at which data is provided, often below\nthe rate of the compression. Therefore, compression is only sensible if the\nnetwork connection is limited."
          },
          {
            "name": "glob_pattern",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "An optional *glob* (or unix style path) pattern that is used to filter the\nreturned files. Only files matching the pattern are returned. The pattern is only\napplied to the end of the full path. Internally\n[fnmatch](https://docs.python.org/3/library/fnmatch.html) is used.",
              "title": "Glob Pattern"
            },
            "description": "An optional *glob* (or unix style path) pattern that is used to filter the\nreturned files. Only files matching the pattern are returned. The pattern is only\napplied to the end of the full path. Internally\n[fnmatch](https://docs.python.org/3/library/fnmatch.html) is used."
          },
          {
            "name": "re_pattern",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "An optional regexp that is used to filter the returned files. Only files matching\nthe pattern are returned. The pattern is applied in search mode to the full\npath of the files. With `$` and `^` you can control if you want to match the\nwhole path.\n\nA re pattern will replace a given glob pattern.",
              "title": "Re Pattern"
            },
            "description": "An optional regexp that is used to filter the returned files. Only files matching\nthe pattern are returned. The pattern is applied in search mode to the full\npath of the files. With `$` and `^` you can control if you want to match the\nwhole path.\n\nA re pattern will replace a given glob pattern."
          },
          {
            "name": "include_files",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "description": "Optional list of file names. Only files with these names are included in the\nresults. This will overwrite any given glob or re pattern.",
              "title": "Include Files"
            },
            "description": "Optional list of file names. Only files with these names are included in the\nresults. This will overwrite any given glob or re pattern."
          },
          {
            "name": "signature_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Signature token used to sign download urls.",
              "title": "Signature Token"
            },
            "description": "Signature token used to sign download urls."
          }
        ],
        "responses": {
          "200": {
            "description": "A zip file with the requested raw files. The file is streamed.\nThe content length is not known in advance.",
            "content": {
              "application/zip": {}
            }
          },
          "401": {
            "description": "Unauthorized. The given owner requires authorization,\nbut no or bad authentication credentials are given.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/entries/export": {
      "get": {
        "tags": [
          "entries/metadata"
        ],
        "summary": "Search entries and download their metadata in selected format",
        "description": "(**Experimental**) Export metadata entries in a selected format.\n\nThis endpoint allows users to export metadata entries in either JSON or CSV format.\nThe format must be specified via the `Content-Type` HTTP header:\n    - `application/json` → Returns the metadata as a JSON response.\n    - `text/csv` → Returns the metadata as a CSV file.",
        "operationId": "export_entries_metadata_entries_export_get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "exclusiveMinimum": 0,
              "default": 10000,
              "title": "Page Size"
            }
          },
          {
            "name": "owner",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/Owner"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The `owner` allows to limit the scope of the search based on entry ownership.\nThis is useful if you only want to search among all publicly downloadable\nentries or only among your own entries, etc.\n\nThese are the possible owner values and their meaning:\n\n* `admin`: No restriction. Only usable by an admin user.\n* `all`: Published entries (with or without embargo), or entries that belong to you\n    or are shared with you.\n* `public`: Published entries without embargo.\n* `shared`: Entries that belong to you or are shared with you.\n* `staging`: Unpublished entries that belong to you or are shared with you.\n* `user`: Entries that belong to you.\n* `visible`: Published entries without embargo, or unpublished entries that belong to\n    you or are shared with you.",
              "default": "public",
              "title": "Owner"
            },
            "description": "The `owner` allows to limit the scope of the search based on entry ownership.\nThis is useful if you only want to search among all publicly downloadable\nentries or only among your own entries, etc.\n\nThese are the possible owner values and their meaning:\n\n* `admin`: No restriction. Only usable by an admin user.\n* `all`: Published entries (with or without embargo), or entries that belong to you\n    or are shared with you.\n* `public`: Published entries without embargo.\n* `shared`: Entries that belong to you or are shared with you.\n* `staging`: Unpublished entries that belong to you or are shared with you.\n* `user`: Entries that belong to you.\n* `visible`: Published entries without embargo, or unpublished entries that belong to\n    you or are shared with you."
          },
          {
            "name": "json_query",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "To pass a query string in the format of JSON e.g. '{{\"results.material.elements\": [\"H\", \"O\"]}}'.",
              "title": "Json Query"
            },
            "description": "To pass a query string in the format of JSON e.g. '{{\"results.material.elements\": [\"H\", \"O\"]}}'."
          },
          {
            "name": "q",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "description": "Since we cannot properly offer forms for all parameters in the OpenAPI dashboard,\nyou can use the parameter `q` and encode a query parameter like this\n`atoms__H` or `n_atoms__gt__3`. Multiple usage of `q` will combine parameters with\nlogical *and*.",
              "default": [],
              "title": "Q"
            },
            "description": "Since we cannot properly offer forms for all parameters in the OpenAPI dashboard,\nyou can use the parameter `q` and encode a query parameter like this\n`atoms__H` or `n_atoms__gt__3`. Multiple usage of `q` will combine parameters with\nlogical *and*."
          },
          {
            "name": "include",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "description": "Quantities to include for each result. Only those quantities will be\nreturned. At least one id quantity (e.g. `entry_id`) will always be included.",
              "title": "Include"
            },
            "description": "Quantities to include for each result. Only those quantities will be\nreturned. At least one id quantity (e.g. `entry_id`) will always be included."
          },
          {
            "name": "exclude",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "description": "Quantities to exclude for each result. Only all other quantities will\nbe returned. The entity's id quantity (e.g. `entry_id`) cannot be excluded.",
              "title": "Exclude"
            },
            "description": "Quantities to exclude for each result. Only all other quantities will\nbe returned. The entity's id quantity (e.g. `entry_id`) cannot be excluded."
          },
          {
            "name": "signature_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Signature token used to sign download urls.",
              "title": "Signature Token"
            },
            "description": "Signature token used to sign download urls."
          },
          {
            "name": "content-type",
            "in": "header",
            "required": false,
            "schema": {
              "type": "string",
              "default": "application/json",
              "title": "Content-Type"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response"
          },
          "401": {
            "description": "Unauthorized. The given owner requires authorization,\nbut no or bad authentication credentials are given.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/entries/archive/query": {
      "post": {
        "tags": [
          "entries/archive"
        ],
        "summary": "Search entries and access their archives",
        "description": "This operation will perform a search with the given `query` and `owner` and return\nthe a *page* of `required` archive data. Look at the body schema or parameter documentation\nfor more details. The **GET** version of this operation will only allow to provide\nthe full archives.",
        "operationId": "post_entries_archive_query_entries_archive_query_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntriesArchive"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntriesArchiveResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The given owner requires authorization,\nbut no or bad authentication credentials are given.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "400": {
            "description": "The given required specification could not be understood.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      }
    },
    "/entries/archive": {
      "get": {
        "tags": [
          "entries/archive"
        ],
        "summary": "Search entries and access their archives",
        "description": "This operation will perform a search with the given `query` and `owner` and return\nthe a *page* of `required` archive data. Look at the body schema or parameter documentation\nfor more details. The **GET** version of this operation will only allow to provide\nthe full archives.",
        "operationId": "get_entries_archive_query_entries_archive_get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "owner",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/Owner"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The `owner` allows to limit the scope of the search based on entry ownership.\nThis is useful if you only want to search among all publicly downloadable\nentries or only among your own entries, etc.\n\nThese are the possible owner values and their meaning:\n\n* `admin`: No restriction. Only usable by an admin user.\n* `all`: Published entries (with or without embargo), or entries that belong to you\n    or are shared with you.\n* `public`: Published entries without embargo.\n* `shared`: Entries that belong to you or are shared with you.\n* `staging`: Unpublished entries that belong to you or are shared with you.\n* `user`: Entries that belong to you.\n* `visible`: Published entries without embargo, or unpublished entries that belong to\n    you or are shared with you.",
              "default": "public",
              "title": "Owner"
            },
            "description": "The `owner` allows to limit the scope of the search based on entry ownership.\nThis is useful if you only want to search among all publicly downloadable\nentries or only among your own entries, etc.\n\nThese are the possible owner values and their meaning:\n\n* `admin`: No restriction. Only usable by an admin user.\n* `all`: Published entries (with or without embargo), or entries that belong to you\n    or are shared with you.\n* `public`: Published entries without embargo.\n* `shared`: Entries that belong to you or are shared with you.\n* `staging`: Unpublished entries that belong to you or are shared with you.\n* `user`: Entries that belong to you.\n* `visible`: Published entries without embargo, or unpublished entries that belong to\n    you or are shared with you."
          },
          {
            "name": "json_query",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "To pass a query string in the format of JSON e.g. '{{\"results.material.elements\": [\"H\", \"O\"]}}'.",
              "title": "Json Query"
            },
            "description": "To pass a query string in the format of JSON e.g. '{{\"results.material.elements\": [\"H\", \"O\"]}}'."
          },
          {
            "name": "q",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "description": "Since we cannot properly offer forms for all parameters in the OpenAPI dashboard,\nyou can use the parameter `q` and encode a query parameter like this\n`atoms__H` or `n_atoms__gt__3`. Multiple usage of `q` will combine parameters with\nlogical *and*.",
              "default": [],
              "title": "Q"
            },
            "description": "Since we cannot properly offer forms for all parameters in the OpenAPI dashboard,\nyou can use the parameter `q` and encode a query parameter like this\n`atoms__H` or `n_atoms__gt__3`. Multiple usage of `q` will combine parameters with\nlogical *and*."
          },
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The page size, e.g. the maximum number of items contained in one response.\nA `page_size` of 0 will return no results.",
              "default": 10,
              "title": "Page Size"
            },
            "description": "The page size, e.g. the maximum number of items contained in one response.\nA `page_size` of 0 will return no results."
          },
          {
            "name": "order_by",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The results are ordered by the values of this field. You can order\nby any indexed scalar value, or one following two special fields:\n\n - `_score`: Sorts by relevance score.\n - `_doc`: Use when sorting does not matter, gives the best performance.\n\nIf omitted, default ordering is applied.",
              "title": "Order By"
            },
            "description": "The results are ordered by the values of this field. You can order\nby any indexed scalar value, or one following two special fields:\n\n - `_score`: Sorts by relevance score.\n - `_doc`: Use when sorting does not matter, gives the best performance.\n\nIf omitted, default ordering is applied."
          },
          {
            "name": "order",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/Direction"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The ordering direction of the results based on `order_by`. Its either\nascending `asc` or descending `desc`. Default is `asc`.",
              "default": "asc",
              "title": "Order"
            },
            "description": "The ordering direction of the results based on `order_by`. Its either\nascending `asc` or descending `desc`. Default is `asc`."
          },
          {
            "name": "page_after_value",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "This attribute defines the position after which the page begins, and is used\nto navigate through the total list of results.\n\nWhen requesting the first page, no value should be provided for\n`page_after_value`. Each response will contain a value `next_page_after_value`,\nwhich can be used to obtain the next page (by setting `page_after_value` in\nyour next request to this value).\n\nThe field is encoded as a string, and the format of `page_after_value` and\n`next_page_after_value` depends on which API method is used.\n\nSome API functions additionally allows a simplified navigation, by specifying\nthe page number in the key `page`. It is however always possible to use\n`page_after_value` and `next_page_after_value` to iterate through the results.",
              "title": "Page After Value"
            },
            "description": "This attribute defines the position after which the page begins, and is used\nto navigate through the total list of results.\n\nWhen requesting the first page, no value should be provided for\n`page_after_value`. Each response will contain a value `next_page_after_value`,\nwhich can be used to obtain the next page (by setting `page_after_value` in\nyour next request to this value).\n\nThe field is encoded as a string, and the format of `page_after_value` and\n`next_page_after_value` depends on which API method is used.\n\nSome API functions additionally allows a simplified navigation, by specifying\nthe page number in the key `page`. It is however always possible to use\n`page_after_value` and `next_page_after_value` to iterate through the results."
          },
          {
            "name": "page",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "For simple, index-based pagination, this should contain the number of the\nrequested page (1-based). When provided in a request, this attribute can be\nused instead of `page_after_value` to jump to a particular results page.\n\nHowever, you can only retrieve up to the 10.000th entry with a page number.\nOnly one, `page`, `page_offset` or `page_after_value`, can be used.",
              "title": "Page"
            },
            "description": "For simple, index-based pagination, this should contain the number of the\nrequested page (1-based). When provided in a request, this attribute can be\nused instead of `page_after_value` to jump to a particular results page.\n\nHowever, you can only retrieve up to the 10.000th entry with a page number.\nOnly one, `page`, `page_offset` or `page_after_value`, can be used."
          },
          {
            "name": "page_offset",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Return the page that follows the given number of entries. Overwrites\n`page` and `page_after_value`.\n\nHowever, you can only retrieve up to the 10.000th entry.\nOnly one, `page`, `page_offset` or `page_after_value`, can be used.",
              "title": "Page Offset"
            },
            "description": "Return the page that follows the given number of entries. Overwrites\n`page` and `page_after_value`.\n\nHowever, you can only retrieve up to the 10.000th entry.\nOnly one, `page`, `page_offset` or `page_after_value`, can be used."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntriesArchiveResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The given owner requires authorization,\nbut no or bad authentication credentials are given.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "400": {
            "description": "The given required specification could not be understood.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/entries/archive/download/query": {
      "post": {
        "tags": [
          "entries/archive"
        ],
        "summary": "Search entries and download their archives",
        "description": "This operation will perform a search with the given `query` and `owner` and stream\na .zip-file with the full archive contents for all matching entries. This is not\npaginated. Look at the body schema or parameter documentation for more details.",
        "operationId": "post_entries_archive_download_query_entries_archive_download_query_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntriesArchiveDownload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A zip file with the requested archive files. The file is streamed.\nThe content length is not known in advance.",
            "content": {
              "application/zip": {}
            }
          },
          "401": {
            "description": "Unauthorized. The given owner requires authorization,\nbut no or bad authentication credentials are given.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "400": {
            "description": "The given required specification could not be understood.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      }
    },
    "/entries/archive/download": {
      "get": {
        "tags": [
          "entries/archive"
        ],
        "summary": "Search entries and download their archives",
        "description": "This operation will perform a search with the given `query` and `owner` and stream\na .zip-file with the full archive contents for all matching entries. This is not\npaginated. Look at the body schema or parameter documentation for more details.",
        "operationId": "get_entries_archive_download_entries_archive_download_get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "owner",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/Owner"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The `owner` allows to limit the scope of the search based on entry ownership.\nThis is useful if you only want to search among all publicly downloadable\nentries or only among your own entries, etc.\n\nThese are the possible owner values and their meaning:\n\n* `admin`: No restriction. Only usable by an admin user.\n* `all`: Published entries (with or without embargo), or entries that belong to you\n    or are shared with you.\n* `public`: Published entries without embargo.\n* `shared`: Entries that belong to you or are shared with you.\n* `staging`: Unpublished entries that belong to you or are shared with you.\n* `user`: Entries that belong to you.\n* `visible`: Published entries without embargo, or unpublished entries that belong to\n    you or are shared with you.",
              "default": "public",
              "title": "Owner"
            },
            "description": "The `owner` allows to limit the scope of the search based on entry ownership.\nThis is useful if you only want to search among all publicly downloadable\nentries or only among your own entries, etc.\n\nThese are the possible owner values and their meaning:\n\n* `admin`: No restriction. Only usable by an admin user.\n* `all`: Published entries (with or without embargo), or entries that belong to you\n    or are shared with you.\n* `public`: Published entries without embargo.\n* `shared`: Entries that belong to you or are shared with you.\n* `staging`: Unpublished entries that belong to you or are shared with you.\n* `user`: Entries that belong to you.\n* `visible`: Published entries without embargo, or unpublished entries that belong to\n    you or are shared with you."
          },
          {
            "name": "json_query",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "To pass a query string in the format of JSON e.g. '{{\"results.material.elements\": [\"H\", \"O\"]}}'.",
              "title": "Json Query"
            },
            "description": "To pass a query string in the format of JSON e.g. '{{\"results.material.elements\": [\"H\", \"O\"]}}'."
          },
          {
            "name": "q",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "description": "Since we cannot properly offer forms for all parameters in the OpenAPI dashboard,\nyou can use the parameter `q` and encode a query parameter like this\n`atoms__H` or `n_atoms__gt__3`. Multiple usage of `q` will combine parameters with\nlogical *and*.",
              "default": [],
              "title": "Q"
            },
            "description": "Since we cannot properly offer forms for all parameters in the OpenAPI dashboard,\nyou can use the parameter `q` and encode a query parameter like this\n`atoms__H` or `n_atoms__gt__3`. Multiple usage of `q` will combine parameters with\nlogical *and*."
          },
          {
            "name": "compress",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "By default the returned zip file is not compressed. This allows to enable compression.\nCompression will reduce the rate at which data is provided, often below\nthe rate of the compression. Therefore, compression is only sensible if the\nnetwork connection is limited.",
              "default": false,
              "title": "Compress"
            },
            "description": "By default the returned zip file is not compressed. This allows to enable compression.\nCompression will reduce the rate at which data is provided, often below\nthe rate of the compression. Therefore, compression is only sensible if the\nnetwork connection is limited."
          },
          {
            "name": "glob_pattern",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "An optional *glob* (or unix style path) pattern that is used to filter the\nreturned files. Only files matching the pattern are returned. The pattern is only\napplied to the end of the full path. Internally\n[fnmatch](https://docs.python.org/3/library/fnmatch.html) is used.",
              "title": "Glob Pattern"
            },
            "description": "An optional *glob* (or unix style path) pattern that is used to filter the\nreturned files. Only files matching the pattern are returned. The pattern is only\napplied to the end of the full path. Internally\n[fnmatch](https://docs.python.org/3/library/fnmatch.html) is used."
          },
          {
            "name": "re_pattern",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "An optional regexp that is used to filter the returned files. Only files matching\nthe pattern are returned. The pattern is applied in search mode to the full\npath of the files. With `$` and `^` you can control if you want to match the\nwhole path.\n\nA re pattern will replace a given glob pattern.",
              "title": "Re Pattern"
            },
            "description": "An optional regexp that is used to filter the returned files. Only files matching\nthe pattern are returned. The pattern is applied in search mode to the full\npath of the files. With `$` and `^` you can control if you want to match the\nwhole path.\n\nA re pattern will replace a given glob pattern."
          },
          {
            "name": "include_files",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "description": "Optional list of file names. Only files with these names are included in the\nresults. This will overwrite any given glob or re pattern.",
              "title": "Include Files"
            },
            "description": "Optional list of file names. Only files with these names are included in the\nresults. This will overwrite any given glob or re pattern."
          },
          {
            "name": "signature_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Signature token used to sign download urls.",
              "title": "Signature Token"
            },
            "description": "Signature token used to sign download urls."
          }
        ],
        "responses": {
          "200": {
            "description": "A zip file with the requested archive files. The file is streamed.\nThe content length is not known in advance.",
            "content": {
              "application/zip": {}
            }
          },
          "401": {
            "description": "Unauthorized. The given owner requires authorization,\nbut no or bad authentication credentials are given.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "400": {
            "description": "The given required specification could not be understood.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/entries/{entry_id}": {
      "get": {
        "tags": [
          "entries/metadata"
        ],
        "summary": "Get the metadata of an entry by its id",
        "description": "Retrives the entry metadata for the given id.",
        "operationId": "get_entry_metadata_entries__entry_id__get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "entry_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique entry id of the entry to retrieve metadata from.",
              "title": "Entry Id"
            },
            "description": "The unique entry id of the entry to retrieve metadata from."
          },
          {
            "name": "include",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "description": "Quantities to include for each result. Only those quantities will be\nreturned. At least one id quantity (e.g. `entry_id`) will always be included.",
              "title": "Include"
            },
            "description": "Quantities to include for each result. Only those quantities will be\nreturned. At least one id quantity (e.g. `entry_id`) will always be included."
          },
          {
            "name": "exclude",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "description": "Quantities to exclude for each result. Only all other quantities will\nbe returned. The entity's id quantity (e.g. `entry_id`) cannot be excluded.",
              "title": "Exclude"
            },
            "description": "Quantities to exclude for each result. Only all other quantities will\nbe returned. The entity's id quantity (e.g. `entry_id`) cannot be excluded."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntryMetadataResponse"
                }
              }
            }
          },
          "404": {
            "description": "Entry not found. The given id does not match any entry.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/entries/{entry_id}/rawdir": {
      "get": {
        "tags": [
          "entries/raw"
        ],
        "summary": "Get the raw files metadata for an entry by its id",
        "description": "Returns the file metadata for all input and output files (including auxiliary files)\nof the given `entry_id`. The first file will be the *mainfile*.",
        "operationId": "get_entry_rawdir_entries__entry_id__rawdir_get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "entry_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique entry id of the entry to retrieve raw data from.",
              "title": "Entry Id"
            },
            "description": "The unique entry id of the entry to retrieve raw data from."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntryRawDirResponse"
                }
              }
            }
          },
          "404": {
            "description": "Entry not found. The given id does not match any entry.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/entries/{entry_id}/raw": {
      "get": {
        "tags": [
          "entries/raw"
        ],
        "summary": "Get the raw data of an entry by its id",
        "description": "Streams a .zip file with the raw files from the requested entry.",
        "operationId": "get_entry_raw_entries__entry_id__raw_get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "entry_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique entry id of the entry to retrieve raw data from.",
              "title": "Entry Id"
            },
            "description": "The unique entry id of the entry to retrieve raw data from."
          },
          {
            "name": "compress",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "By default the returned zip file is not compressed. This allows to enable compression.\nCompression will reduce the rate at which data is provided, often below\nthe rate of the compression. Therefore, compression is only sensible if the\nnetwork connection is limited.",
              "default": false,
              "title": "Compress"
            },
            "description": "By default the returned zip file is not compressed. This allows to enable compression.\nCompression will reduce the rate at which data is provided, often below\nthe rate of the compression. Therefore, compression is only sensible if the\nnetwork connection is limited."
          },
          {
            "name": "glob_pattern",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "An optional *glob* (or unix style path) pattern that is used to filter the\nreturned files. Only files matching the pattern are returned. The pattern is only\napplied to the end of the full path. Internally\n[fnmatch](https://docs.python.org/3/library/fnmatch.html) is used.",
              "title": "Glob Pattern"
            },
            "description": "An optional *glob* (or unix style path) pattern that is used to filter the\nreturned files. Only files matching the pattern are returned. The pattern is only\napplied to the end of the full path. Internally\n[fnmatch](https://docs.python.org/3/library/fnmatch.html) is used."
          },
          {
            "name": "re_pattern",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "An optional regexp that is used to filter the returned files. Only files matching\nthe pattern are returned. The pattern is applied in search mode to the full\npath of the files. With `$` and `^` you can control if you want to match the\nwhole path.\n\nA re pattern will replace a given glob pattern.",
              "title": "Re Pattern"
            },
            "description": "An optional regexp that is used to filter the returned files. Only files matching\nthe pattern are returned. The pattern is applied in search mode to the full\npath of the files. With `$` and `^` you can control if you want to match the\nwhole path.\n\nA re pattern will replace a given glob pattern."
          },
          {
            "name": "include_files",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "description": "Optional list of file names. Only files with these names are included in the\nresults. This will overwrite any given glob or re pattern.",
              "title": "Include Files"
            },
            "description": "Optional list of file names. Only files with these names are included in the\nresults. This will overwrite any given glob or re pattern."
          },
          {
            "name": "signature_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Signature token used to sign download urls.",
              "title": "Signature Token"
            },
            "description": "Signature token used to sign download urls."
          }
        ],
        "responses": {
          "200": {
            "description": "A zip file with the requested raw files. The file is streamed.\nThe content length is not known in advance.",
            "content": {
              "application/zip": {}
            }
          },
          "404": {
            "description": "Entry not found. The given id does not match any entry.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/entries/{entry_id}/raw/{path}": {
      "get": {
        "tags": [
          "entries/raw"
        ],
        "summary": "Get the raw data of an entry by its id",
        "description": "Streams the contents of an individual file from the requested entry.",
        "operationId": "get_entry_raw_file_entries__entry_id__raw__path__get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "entry_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique entry id of the entry to retrieve raw data from.",
              "title": "Entry Id"
            },
            "description": "The unique entry id of the entry to retrieve raw data from."
          },
          {
            "name": "path",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "A relative path to a file based on the directory of the entry's mainfile.",
              "title": "Path"
            },
            "description": "A relative path to a file based on the directory of the entry's mainfile."
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer",
                  "minimum": 0
                },
                {
                  "type": "null"
                }
              ],
              "description": "Integer offset that marks the start of the contents to retrieve. Default\nis the start of the file.",
              "default": 0,
              "title": "Offset"
            },
            "description": "Integer offset that marks the start of the contents to retrieve. Default\nis the start of the file."
          },
          {
            "name": "length",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer",
                  "minimum": -1
                },
                {
                  "type": "null"
                }
              ],
              "description": "The amounts of contents in bytes to stream. By default, the remainder of\nthe file is streamed.",
              "default": -1,
              "title": "Length"
            },
            "description": "The amounts of contents in bytes to stream. By default, the remainder of\nthe file is streamed."
          },
          {
            "name": "decompress",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Attempt to decompress the contents, if the file is .gz or .xz.",
              "default": false,
              "title": "Decompress"
            },
            "description": "Attempt to decompress the contents, if the file is .gz or .xz."
          },
          {
            "name": "signature_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Signature token used to sign download urls.",
              "title": "Signature Token"
            },
            "description": "Signature token used to sign download urls."
          }
        ],
        "responses": {
          "200": {
            "description": "A byte stream with raw file contents. The content length is not known in advance.\nIf the whole file is requested, the mime-type might be more specific, depending\non the file contents.",
            "content": {
              "application/octet-stream": {}
            }
          },
          "404": {
            "description": "File or directory not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/entries/{entry_id}/edit": {
      "post": {
        "tags": [
          "entries/raw"
        ],
        "summary": "Edit a raw mainfile in archive format.",
        "operationId": "post_entry_edit_entries__entry_id__edit_post",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "entry_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique entry id of the entry to edit.",
              "title": "Entry Id"
            },
            "description": "The unique entry id of the entry to edit."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntryEdit"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntryEditResponse"
                }
              }
            }
          },
          "404": {
            "description": "Entry not found. The given id does not match any entry.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "400": {
            "description": "Edit request could not be executed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "401": {
            "description": "Not enough permissions to execute edit request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/entries/{entry_id}/archive": {
      "get": {
        "tags": [
          "entries/archive"
        ],
        "summary": "Get the archive for an entry by its id",
        "description": "Returns the full archive for the given `entry_id`.",
        "operationId": "get_entry_archive_entries__entry_id__archive_get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "entry_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique entry id of the entry to retrieve archive data from.",
              "title": "Entry Id"
            },
            "description": "The unique entry id of the entry to retrieve archive data from."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntryArchiveResponse"
                }
              }
            }
          },
          "404": {
            "description": "Entry not found. The given id does not match any entry.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/entries/{entry_id}/archive/download": {
      "get": {
        "tags": [
          "entries/archive"
        ],
        "summary": "Get the archive for an entry by its id as plain archive json",
        "description": "Returns the full archive for the given `entry_id`.",
        "operationId": "get_entry_archive_download_entries__entry_id__archive_download_get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "entry_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique entry id of the entry to retrieve archive data from.",
              "title": "Entry Id"
            },
            "description": "The unique entry id of the entry to retrieve archive data from."
          },
          {
            "name": "signature_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Signature token used to sign download urls.",
              "title": "Signature Token"
            },
            "description": "Signature token used to sign download urls."
          }
        ],
        "responses": {
          "200": {
            "description": "A json body with the requested archive.",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "404": {
            "description": "Entry not found. The given id does not match any entry.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/entries/{entry_id}/archive/query": {
      "post": {
        "tags": [
          "entries/archive"
        ],
        "summary": "Get the archive for an entry by its id",
        "description": "Returns a partial archive for the given `entry_id` based on the `required` specified\nin the body.",
        "operationId": "post_entry_archive_query_entries__entry_id__archive_query_post",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "entry_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique entry id of the entry to retrieve archive data from.",
              "title": "Entry Id"
            },
            "description": "The unique entry id of the entry to retrieve archive data from."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntryArchiveRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntryArchiveResponse"
                }
              }
            }
          },
          "404": {
            "description": "Entry not found. The given id does not match any entry.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "400": {
            "description": "The given required specification could not be understood.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/entries/edit_v0": {
      "post": {
        "tags": [
          "entries/metadata"
        ],
        "summary": "Edit the user metadata of a set of entries",
        "description": "Performs or validates edit actions on a set of entries that match a given query.",
        "operationId": "post_entry_metadata_edit_entries_edit_v0_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntryMetadataEdit"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntryMetadataEditResponse"
                }
              }
            }
          },
          "400": {
            "description": "The given edit actions cannot be performed by you on the given query.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      }
    },
    "/entries/edit": {
      "post": {
        "tags": [
          "entries/metadata"
        ],
        "summary": "Edit the user metadata of a set of entries",
        "description": "Updates the metadata of the specified entries.\n\n**Note:**\n  - Only admins can edit some of the fields.\n  - Only entry level attributes (like `comment`, `references` etc.) can be set using\n    this endpoint; upload level attributes (like `upload_name`, `coauthors`, embargo\n    settings, etc) need to be set through the endpoint **uploads/upload_id/edit**.\n  - If the upload is published, the only operation permitted using this endpoint is to\n    edit the entries in datasets that where created by the current user.",
        "operationId": "post_entries_edit_entries_edit_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MetadataEditRequest-Input"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MetadataEditRequest-Output"
                }
              }
            }
          },
          "400": {
            "description": "Edit request could not be executed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "401": {
            "description": "Not enough permissions to execute edit request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "404": {
            "description": "No matching entries found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      }
    },
    "/federation/logs/": {
      "post": {
        "tags": [
          "federation"
        ],
        "summary": "Receive logs in logstash format from other Nomad installations and store into central logstash for further analysis.",
        "operationId": "logs_federation_logs__post",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          }
        }
      }
    },
    "/graph/raw_query": {
      "post": {
        "tags": [
          "graph"
        ],
        "summary": "Query the database with a graph style without verification.",
        "description": "Query the database with a graph style without verification.",
        "operationId": "raw_query_graph_raw_query_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "title": "Query"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      }
    },
    "/graph/query": {
      "post": {
        "tags": [
          "graph"
        ],
        "summary": "Query the database with a graph style.",
        "description": "Query the database with a graph style.",
        "operationId": "basic_query_graph_query_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GraphRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GraphResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      }
    },
    "/graph/archive/query": {
      "post": {
        "tags": [
          "graph"
        ],
        "summary": "Search entries and access their archives",
        "operationId": "archive_query_graph_archive_query_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntriesArchive"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      }
    },
    "/groups": {
      "get": {
        "tags": [
          "groups"
        ],
        "summary": "List user groups. Use at most one filter.",
        "description": "Get data about user groups.",
        "operationId": "get_user_groups_groups_get",
        "parameters": [
          {
            "name": "group_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "description": "Search groups by their full id (scalar or list).",
              "title": "Group Id"
            },
            "description": "Search groups by their full id (scalar or list)."
          },
          {
            "name": "user_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Search groups by their owner's or members' ids.",
              "title": "User Id"
            },
            "description": "Search groups by their owner's or members' ids."
          },
          {
            "name": "search_terms",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Search groups by parts of their name.",
              "title": "Search Terms"
            },
            "description": "Search groups by parts of their name."
          },
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The page size, e.g. the maximum number of items contained in one response.\nA `page_size` of 0 will return no results.",
              "default": 10,
              "title": "Page Size"
            },
            "description": "The page size, e.g. the maximum number of items contained in one response.\nA `page_size` of 0 will return no results."
          },
          {
            "name": "order_by",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The results are ordered by the values of this field. If omitted, default\nordering is applied.",
              "title": "Order By"
            },
            "description": "The results are ordered by the values of this field. If omitted, default\nordering is applied."
          },
          {
            "name": "order",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/Direction"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The ordering direction of the results based on `order_by`. Its either\nascending `asc` or descending `desc`. Default is `asc`.",
              "default": "asc",
              "title": "Order"
            },
            "description": "The ordering direction of the results based on `order_by`. Its either\nascending `asc` or descending `desc`. Default is `asc`."
          },
          {
            "name": "page_after_value",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "This attribute defines the position after which the page begins, and is used\nto navigate through the total list of results.\n\nWhen requesting the first page, no value should be provided for\n`page_after_value`. Each response will contain a value `next_page_after_value`,\nwhich can be used to obtain the next page (by setting `page_after_value` in\nyour next request to this value).\n\nThe field is encoded as a string, and the format of `page_after_value` and\n`next_page_after_value` depends on which API method is used.\n\nSome API functions additionally allows a simplified navigation, by specifying\nthe page number in the key `page`. It is however always possible to use\n`page_after_value` and `next_page_after_value` to iterate through the results.",
              "title": "Page After Value"
            },
            "description": "This attribute defines the position after which the page begins, and is used\nto navigate through the total list of results.\n\nWhen requesting the first page, no value should be provided for\n`page_after_value`. Each response will contain a value `next_page_after_value`,\nwhich can be used to obtain the next page (by setting `page_after_value` in\nyour next request to this value).\n\nThe field is encoded as a string, and the format of `page_after_value` and\n`next_page_after_value` depends on which API method is used.\n\nSome API functions additionally allows a simplified navigation, by specifying\nthe page number in the key `page`. It is however always possible to use\n`page_after_value` and `next_page_after_value` to iterate through the results."
          },
          {
            "name": "page",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The number of the page (1-based). When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used.",
              "title": "Page"
            },
            "description": "The number of the page (1-based). When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used."
          },
          {
            "name": "page_offset",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The number of skipped entries. When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page_offset` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used.",
              "title": "Page Offset"
            },
            "description": "The number of skipped entries. When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page_offset` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserGroupResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "groups"
        ],
        "summary": "Create user group.",
        "description": "Create user group.",
        "operationId": "create_user_group_groups_post",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserGroupEdit"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserGroup"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/groups/{group_id}": {
      "get": {
        "tags": [
          "groups"
        ],
        "summary": "Get data about user group.",
        "description": "Get data about user group.",
        "operationId": "get_user_group_groups__group_id__get",
        "parameters": [
          {
            "name": "group_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Group Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserGroup"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "groups"
        ],
        "summary": "Delete user group.",
        "description": "Delete user group.",
        "operationId": "delete_user_group_groups__group_id__delete",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "group_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Group Id"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/groups/{group_id}/edit": {
      "post": {
        "tags": [
          "groups"
        ],
        "summary": "Update user group.",
        "description": "Update user group.",
        "operationId": "update_user_group_groups__group_id__edit_post",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "group_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Group Id"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserGroupEdit"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserGroup"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/info": {
      "get": {
        "tags": [
          "info"
        ],
        "summary": "Get information about the nomad backend and its configuration",
        "description": "Return information about the nomad backend and its configuration.",
        "operationId": "get_info_info_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InfoModel"
                }
              }
            }
          }
        }
      }
    },
    "/materials/query": {
      "post": {
        "tags": [
          "materials"
        ],
        "summary": "Search materials and retrieve their metadata",
        "description": "Executes a *query* and returns a *page* of the results with *required* result data\nas well as *statistics* and *aggregated* data.\n\nThis is the basic search operation to retrieve metadata for entries that match\ncertain search criteria (`query` and `owner`). All parameters (including `query`, `owner`)\nare optional. Look at the body schema or parameter documentation for more details.\n\nBy default the *empty* search (that returns everything) is performed. Only a small\npage of the search results are returned at a time; use `pagination` in subsequent\nrequests to retrive more data. Each entry has a lot of different *metadata*, use\n`required` to limit the data that is returned.\n\nThe `statistics` and `aggregations` keys will further allow to return statistics\nand aggregated data over all search results.",
        "operationId": "post_entries_metadata_query_materials_query_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Metadata"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MetadataResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The given owner requires authorization,\nbut no or bad authentication credentials are given.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      }
    },
    "/materials": {
      "get": {
        "tags": [
          "materials"
        ],
        "summary": "Search materials and retrieve their metadata",
        "description": "Executes a *query* and returns a *page* of the results with *required* result data.\nThis is a version of `/entries/query`. Queries work a little different, because\nwe cannot put complex queries into URL parameters.\n\nIn addition to the `q` parameter (see parameter documentation for details), you can use all NOMAD\nsearch quantities as parameters, e.g. `?atoms=H&atoms=O`. Those quantities can be\nused with additional operators attached to their names, e.g. `?n_atoms__gte=3` for\nall entries with more than 3 atoms. Operators are `all`, `any`, `none`, `gte`,\n`gt`, `lt`, `lte`.",
        "operationId": "get_entries_metadata_materials_get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "owner",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/Owner"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The `owner` allows to limit the scope of the search based on entry ownership.\nThis is useful if you only want to search among all publicly downloadable\nentries or only among your own entries, etc.\n\nThese are the possible owner values and their meaning:\n\n* `admin`: No restriction. Only usable by an admin user.\n* `all`: Published entries (with or without embargo), or entries that belong to you\n    or are shared with you.\n* `public`: Published entries without embargo.\n* `shared`: Entries that belong to you or are shared with you.\n* `staging`: Unpublished entries that belong to you or are shared with you.\n* `user`: Entries that belong to you.\n* `visible`: Published entries without embargo, or unpublished entries that belong to\n    you or are shared with you.",
              "default": "public",
              "title": "Owner"
            },
            "description": "The `owner` allows to limit the scope of the search based on entry ownership.\nThis is useful if you only want to search among all publicly downloadable\nentries or only among your own entries, etc.\n\nThese are the possible owner values and their meaning:\n\n* `admin`: No restriction. Only usable by an admin user.\n* `all`: Published entries (with or without embargo), or entries that belong to you\n    or are shared with you.\n* `public`: Published entries without embargo.\n* `shared`: Entries that belong to you or are shared with you.\n* `staging`: Unpublished entries that belong to you or are shared with you.\n* `user`: Entries that belong to you.\n* `visible`: Published entries without embargo, or unpublished entries that belong to\n    you or are shared with you."
          },
          {
            "name": "json_query",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "To pass a query string in the format of JSON e.g. '{{\"results.material.elements\": [\"H\", \"O\"]}}'.",
              "title": "Json Query"
            },
            "description": "To pass a query string in the format of JSON e.g. '{{\"results.material.elements\": [\"H\", \"O\"]}}'."
          },
          {
            "name": "q",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "description": "Since we cannot properly offer forms for all parameters in the OpenAPI dashboard,\nyou can use the parameter `q` and encode a query parameter like this\n`atoms__H` or `n_atoms__gt__3`. Multiple usage of `q` will combine parameters with\nlogical *and*.",
              "default": [],
              "title": "Q"
            },
            "description": "Since we cannot properly offer forms for all parameters in the OpenAPI dashboard,\nyou can use the parameter `q` and encode a query parameter like this\n`atoms__H` or `n_atoms__gt__3`. Multiple usage of `q` will combine parameters with\nlogical *and*."
          },
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The page size, e.g. the maximum number of items contained in one response.\nA `page_size` of 0 will return no results.",
              "default": 10,
              "title": "Page Size"
            },
            "description": "The page size, e.g. the maximum number of items contained in one response.\nA `page_size` of 0 will return no results."
          },
          {
            "name": "order_by",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The results are ordered by the values of this field. You can order\nby any indexed scalar value, or one following two special fields:\n\n - `_score`: Sorts by relevance score.\n - `_doc`: Use when sorting does not matter, gives the best performance.\n\nIf omitted, default ordering is applied.",
              "title": "Order By"
            },
            "description": "The results are ordered by the values of this field. You can order\nby any indexed scalar value, or one following two special fields:\n\n - `_score`: Sorts by relevance score.\n - `_doc`: Use when sorting does not matter, gives the best performance.\n\nIf omitted, default ordering is applied."
          },
          {
            "name": "order",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/Direction"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The ordering direction of the results based on `order_by`. Its either\nascending `asc` or descending `desc`. Default is `asc`.",
              "default": "asc",
              "title": "Order"
            },
            "description": "The ordering direction of the results based on `order_by`. Its either\nascending `asc` or descending `desc`. Default is `asc`."
          },
          {
            "name": "page_after_value",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "This attribute defines the position after which the page begins, and is used\nto navigate through the total list of results.\n\nWhen requesting the first page, no value should be provided for\n`page_after_value`. Each response will contain a value `next_page_after_value`,\nwhich can be used to obtain the next page (by setting `page_after_value` in\nyour next request to this value).\n\nThe field is encoded as a string, and the format of `page_after_value` and\n`next_page_after_value` depends on which API method is used.\n\nSome API functions additionally allows a simplified navigation, by specifying\nthe page number in the key `page`. It is however always possible to use\n`page_after_value` and `next_page_after_value` to iterate through the results.",
              "title": "Page After Value"
            },
            "description": "This attribute defines the position after which the page begins, and is used\nto navigate through the total list of results.\n\nWhen requesting the first page, no value should be provided for\n`page_after_value`. Each response will contain a value `next_page_after_value`,\nwhich can be used to obtain the next page (by setting `page_after_value` in\nyour next request to this value).\n\nThe field is encoded as a string, and the format of `page_after_value` and\n`next_page_after_value` depends on which API method is used.\n\nSome API functions additionally allows a simplified navigation, by specifying\nthe page number in the key `page`. It is however always possible to use\n`page_after_value` and `next_page_after_value` to iterate through the results."
          },
          {
            "name": "page",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "For simple, index-based pagination, this should contain the number of the\nrequested page (1-based). When provided in a request, this attribute can be\nused instead of `page_after_value` to jump to a particular results page.\n\nHowever, you can only retrieve up to the 10.000th entry with a page number.\nOnly one, `page`, `page_offset` or `page_after_value`, can be used.",
              "title": "Page"
            },
            "description": "For simple, index-based pagination, this should contain the number of the\nrequested page (1-based). When provided in a request, this attribute can be\nused instead of `page_after_value` to jump to a particular results page.\n\nHowever, you can only retrieve up to the 10.000th entry with a page number.\nOnly one, `page`, `page_offset` or `page_after_value`, can be used."
          },
          {
            "name": "page_offset",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Return the page that follows the given number of entries. Overwrites\n`page` and `page_after_value`.\n\nHowever, you can only retrieve up to the 10.000th entry.\nOnly one, `page`, `page_offset` or `page_after_value`, can be used.",
              "title": "Page Offset"
            },
            "description": "Return the page that follows the given number of entries. Overwrites\n`page` and `page_after_value`.\n\nHowever, you can only retrieve up to the 10.000th entry.\nOnly one, `page`, `page_offset` or `page_after_value`, can be used."
          },
          {
            "name": "include",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "description": "Quantities to include for each result. Only those quantities will be\nreturned. At least one id quantity (e.g. `entry_id`) will always be included.",
              "title": "Include"
            },
            "description": "Quantities to include for each result. Only those quantities will be\nreturned. At least one id quantity (e.g. `entry_id`) will always be included."
          },
          {
            "name": "exclude",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "description": "Quantities to exclude for each result. Only all other quantities will\nbe returned. The entity's id quantity (e.g. `entry_id`) cannot be excluded.",
              "title": "Exclude"
            },
            "description": "Quantities to exclude for each result. Only all other quantities will\nbe returned. The entity's id quantity (e.g. `entry_id`) cannot be excluded."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MetadataResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The given owner requires authorization,\nbut no or bad authentication credentials are given.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/materials/{material_id}": {
      "get": {
        "tags": [
          "materials"
        ],
        "summary": "Get the metadata of a material by its id",
        "description": "Retrives the material metadata for the given id.",
        "operationId": "get_material_metadata_materials__material_id__get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "material_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique material id of the material to retrieve metadata from.",
              "title": "Material Id"
            },
            "description": "The unique material id of the material to retrieve metadata from."
          },
          {
            "name": "include",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "description": "Quantities to include for each result. Only those quantities will be\nreturned. At least one id quantity (e.g. `entry_id`) will always be included.",
              "title": "Include"
            },
            "description": "Quantities to include for each result. Only those quantities will be\nreturned. At least one id quantity (e.g. `entry_id`) will always be included."
          },
          {
            "name": "exclude",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "description": "Quantities to exclude for each result. Only all other quantities will\nbe returned. The entity's id quantity (e.g. `entry_id`) cannot be excluded.",
              "title": "Exclude"
            },
            "description": "Quantities to exclude for each result. Only all other quantities will\nbe returned. The entity's id quantity (e.g. `entry_id`) cannot be excluded."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MaterialMetadataResponse"
                }
              }
            }
          },
          "404": {
            "description": "Material not found. The given id does not match any material.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/metainfo/{section_definition_id}": {
      "get": {
        "tags": [
          "metainfo"
        ],
        "summary": "Get the definition of package that contains the target id based section definition.",
        "description": "Retrieve the package that contains the target section.",
        "operationId": "get_package_definition_metainfo__section_definition_id__get",
        "parameters": [
          {
            "name": "section_definition_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "pattern": "^\\w{40}$",
              "description": "The section definition id to be used to retrieve package.",
              "title": "Section Definition Id"
            },
            "description": "The section definition id to be used to retrieve package."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PackageDefinitionResponse"
                }
              }
            }
          },
          "404": {
            "description": "Package not found. The given section definition is not contained in any packages.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/north/": {
      "get": {
        "tags": [
          "north"
        ],
        "summary": "Get a list of all configured tools and their current state.",
        "operationId": "get_tools_north__get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ToolsResponseModel"
                }
              }
            }
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      }
    },
    "/north/{name}": {
      "get": {
        "tags": [
          "north"
        ],
        "summary": "Get information for a specific tool.",
        "operationId": "get_tool_north__name__get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Name"
            }
          },
          {
            "name": "upload_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Upload Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ToolResponseModel"
                }
              }
            }
          },
          "404": {
            "description": "The tool does not exist.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "north"
        ],
        "summary": "Start a tool.",
        "operationId": "start_tool_north__name__post",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Name"
            }
          },
          {
            "name": "upload_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Upload Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ToolResponseModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "north"
        ],
        "summary": "Stop a tool.",
        "operationId": "stop_tool_north__name__delete",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Name"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ToolResponseModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/suggestions": {
      "post": {
        "tags": [
          "suggestions"
        ],
        "summary": "Get a list of suggestions for the given quantity names and input.",
        "operationId": "get_suggestions_suggestions_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SuggestionsRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "additionalProperties": {
                    "items": {
                      "$ref": "#/components/schemas/Suggestion"
                    },
                    "type": "array"
                  },
                  "type": "object",
                  "title": "Response Get Suggestions Suggestions Post"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      }
    },
    "/systems/{entry_id}": {
      "get": {
        "tags": [
          "systems"
        ],
        "summary": "Build and retrieve an atomistic structure file from data within an entry.",
        "description": "Build and retrieve a structure file containing an atomistic system stored\nwithin an entry.\n\nAll length dimensions in the structure files are in Ångstroms (=1e-10 meter).\n\nNote that some formats are more restricted and cannot fully\ndescribe certains kinds of systems. For examples some entries within NOMAD\ndo not contain a unit cell (e.g. molecules), whereas some formats require it\nto be present.",
        "operationId": "get_entry_raw_file_systems__entry_id__get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "entry_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique entry id of the entry to retrieve archive data from.",
              "title": "Entry Id"
            },
            "description": "The unique entry id of the entry to retrieve archive data from."
          },
          {
            "name": "path",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Path to a NOMAD System inside the archive. The targeted path should\npoint to a system in `run.system` or `results.material.topology`.\nThe following path types are supported:\n\n- `run/0/system/0`: Path to system in `run.system`\n- `results/material/topology/0`: Path to system in `results.material.topology`\n- `run/0/system/-1`: Negative indices are supported.",
              "title": "Path"
            },
            "description": "Path to a NOMAD System inside the archive. The targeted path should\npoint to a system in `run.system` or `results.material.topology`.\nThe following path types are supported:\n\n- `run/0/system/0`: Path to system in `run.system`\n- `results/material/topology/0`: Path to system in `results.material.topology`\n- `run/0/system/-1`: Negative indices are supported.",
            "example": "run/0/system/0"
          },
          {
            "name": "format",
            "in": "query",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/FormatEnum",
              "description": "The file format for the system. The following formats are supported:\n\n- `cif`: Crystallographic Information File\n- `xyz`: XYZ file. The comment line contains information that\n        complies with the extended XYZ specification.\n- `pdb`: Protein Data Bank file. Note that valid PDB files\n        require a CRYST1 record, while certains systems in NOMAD may not have a\n        unit cell associated with them. In this case the returned structure file\n        will contain a dummy CRYST1 record in order to load the atomic\n        positions.\n\nHere is a brief rundown of the different features each format supports:\n\nFormat|Cartesian positions without unit cell|Full lattice vectors|Periodic boundary conditions (PBC)\n:---|:---:|:---:|:---:\ncif|&#9745;|&#9744;|&#9744;\nxyz|&#9745;|&#9745;|&#9745;\npdb|&#9744;|&#9744;|&#9744;",
              "default": "cif"
            },
            "description": "The file format for the system. The following formats are supported:\n\n- `cif`: Crystallographic Information File\n- `xyz`: XYZ file. The comment line contains information that\n        complies with the extended XYZ specification.\n- `pdb`: Protein Data Bank file. Note that valid PDB files\n        require a CRYST1 record, while certains systems in NOMAD may not have a\n        unit cell associated with them. In this case the returned structure file\n        will contain a dummy CRYST1 record in order to load the atomic\n        positions.\n\nHere is a brief rundown of the different features each format supports:\n\nFormat|Cartesian positions without unit cell|Full lattice vectors|Periodic boundary conditions (PBC)\n:---|:---:|:---:|:---:\ncif|&#9745;|&#9744;|&#9744;\nxyz|&#9745;|&#9745;|&#9745;\npdb|&#9744;|&#9744;|&#9744;"
          },
          {
            "name": "wrap_mode",
            "in": "query",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/WrapModeEnum",
              "description": "Determines how to handle atomic positions for the requested system. The available options are:\n\n- `original`: The original positions as set in the data\n- `wrap`: Positions are wrapped to be inside the cell respecting periodic boundary conditions\n- `unwrap`: Positions are reconstructed so that the structure is not split by\nperiodic cell boundaries. Note that this produces meaningful results\nonly if the system dimensions are smaller than the unit cell.\n\n            ",
              "default": "original"
            },
            "description": "Determines how to handle atomic positions for the requested system. The available options are:\n\n- `original`: The original positions as set in the data\n- `wrap`: Positions are wrapped to be inside the cell respecting periodic boundary conditions\n- `unwrap`: Positions are reconstructed so that the structure is not split by\nperiodic cell boundaries. Note that this produces meaningful results\nonly if the system dimensions are smaller than the unit cell.\n\n            "
          },
          {
            "name": "signature_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Signature token used to sign download urls.",
              "title": "Signature Token"
            },
            "description": "Signature token used to sign download urls."
          }
        ],
        "responses": {
          "200": {
            "description": "A byte stream with file contents. The content length is not known in advance.\nThe final mime-type may be more specific depending on the format.",
            "content": {
              "application/octet-stream": {}
            }
          },
          "404": {
            "description": "Could not find data for given entry id and path. Check that the\narguments are correct and that you are authorized to access the data.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "500": {
            "description": "Could not serialize the system information in the given format. The\ninformation may be invalid or incomplete for this format.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/uploads/command-examples": {
      "get": {
        "tags": [
          "uploads"
        ],
        "summary": "Get example commands for shell based uploads.",
        "description": "Get url and example command for shell based uploads.",
        "operationId": "get_command_examples_uploads_command_examples_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UploadCommandExamplesResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Authorization is required, but no or bad authentication credentials provided.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      }
    },
    "/uploads": {
      "get": {
        "tags": [
          "uploads/metadata"
        ],
        "summary": "List uploads of authenticated user.",
        "description": "Retrieves metadata about all uploads that match the given query criteria.",
        "operationId": "get_uploads_uploads_get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "roles",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/UploadRole"
              },
              "description": "Only return uploads where the user has one of the given roles.",
              "title": "Roles"
            },
            "description": "Only return uploads where the user has one of the given roles."
          },
          {
            "name": "include_all",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "Include uploads that are shared with all users.",
              "default": false,
              "title": "Include All"
            },
            "description": "Include uploads that are shared with all users."
          },
          {
            "name": "upload_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "description": "Search for uploads matching the given id. Multiple values can be specified.",
              "title": "Upload Id"
            },
            "description": "Search for uploads matching the given id. Multiple values can be specified."
          },
          {
            "name": "upload_name",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "description": "Search for uploads matching the given upload_name. Multiple values can be specified.",
              "title": "Upload Name"
            },
            "description": "Search for uploads matching the given upload_name. Multiple values can be specified."
          },
          {
            "name": "is_processing",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "If True, only include currently processing uploads.\nIf False, do not include currently processing uploads.\nIf unset, include everything.",
              "title": "Is Processing"
            },
            "description": "If True, only include currently processing uploads.\nIf False, do not include currently processing uploads.\nIf unset, include everything."
          },
          {
            "name": "is_published",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "If True: only include published uploads.\nIf False: only include unpublished uploads.\nIf unset: include everything.",
              "title": "Is Published"
            },
            "description": "If True: only include published uploads.\nIf False: only include unpublished uploads.\nIf unset: include everything."
          },
          {
            "name": "process_status",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Search by the process status.",
              "title": "Process Status"
            },
            "description": "Search by the process status."
          },
          {
            "name": "is_owned",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "If True: only include owned uploads.\nIf False: only include shared uploads.\nIf unset: include everything.",
              "title": "Is Owned"
            },
            "description": "If True: only include owned uploads.\nIf False: only include shared uploads.\nIf unset: include everything."
          },
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The page size, e.g. the maximum number of items contained in one response.\nA `page_size` of 0 will return no results.",
              "default": 10,
              "title": "Page Size"
            },
            "description": "The page size, e.g. the maximum number of items contained in one response.\nA `page_size` of 0 will return no results."
          },
          {
            "name": "order_by",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The results are ordered by the values of this field. If omitted, default\nordering is applied.",
              "title": "Order By"
            },
            "description": "The results are ordered by the values of this field. If omitted, default\nordering is applied."
          },
          {
            "name": "order",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/Direction"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The ordering direction of the results based on `order_by`. Its either\nascending `asc` or descending `desc`. Default is `asc`.",
              "default": "asc",
              "title": "Order"
            },
            "description": "The ordering direction of the results based on `order_by`. Its either\nascending `asc` or descending `desc`. Default is `asc`."
          },
          {
            "name": "page_after_value",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "This attribute defines the position after which the page begins, and is used\nto navigate through the total list of results.\n\nWhen requesting the first page, no value should be provided for\n`page_after_value`. Each response will contain a value `next_page_after_value`,\nwhich can be used to obtain the next page (by setting `page_after_value` in\nyour next request to this value).\n\nThe field is encoded as a string, and the format of `page_after_value` and\n`next_page_after_value` depends on which API method is used.\n\nSome API functions additionally allows a simplified navigation, by specifying\nthe page number in the key `page`. It is however always possible to use\n`page_after_value` and `next_page_after_value` to iterate through the results.",
              "title": "Page After Value"
            },
            "description": "This attribute defines the position after which the page begins, and is used\nto navigate through the total list of results.\n\nWhen requesting the first page, no value should be provided for\n`page_after_value`. Each response will contain a value `next_page_after_value`,\nwhich can be used to obtain the next page (by setting `page_after_value` in\nyour next request to this value).\n\nThe field is encoded as a string, and the format of `page_after_value` and\n`next_page_after_value` depends on which API method is used.\n\nSome API functions additionally allows a simplified navigation, by specifying\nthe page number in the key `page`. It is however always possible to use\n`page_after_value` and `next_page_after_value` to iterate through the results."
          },
          {
            "name": "page",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The number of the page (1-based). When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used.",
              "title": "Page"
            },
            "description": "The number of the page (1-based). When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used."
          },
          {
            "name": "page_offset",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The number of skipped entries. When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page_offset` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used.",
              "title": "Page Offset"
            },
            "description": "The number of skipped entries. When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page_offset` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UploadProcDataQueryResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Authorization is required, but no or bad authentication credentials provided.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. Invalid pagination arguments supplied.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "uploads"
        ],
        "summary": "Submit a new upload",
        "description": "Creates a new, empty upload and, optionally, uploads one or more files to it. If zip or\ntar files are uploaded, they will first be extracted, then added.\n\nIt is recommended to give the upload itself a descriptive `upload_name`. If not specified,\nand a single file is provided, `upload_name` will be set to the name of this file. The\n`upload_name` can also be edited afterwards (as long as the upload is not published).\n\nThere are two basic ways to upload files: in the multipart-formdata or streaming the\nfile data in the http body. Both are supported. Note, however, that the second method\nonly allows the upload of a single file, and that it does not transfer a filename. If a\ntransfer is made using method 2, you can specify the query argument `file_name` to name it.\nThis *needs* to be specified when using method 2, unless you are uploading a zip/tar file\n(for zip/tar files the names don't matter since they are extracted).\n\nExample curl commands for creating an upload and uploading a file:\n\nMethod 1: multipart-formdata\n\n    curl -X 'POST' \"url\" -F file=@local_file\n\nMethod 2: streaming data\n\n    curl -X 'POST' \"url\" -T local_file\n\nAuthentication is required. This can either be done using the regular bearer token,\nor using the simplified upload token. To use the simplified upload token, just\nspecify it as a query parameter in the url, i.e.\n\n    curl -X 'POST' \"baseurl?token=ABC.XYZ\" ...\n\nNote, there is a limit on how many unpublished uploads a user can have. If exceeded,\nerror code 400 will be returned.",
        "operationId": "post_upload_uploads_post",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "local_path",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Internal/Admin use only.",
              "title": "Local Path"
            },
            "description": "Internal/Admin use only."
          },
          {
            "name": "example_upload_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "If provided, instantiates a new upload from the given example upload\nentry point id. You may use this parameter in combination with other\nfile sources.",
              "title": "Example Upload Id"
            },
            "description": "If provided, instantiates a new upload from the given example upload\nentry point id. You may use this parameter in combination with other\nfile sources."
          },
          {
            "name": "file_name",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Specifies the name of the file, when using method 2.",
              "title": "File Name"
            },
            "description": "Specifies the name of the file, when using method 2."
          },
          {
            "name": "upload_name",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "A human readable name for the upload.",
              "title": "Upload Name"
            },
            "description": "A human readable name for the upload."
          },
          {
            "name": "embargo_length",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "description": "The requested embargo length, in months, if any (0-36).",
              "default": 0,
              "title": "Embargo Length"
            },
            "description": "The requested embargo length, in months, if any (0-36)."
          },
          {
            "name": "publish_directly",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "If the upload should be published directly. False by default.",
              "title": "Publish Directly"
            },
            "description": "If the upload should be published directly. False by default."
          },
          {
            "name": "token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Token for simplified authorization for uploading.",
              "title": "Token"
            },
            "description": "Token for simplified authorization for uploading."
          }
        ],
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "schema": {
                "$ref": "#/components/schemas/Body_post_upload_uploads_post"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "A json structure with upload data, or a plain text information string.\nIt will be a json structure if the request headers specifies `Accept = application/json`.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UploadProcDataResponse"
                }
              },
              "text/plain": {
                "example": "Thanks for uploading your data to nomad."
              }
            }
          },
          "401": {
            "description": "Unauthorized. Authorization is required, but no or bad authentication credentials provided.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. The request could not be processed because of some error/invalid argument.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/uploads/{upload_id}": {
      "get": {
        "tags": [
          "uploads/metadata"
        ],
        "summary": "Get a specific upload",
        "description": "Fetches a specific upload by its upload_id.",
        "operationId": "get_upload_uploads__upload_id__get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "upload_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique id of the upload to retrieve.",
              "title": "Upload Id"
            },
            "description": "The unique id of the upload to retrieve."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UploadProcDataResponse"
                }
              }
            }
          },
          "404": {
            "description": "The specified upload could not be found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. No credentials provided, or you do not have permissions to the\nspecified upload.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "uploads"
        ],
        "summary": "Delete an upload",
        "description": "Delete an existing upload.\n\nOnly uploads that are sill in staging, not already deleted, not still uploaded, and\nnot currently processed, can be deleted.",
        "operationId": "delete_upload_uploads__upload_id__delete",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "upload_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique id of the upload to delete.",
              "title": "Upload Id"
            },
            "description": "The unique id of the upload to delete."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UploadProcDataResponse"
                }
              }
            }
          },
          "404": {
            "description": "The specified upload could not be found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. No credentials provided, or you do not have permissions to the\nspecified upload.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. The request could not be processed because of some error/invalid argument.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/uploads/{upload_id}/entries": {
      "get": {
        "tags": [
          "uploads/metadata"
        ],
        "summary": "Get the entries of the specific upload as a list",
        "description": "Fetches the entries of a specific upload. Pagination is used to browse through the\nresults.",
        "operationId": "get_upload_entries_uploads__upload_id__entries_get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "upload_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique id of the upload to retrieve entries for.",
              "title": "Upload Id"
            },
            "description": "The unique id of the upload to retrieve entries for."
          },
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The page size, e.g. the maximum number of items contained in one response.\nA `page_size` of 0 will return no results.",
              "default": 10,
              "title": "Page Size"
            },
            "description": "The page size, e.g. the maximum number of items contained in one response.\nA `page_size` of 0 will return no results."
          },
          {
            "name": "order_by",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The results are ordered by the values of this field. If omitted, default\nordering is applied.",
              "title": "Order By"
            },
            "description": "The results are ordered by the values of this field. If omitted, default\nordering is applied."
          },
          {
            "name": "order",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/Direction"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The ordering direction of the results based on `order_by`. Its either\nascending `asc` or descending `desc`. Default is `asc`.",
              "default": "asc",
              "title": "Order"
            },
            "description": "The ordering direction of the results based on `order_by`. Its either\nascending `asc` or descending `desc`. Default is `asc`."
          },
          {
            "name": "page_after_value",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "This attribute defines the position after which the page begins, and is used\nto navigate through the total list of results.\n\nWhen requesting the first page, no value should be provided for\n`page_after_value`. Each response will contain a value `next_page_after_value`,\nwhich can be used to obtain the next page (by setting `page_after_value` in\nyour next request to this value).\n\nThe field is encoded as a string, and the format of `page_after_value` and\n`next_page_after_value` depends on which API method is used.\n\nSome API functions additionally allows a simplified navigation, by specifying\nthe page number in the key `page`. It is however always possible to use\n`page_after_value` and `next_page_after_value` to iterate through the results.",
              "title": "Page After Value"
            },
            "description": "This attribute defines the position after which the page begins, and is used\nto navigate through the total list of results.\n\nWhen requesting the first page, no value should be provided for\n`page_after_value`. Each response will contain a value `next_page_after_value`,\nwhich can be used to obtain the next page (by setting `page_after_value` in\nyour next request to this value).\n\nThe field is encoded as a string, and the format of `page_after_value` and\n`next_page_after_value` depends on which API method is used.\n\nSome API functions additionally allows a simplified navigation, by specifying\nthe page number in the key `page`. It is however always possible to use\n`page_after_value` and `next_page_after_value` to iterate through the results."
          },
          {
            "name": "page",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The number of the page (1-based). When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used.",
              "title": "Page"
            },
            "description": "The number of the page (1-based). When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used."
          },
          {
            "name": "page_offset",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The number of skipped entries. When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page_offset` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used.",
              "title": "Page Offset"
            },
            "description": "The number of skipped entries. When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page_offset` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntryProcDataQueryResponse"
                }
              }
            }
          },
          "404": {
            "description": "The specified upload could not be found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. No credentials provided, or you do not have permissions to the\nspecified upload.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. Invalid pagination arguments supplied.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/uploads/{upload_id}/entries/{entry_id}": {
      "get": {
        "tags": [
          "uploads/metadata"
        ],
        "summary": "Get a specific entry for a specific upload",
        "description": "Fetches a specific entry for a specific upload.",
        "operationId": "get_upload_entry_uploads__upload_id__entries__entry_id__get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "upload_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique id of the upload.",
              "title": "Upload Id"
            },
            "description": "The unique id of the upload."
          },
          {
            "name": "entry_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique id of the entry, belonging to the specified upload.",
              "title": "Entry Id"
            },
            "description": "The unique id of the entry, belonging to the specified upload."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntryProcDataResponse"
                }
              }
            }
          },
          "404": {
            "description": "The specified upload or entry could not be found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. No credentials provided, or you do not have permissions to the\nspecified upload or entry.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/uploads/{upload_id}/rawdir/{path}": {
      "get": {
        "tags": [
          "uploads/raw"
        ],
        "summary": "Get the metadata for the raw file or folder located at the specified path in the specified upload.",
        "description": "For the upload specified by `upload_id`, gets the raw file or directory metadata\nlocated at the given `path`. The response will either contain a `file_metadata` or\n`directory_metadata` key. For files, basic data about the file is returned, such as its\nname and size. For directories, the response includes a list of elements\n(files and folders) in the directory. For directories, the result is paginated.",
        "operationId": "get_upload_rawdir_path_uploads__upload_id__rawdir__path__get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "upload_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique id of the upload.",
              "title": "Upload Id"
            },
            "description": "The unique id of the upload."
          },
          {
            "name": "path",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The path within the upload raw files.",
              "title": "Path"
            },
            "description": "The path within the upload raw files."
          },
          {
            "name": "include_entry_info",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "If the fields `entry_id` and `parser_name` should be populated for all\nencountered mainfiles.",
              "default": false,
              "title": "Include Entry Info"
            },
            "description": "If the fields `entry_id` and `parser_name` should be populated for all\nencountered mainfiles."
          },
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The page size, e.g. the maximum number of items contained in one response.\nA `page_size` of 0 will return no results.",
              "default": 10,
              "title": "Page Size"
            },
            "description": "The page size, e.g. the maximum number of items contained in one response.\nA `page_size` of 0 will return no results."
          },
          {
            "name": "page_after_value",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "This attribute defines the position after which the page begins, and is used\nto navigate through the total list of results.\n\nWhen requesting the first page, no value should be provided for\n`page_after_value`. Each response will contain a value `next_page_after_value`,\nwhich can be used to obtain the next page (by setting `page_after_value` in\nyour next request to this value).\n\nThe field is encoded as a string, and the format of `page_after_value` and\n`next_page_after_value` depends on which API method is used.\n\nSome API functions additionally allows a simplified navigation, by specifying\nthe page number in the key `page`. It is however always possible to use\n`page_after_value` and `next_page_after_value` to iterate through the results.",
              "title": "Page After Value"
            },
            "description": "This attribute defines the position after which the page begins, and is used\nto navigate through the total list of results.\n\nWhen requesting the first page, no value should be provided for\n`page_after_value`. Each response will contain a value `next_page_after_value`,\nwhich can be used to obtain the next page (by setting `page_after_value` in\nyour next request to this value).\n\nThe field is encoded as a string, and the format of `page_after_value` and\n`next_page_after_value` depends on which API method is used.\n\nSome API functions additionally allows a simplified navigation, by specifying\nthe page number in the key `page`. It is however always possible to use\n`page_after_value` and `next_page_after_value` to iterate through the results."
          },
          {
            "name": "page",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The number of the page (1-based). When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used.",
              "title": "Page"
            },
            "description": "The number of the page (1-based). When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used."
          },
          {
            "name": "page_offset",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The number of skipped entries. When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page_offset` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used.",
              "title": "Page Offset"
            },
            "description": "The number of skipped entries. When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page_offset` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RawDirResponse"
                }
              }
            }
          },
          "404": {
            "description": "The specified upload, or a resource with the specified path within the upload,\ncould not be found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. No credentials provided, or you do not have permissions to the\nspecified upload.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. The request could not be processed because of some error/invalid argument.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/uploads/{upload_id}/raw": {
      "get": {
        "tags": [
          "uploads/raw"
        ],
        "summary": "Downloads the published upload .zip file with all the raw files of the upload.",
        "description": "NOMAD manages the raw files of published uploads as a .zip file. This endpoint\nallows to download it. While the outcome is similar to using `/uploads/<upload_id>/raw/`\nwhich creates a .zip file on the fly, this endpoint is more efficient\nbecause it simply streams an already existing .zip file. On the other hand, this\nendpoint is only available for published uploads and does not allow to selectively\nfilter the files.",
        "operationId": "get_upload_raw_uploads__upload_id__raw_get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "upload_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique id of the upload.",
              "title": "Upload Id"
            },
            "description": "The unique id of the upload."
          },
          {
            "name": "signature_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Signature token used to sign download urls.",
              "title": "Signature Token"
            },
            "description": "Signature token used to sign download urls."
          }
        ],
        "responses": {
          "200": {
            "description": "If `path` denotes a file: a stream with the file content, zipped if `compress = true`.\nIf `path` denotes a directory, and `compress = true`, the directory content, zipped.",
            "content": {
              "application/octet-stream": {
                "example": "file data"
              },
              "application/zip": {
                "example": "<zipped file or directory content>"
              }
            }
          },
          "404": {
            "description": "The specified upload, or a resource with the specified path within the upload,\ncould not be found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. No credentials provided, or you do not have permissions to the\nspecified upload.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. The request could not be processed because of some error/invalid argument.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/uploads/{upload_id}/raw/{path}": {
      "get": {
        "tags": [
          "uploads/raw"
        ],
        "summary": "Download the raw file or folder located at the specified path in the specified upload.",
        "description": "For the upload specified by `upload_id`, gets the raw file or directory content located\nat the given `path`. The data is zipped if `compress = true`.\n\nIt is possible to download both individual files and directories, but directories can\nonly be downloaded if `compress = true`. When downloading a directory, it is also\npossible to specify `re_pattern`, `glob_pattern` or `include_files` to filter the files\nbased on the file names.\n\nWhen downloading a file, you can specify `decompress` to attempt to decompress the data\nif the file is compressed before streaming it. You can also specify `offset` and `length`\nto download only a segment of the file (*Note:* `offset` and `length` does not work if\n`compress` is set to true).",
        "operationId": "get_upload_raw_path_uploads__upload_id__raw__path__get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "upload_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique id of the upload.",
              "title": "Upload Id"
            },
            "description": "The unique id of the upload."
          },
          {
            "name": "path",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The path within the upload raw files.",
              "title": "Path"
            },
            "description": "The path within the upload raw files."
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "When dowloading individual files with `compress = false`, this can be\nused to seek to a specified position within the file in question. Default\nis 0, i.e. the start of the file.",
              "default": 0,
              "title": "Offset"
            },
            "description": "When dowloading individual files with `compress = false`, this can be\nused to seek to a specified position within the file in question. Default\nis 0, i.e. the start of the file."
          },
          {
            "name": "length",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "When dowloading individual files with `compress = false`, this can be\nused to specify the number of bytes to read. By default, the value is -1,\nwhich means that the remainder of the file is streamed.",
              "default": -1,
              "title": "Length"
            },
            "description": "When dowloading individual files with `compress = false`, this can be\nused to specify the number of bytes to read. By default, the value is -1,\nwhich means that the remainder of the file is streamed."
          },
          {
            "name": "decompress",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "Set if compressed files should be decompressed before streaming the\ncontent (that is: if there are compressed files *within* the raw files).\nNote, only some compression formats are supported.",
              "default": false,
              "title": "Decompress"
            },
            "description": "Set if compressed files should be decompressed before streaming the\ncontent (that is: if there are compressed files *within* the raw files).\nNote, only some compression formats are supported."
          },
          {
            "name": "ignore_mime_type",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "Sets the mime type specified in the response headers to `application/octet-stream`\ninstead of the actual mime type.",
              "default": false,
              "title": "Ignore Mime Type"
            },
            "description": "Sets the mime type specified in the response headers to `application/octet-stream`\ninstead of the actual mime type."
          },
          {
            "name": "compress",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "By default the returned zip file is not compressed. This allows to enable compression.\nCompression will reduce the rate at which data is provided, often below\nthe rate of the compression. Therefore, compression is only sensible if the\nnetwork connection is limited.",
              "default": false,
              "title": "Compress"
            },
            "description": "By default the returned zip file is not compressed. This allows to enable compression.\nCompression will reduce the rate at which data is provided, often below\nthe rate of the compression. Therefore, compression is only sensible if the\nnetwork connection is limited."
          },
          {
            "name": "glob_pattern",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "An optional *glob* (or unix style path) pattern that is used to filter the\nreturned files. Only files matching the pattern are returned. The pattern is only\napplied to the end of the full path. Internally\n[fnmatch](https://docs.python.org/3/library/fnmatch.html) is used.",
              "title": "Glob Pattern"
            },
            "description": "An optional *glob* (or unix style path) pattern that is used to filter the\nreturned files. Only files matching the pattern are returned. The pattern is only\napplied to the end of the full path. Internally\n[fnmatch](https://docs.python.org/3/library/fnmatch.html) is used."
          },
          {
            "name": "re_pattern",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "An optional regexp that is used to filter the returned files. Only files matching\nthe pattern are returned. The pattern is applied in search mode to the full\npath of the files. With `$` and `^` you can control if you want to match the\nwhole path.\n\nA re pattern will replace a given glob pattern.",
              "title": "Re Pattern"
            },
            "description": "An optional regexp that is used to filter the returned files. Only files matching\nthe pattern are returned. The pattern is applied in search mode to the full\npath of the files. With `$` and `^` you can control if you want to match the\nwhole path.\n\nA re pattern will replace a given glob pattern."
          },
          {
            "name": "include_files",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "description": "Optional list of file names. Only files with these names are included in the\nresults. This will overwrite any given glob or re pattern.",
              "title": "Include Files"
            },
            "description": "Optional list of file names. Only files with these names are included in the\nresults. This will overwrite any given glob or re pattern."
          },
          {
            "name": "signature_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Signature token used to sign download urls.",
              "title": "Signature Token"
            },
            "description": "Signature token used to sign download urls."
          }
        ],
        "responses": {
          "200": {
            "description": "If `path` denotes a file: a stream with the file content, zipped if `compress = true`.\nIf `path` denotes a directory, and `compress = true`, the directory content, zipped.",
            "content": {
              "application/octet-stream": {
                "example": "file data"
              },
              "application/zip": {
                "example": "<zipped file or directory content>"
              }
            }
          },
          "404": {
            "description": "The specified upload, or a resource with the specified path within the upload,\ncould not be found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. No credentials provided, or you do not have permissions to the\nspecified upload.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. The request could not be processed because of some error/invalid argument.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "uploads/raw"
        ],
        "summary": "Upload a raw file to the specified path (directory) in the specified upload.",
        "description": "Upload one or more files to the directory specified by `path` in the upload specified by `upload_id`.\n\nWhen uploading a zip or tar archive, it will first be extracted, and the content will be\n*merged* with the existing content, i.e. new files are added, and if there is a collision\n(an old file with the same path and name as one of the new files), the old file will\nbe overwritten, but the rest of the old files will remain untouched. If the file is not\na zip or tar archive, the file will just be uploaded as it is, overwriting the existing\nfile if there is one.\n\nThe `path` should denote a directory. The empty string gives the \"root\" directory.\n\nIf a single file is uploaded (and it is not a zip or tar archive), it is possible to specify\n`wait_for_processing`. This means that the file (and only this file) will be matched and\nprocessed, and information about the outcome will be returned with the response. **NOTE**:\nthis should be used with caution! When this option is set, the call will block until\nprocessing is complete, which may take some time. Also note, that just processing the\nnew/modified file may not be enough in some cases (since adding/modifying a file somewhere\nin the directory structure may affect other entries). Also note that\nprocessing.entry.entry_metadata will not be populated in the response.\n\nThere are two basic ways to upload files: in the multipart-formdata or streaming the\nfile data in the http body. Both are supported. Note, however, that the second method\nonly allows the upload of a single file, and that it does not transfer a filename. If a\ntransfer is made using method 2, you can specify the query argument `file_name` to name it.\nThis *needs* to be specified when using method 2, unless you are uploading a zip/tar file\n(for zip/tar files the names don't matter since they are extracted). See the POST `uploads`\nendpoint for examples of curl commands for uploading files.\n\nAlso, this path can be used to copy/move a file from one directory to another. Three\nquery parameters are required for a successful operation: 1) `copy_or_move` param to specify\nif the file needs to be moved (if set to move then the original file will be removed), 2)\n`file_name` param that contains the new name for the file moved/copied file and 3) `copy_or_move_source_path`\nparam that contains the path of the original/existing local file to be copied or moved.",
        "operationId": "put_upload_raw_path_uploads__upload_id__raw__path__put",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "upload_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique id of the upload.",
              "title": "Upload Id"
            },
            "description": "The unique id of the upload."
          },
          {
            "name": "path",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The path within the upload raw files.",
              "title": "Path"
            },
            "description": "The path within the upload raw files."
          },
          {
            "name": "local_path",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Internal/Admin use only.",
              "title": "Local Path"
            },
            "description": "Internal/Admin use only."
          },
          {
            "name": "file_name",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Specifies the name of the file, when using method 2.",
              "title": "File Name"
            },
            "description": "Specifies the name of the file, when using method 2."
          },
          {
            "name": "overwrite_if_exists",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "If set to True (default), overwrites the file if it already exists.",
              "default": true,
              "title": "Overwrite If Exists"
            },
            "description": "If set to True (default), overwrites the file if it already exists."
          },
          {
            "name": "copy_or_move",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "If moving or copying a file within the same upload, specify which operation to do: move or copy",
              "title": "Copy Or Move"
            },
            "description": "If moving or copying a file within the same upload, specify which operation to do: move or copy"
          },
          {
            "name": "copy_or_move_source_path",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "If moving or copying a file within the same upload, specify the path to the source file.",
              "title": "Copy Or Move Source Path"
            },
            "description": "If moving or copying a file within the same upload, specify the path to the source file."
          },
          {
            "name": "wait_for_processing",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "Waits for the processing to complete and return information about the outcome in the response (**USE WITH CARE**).",
              "default": false,
              "title": "Wait For Processing"
            },
            "description": "Waits for the processing to complete and return information about the outcome in the response (**USE WITH CARE**)."
          },
          {
            "name": "include_archive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "If the archive data should be included in the response when using `wait_for_processing` (**USE WITH CARE**).",
              "default": false,
              "title": "Include Archive"
            },
            "description": "If the archive data should be included in the response when using `wait_for_processing` (**USE WITH CARE**)."
          },
          {
            "name": "entry_hash",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "The hash code of the not modified entry.",
              "title": "Entry Hash"
            },
            "description": "The hash code of the not modified entry."
          },
          {
            "name": "token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Token for simplified authorization for uploading.",
              "title": "Token"
            },
            "description": "Token for simplified authorization for uploading."
          }
        ],
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "schema": {
                "$ref": "#/components/schemas/Body_put_upload_raw_path_uploads__upload_id__raw__path__put"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "A json structure with upload data and possibly information from the processing,\nor a plain text information string.\nIt will be a json structure if the request headers specifies `Accept = application/json`\nor if `wait_for_processing` is set.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PutRawFileResponse"
                }
              },
              "text/plain": {
                "example": "Thanks for uploading your data to nomad."
              }
            }
          },
          "404": {
            "description": "The specified upload could not be found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. No credentials provided, or you do not have permissions to the\nspecified upload.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. The request could not be processed because of some error/invalid argument.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "uploads/raw"
        ],
        "summary": "Delete the raw file or folder located at the specified path in the specified upload.",
        "description": "Delete file or folder located at the specified path in the specified upload. The upload\nmust not be published. This also automatically triggers a reprocessing of the upload.\nChoosing the empty string as `path` deletes all files.",
        "operationId": "delete_upload_raw_path_uploads__upload_id__raw__path__delete",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "upload_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique id of the upload.",
              "title": "Upload Id"
            },
            "description": "The unique id of the upload."
          },
          {
            "name": "path",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The path within the upload raw files.",
              "title": "Path"
            },
            "description": "The path within the upload raw files."
          },
          {
            "name": "token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Token for simplified authorization for uploading.",
              "title": "Token"
            },
            "description": "Token for simplified authorization for uploading."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UploadProcDataResponse"
                }
              }
            }
          },
          "404": {
            "description": "The specified upload could not be found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. No credentials provided, or you do not have permissions to the\nspecified upload.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. The request could not be processed because of some error/invalid argument.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/uploads/{upload_id}/raw-create-dir/{path}": {
      "post": {
        "tags": [
          "uploads/raw"
        ],
        "summary": "Create a new empty directory with the specified path in the specified upload.",
        "description": "Create a new empty directory in the specified upload. The `path` should be the full path\nto the new directory (i.e. ending with the name of the new directory). The api call returns\nimmediately (no processing is necessary).",
        "operationId": "post_upload_raw_create_dir_path_uploads__upload_id__raw_create_dir__path__post",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "upload_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique id of the upload.",
              "title": "Upload Id"
            },
            "description": "The unique id of the upload."
          },
          {
            "name": "path",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The path within the upload raw files.",
              "title": "Path"
            },
            "description": "The path within the upload raw files."
          },
          {
            "name": "token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Token for simplified authorization for uploading.",
              "title": "Token"
            },
            "description": "Token for simplified authorization for uploading."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UploadProcDataResponse"
                }
              }
            }
          },
          "404": {
            "description": "The specified upload could not be found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. No credentials provided, or you do not have permissions to the\nspecified upload.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. The request could not be processed because of some error/invalid argument.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/uploads/{upload_id}/archive/mainfile/{mainfile}": {
      "get": {
        "tags": [
          "uploads/archive"
        ],
        "summary": "Get the full archive for the given upload and mainfile path.",
        "description": "For the upload specified by `upload_id`, gets the full archive of a single entry that\nis identified by the given `mainfile`.",
        "operationId": "get_upload_entry_archive_mainfile_uploads__upload_id__archive_mainfile__mainfile__get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "upload_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique id of the upload.",
              "title": "Upload Id"
            },
            "description": "The unique id of the upload."
          },
          {
            "name": "mainfile",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The mainfile path within the upload's raw files.",
              "title": "Mainfile"
            },
            "description": "The mainfile path within the upload's raw files."
          },
          {
            "name": "mainfile_key",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "The mainfile_key, for accessing child entries.",
              "title": "Mainfile Key"
            },
            "description": "The mainfile_key, for accessing child entries."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntryArchiveResponse"
                }
              }
            }
          },
          "404": {
            "description": "The specified upload, or a resource with the specified path within the upload,\ncould not be found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. No credentials provided, or you do not have permissions to the\nspecified upload.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/uploads/{upload_id}/archive/{entry_id}": {
      "get": {
        "tags": [
          "uploads/archive"
        ],
        "summary": "Get the full archive for the given upload and entry.",
        "description": "For the upload specified by `upload_id`, gets the full archive of a single entry that\nis identified by the given `entry_id`.",
        "operationId": "get_upload_entry_archive_uploads__upload_id__archive__entry_id__get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "upload_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique id of the upload.",
              "title": "Upload Id"
            },
            "description": "The unique id of the upload."
          },
          {
            "name": "entry_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique entry id.",
              "title": "Entry Id"
            },
            "description": "The unique entry id."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntryArchiveResponse"
                }
              }
            }
          },
          "404": {
            "description": "The specified upload, or a resource with the specified path within the upload,\ncould not be found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. No credentials provided, or you do not have permissions to the\nspecified upload.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/uploads/{upload_id}/edit": {
      "post": {
        "tags": [
          "uploads/metadata"
        ],
        "summary": "Updates the metadata of the specified upload.",
        "description": "Updates the metadata of the specified upload and entries. An optional `query` can be\nspecified to select only some of the entries of the upload (the query results are\nautomatically restricted to the specified upload).\n\n**Note:**\n  - Only admins can edit some of the fields.\n  - The embargo of a published upload is lifted by setting the `embargo_length` attribute\n    to 0.\n  - If the upload is published, the only operations permitted using this endpoint is to\n    lift the embargo, i.e. set `embargo_length` to 0, and to edit the entries in datasets\n    that where created by the current user.\n  - If a query is specified, it is not possible to edit upload level metadata (like\n    `upload_name`, `coauthors`, etc.), as the purpose of queries is to select only a\n    subset of the upload entries to edit, but changing upload level metadata would affect\n    **all** entries of the upload.",
        "operationId": "post_upload_edit_uploads__upload_id__edit_post",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "upload_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique id of the upload.",
              "title": "Upload Id"
            },
            "description": "The unique id of the upload."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MetadataEditRequest-Input"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UploadProcDataResponse"
                }
              }
            }
          },
          "404": {
            "description": "The specified upload could not be found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. No credentials provided, or you do not have permissions to the\nspecified upload.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. The request could not be processed because of some error/invalid argument.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/uploads/{upload_id}/action/publish": {
      "post": {
        "tags": [
          "uploads/action"
        ],
        "summary": "Publish an upload",
        "description": "Publishes an upload. The upload cannot be modified after this point (except for special\ncases, like when lifting the embargo prematurely, and by admins). After the upload is\npublished and the embargo period (if any) is expired, the generated archive entries\nwill be publicly visible.",
        "operationId": "post_upload_action_publish_uploads__upload_id__action_publish_post",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "upload_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique id of the upload to publish.",
              "title": "Upload Id"
            },
            "description": "The unique id of the upload to publish."
          },
          {
            "name": "embargo_length",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "description": "If provided, updates the embargo length of the upload. The value should\nbe between 0 and 36 months. 0 means no embargo.",
              "title": "Embargo Length"
            },
            "description": "If provided, updates the embargo length of the upload. The value should\nbe between 0 and 36 months. 0 means no embargo."
          },
          {
            "name": "to_central_nomad",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "Will send the upload to the central NOMAD repository and publish it. This\noption is only available on an OASIS. The upload must already be published\non the OASIS.",
              "default": false,
              "title": "To Central Nomad"
            },
            "description": "Will send the upload to the central NOMAD repository and publish it. This\noption is only available on an OASIS. The upload must already be published\non the OASIS."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UploadProcDataResponse"
                }
              }
            }
          },
          "404": {
            "description": "The specified upload could not be found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. No credentials provided, or you do not have permissions to the\nspecified upload.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. The request could not be processed because of some error/invalid argument.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/uploads/{upload_id}/action/process": {
      "post": {
        "tags": [
          "uploads/action"
        ],
        "summary": "Manually triggers processing of an upload.",
        "description": "Processes an upload, i.e. parses the files and updates the NOMAD archive. Only admins\ncan process an already published upload.",
        "operationId": "post_upload_action_process_uploads__upload_id__action_process_post",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "upload_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique id of the upload to process.",
              "title": "Upload Id"
            },
            "description": "The unique id of the upload to process."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UploadProcDataResponse"
                }
              }
            }
          },
          "404": {
            "description": "The specified upload could not be found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. No credentials provided, or you do not have permissions to the\nspecified upload.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. The request could not be processed because of some error/invalid argument.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/uploads/{upload_id}/action/delete-entry-files": {
      "post": {
        "tags": [
          "uploads/action"
        ],
        "summary": "Deletes the files of the entries specified by a query.",
        "description": "Deletes the files of the entries specified by the provided query.",
        "operationId": "post_upload_action_delete_entry_files_uploads__upload_id__action_delete_entry_files_post",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "upload_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique id of the upload within which to delete entry files.",
              "title": "Upload Id"
            },
            "description": "The unique id of the upload within which to delete entry files."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteEntryFilesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UploadProcDataResponse"
                }
              }
            }
          },
          "404": {
            "description": "The specified upload could not be found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. No credentials provided, or you do not have permissions to the\nspecified upload.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. The request could not be processed because of some error/invalid argument.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/uploads/{upload_id}/action/lift-embargo": {
      "post": {
        "tags": [
          "uploads/action"
        ],
        "summary": "Lifts the embargo of an upload.",
        "description": "Lifts the embargo of an upload.",
        "operationId": "post_upload_action_lift_embargo_uploads__upload_id__action_lift_embargo_post",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "upload_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique id of the upload to lift the embargo for.",
              "title": "Upload Id"
            },
            "description": "The unique id of the upload to lift the embargo for."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UploadProcDataResponse"
                }
              }
            }
          },
          "404": {
            "description": "The specified upload could not be found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. No credentials provided, or you do not have permissions to the\nspecified upload.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. The request could not be processed because of some error/invalid argument.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/uploads/{upload_id}/bundle": {
      "get": {
        "tags": [
          "uploads/bundle"
        ],
        "summary": "Gets an *upload bundle* for the specified upload.",
        "description": "Get an *upload bundle* for the specified upload. An upload bundle is a file bundle which\ncan be used to export and import uploads between different NOMAD deployments.",
        "operationId": "get_upload_bundle_uploads__upload_id__bundle_get",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "upload_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique id of the upload.",
              "title": "Upload Id"
            },
            "description": "The unique id of the upload."
          },
          {
            "name": "include_raw_files",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "If raw files should be included in the bundle (true by default).",
              "default": true,
              "title": "Include Raw Files"
            },
            "description": "If raw files should be included in the bundle (true by default)."
          },
          {
            "name": "include_archive_files",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "If archive files (i.e. parsed entries data) should be included in the bundle\n(true by default).",
              "default": true,
              "title": "Include Archive Files"
            },
            "description": "If archive files (i.e. parsed entries data) should be included in the bundle\n(true by default)."
          },
          {
            "name": "include_datasets",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "If datasets references to this upload should be included in the bundle\n(true by default).",
              "default": true,
              "title": "Include Datasets"
            },
            "description": "If datasets references to this upload should be included in the bundle\n(true by default)."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/zip": {
                "example": "<zipped bundle data>"
              }
            }
          },
          "404": {
            "description": "The specified upload could not be found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. No credentials provided, or you do not have permissions to the\nspecified upload.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. The request could not be processed because of some error/invalid argument.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/uploads/bundle": {
      "post": {
        "tags": [
          "uploads/bundle"
        ],
        "summary": "Posts an *upload bundle* to this NOMAD deployment.",
        "description": "Posts an *upload bundle* to this NOMAD deployment. An upload bundle is a file bundle which\ncan be used to export and import uploads between different NOMAD installations. The\nendpoint expects an upload bundle attached as a zipfile.\n\n**NOTE:** This endpoint is restricted to admin users and oasis admins. Further, all\nsettings except `embargo_length` requires an admin user to change (these settings\nhave default values specified by the system configuration).\n\nThere are two basic ways to upload files: in the multipart-formdata or streaming the\nfile data in the http body. Both are supported. See the POST `uploads` endpoint for\nexamples of curl commands for uploading files.",
        "operationId": "post_upload_bundle_uploads_bundle_post",
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ],
        "parameters": [
          {
            "name": "local_path",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Internal/Admin use only.",
              "title": "Local Path"
            },
            "description": "Internal/Admin use only."
          },
          {
            "name": "embargo_length",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Specifies the embargo length in months to set on the upload. If omitted,\nthe value specified in the bundle will be used. A value of 0 means no\nembargo.",
              "title": "Embargo Length"
            },
            "description": "Specifies the embargo length in months to set on the upload. If omitted,\nthe value specified in the bundle will be used. A value of 0 means no\nembargo."
          },
          {
            "name": "include_raw_files",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "If raw files should be imported from the bundle\n*(only admins can change this setting)*.",
              "title": "Include Raw Files"
            },
            "description": "If raw files should be imported from the bundle\n*(only admins can change this setting)*."
          },
          {
            "name": "include_archive_files",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "If archive files (i.e. parsed entries data) should be imported from the bundle\n*(only admins can change this setting)*.",
              "title": "Include Archive Files"
            },
            "description": "If archive files (i.e. parsed entries data) should be imported from the bundle\n*(only admins can change this setting)*."
          },
          {
            "name": "include_datasets",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "If dataset references to this upload should be imported from the bundle\n*(only admins can change this setting)*.",
              "title": "Include Datasets"
            },
            "description": "If dataset references to this upload should be imported from the bundle\n*(only admins can change this setting)*."
          },
          {
            "name": "include_bundle_info",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "If the bundle_info.json file should be kept\n*(only admins can change this setting)*.",
              "title": "Include Bundle Info"
            },
            "description": "If the bundle_info.json file should be kept\n*(only admins can change this setting)*."
          },
          {
            "name": "keep_original_timestamps",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "If all original timestamps, including `upload_create_time`, `entry_create_time`\nand `publish_time`, should be kept\n*(only admins can change this setting)*.",
              "title": "Keep Original Timestamps"
            },
            "description": "If all original timestamps, including `upload_create_time`, `entry_create_time`\nand `publish_time`, should be kept\n*(only admins can change this setting)*."
          },
          {
            "name": "set_from_oasis",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "If the `from_oasis` flag and `oasis_deployment_url` should be set\n*(only admins can change this setting)*.",
              "title": "Set From Oasis"
            },
            "description": "If the `from_oasis` flag and `oasis_deployment_url` should be set\n*(only admins can change this setting)*."
          },
          {
            "name": "trigger_processing",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "description": "If processing should be triggered after the bundle has been imported\n*(only admins can change this setting)*.",
              "title": "Trigger Processing"
            },
            "description": "If processing should be triggered after the bundle has been imported\n*(only admins can change this setting)*."
          },
          {
            "name": "token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Token for simplified authorization for uploading.",
              "title": "Token"
            },
            "description": "Token for simplified authorization for uploading."
          }
        ],
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "schema": {
                "$ref": "#/components/schemas/Body_post_upload_bundle_uploads_bundle_post"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UploadProcDataResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Authorization is required, but no or bad authentication credentials provided.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. The request could not be processed because of some error/invalid argument.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/users/me": {
      "get": {
        "tags": [
          "users"
        ],
        "summary": "Get your account data",
        "description": "Returns the account data of the authenticated user.",
        "operationId": "read_users_me_users_me_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/User"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The operation requires authorization,\nbut no or bad authentication credentials are given.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      }
    },
    "/users": {
      "get": {
        "tags": [
          "users"
        ],
        "summary": "Get existing users",
        "description": "Get existing users for given criteria",
        "operationId": "get_users_users_get",
        "parameters": [
          {
            "name": "prefix",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Search the user with the given prefix.",
              "title": "Prefix"
            },
            "description": "Search the user with the given prefix."
          },
          {
            "name": "user_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "description": "To get the user(s) by their user_id(s).",
              "title": "User Id"
            },
            "description": "To get the user(s) by their user_id(s)."
          },
          {
            "name": "username",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "description": "To get the user(s) by their username(s).",
              "title": "Username"
            },
            "description": "To get the user(s) by their username(s)."
          },
          {
            "name": "email",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "description": "To get the user(s) by their email(s).",
              "title": "Email"
            },
            "description": "To get the user(s) by their email(s)."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Users"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/users/{user_id}": {
      "get": {
        "tags": [
          "users"
        ],
        "summary": "Get existing users",
        "description": "Get the user using the given user_id",
        "operationId": "get_user_users__user_id__get",
        "parameters": [
          {
            "name": "user_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicUserInfo"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/users/invite": {
      "put": {
        "tags": [
          "users"
        ],
        "summary": "Invite a new user",
        "operationId": "invite_user_users_invite_put",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/User"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/User"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The operation requires authorization,\nbut no or bad authentication credentials are given.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "400": {
            "description": "The invite is invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPExceptionModel"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "OAuth2PasswordBearer": []
          }
        ]
      }
    }
  },
  "components": {
    "schemas": {
      "AggregatedEntities": {
        "properties": {
          "size": {
            "anyOf": [
              {
                "type": "integer",
                "exclusiveMinimum": 0
              },
              {
                "type": "null"
              }
            ],
            "title": "Size",
            "description": "The number of entries that should be returned for each value in the\naggregation.",
            "default": 1
          },
          "required": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MetadataRequired"
              },
              {
                "type": "null"
              }
            ],
            "description": "This allows to determined what fields should be returned for each entry."
          }
        },
        "type": "object",
        "title": "AggregatedEntities"
      },
      "Aggregation": {
        "properties": {
          "terms": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/TermsAggregation"
              },
              {
                "type": "null"
              }
            ],
            "description": "A `terms` aggregation allows to get the values of a quantity that occur in\nthe search query result data. For each value, a bucket is created with\ninformation about how many entries have the value (or additional metrics).\nFor example to get all entries that use a certain code, you can use:\n```json\n{\n    \"aggregations\": {\n        \"all_codes\": {\n            \"terms\": {\n                \"quantity\": \"results.method.simulation.program_name\"\n            }\n        }\n    }\n}\n```\n\nTerms aggregations can also be used to paginate though all values of a certain\nquantities. Each page will be companied with a `page_after_value` that\ncan be used to retrieve the next value. For example to go through all datasets\navailable in the search query:\n```json\n{\n    \"aggregations\": {\n        \"all_datasets\": {\n            \"terms\": {\n                \"quantity\": \"datasets\",\n                \"pagination\": {\n                    \"page_size\": 100\n                }\n            }\n        }\n    }\n}\n```"
          },
          "histogram": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/HistogramAggregation"
              },
              {
                "type": "null"
              }
            ],
            "description": "A `histogram` aggregation allows to get the ranges quantity values and\nhow many (or another metrics) entries exhibit values in those ranges:\n\n```json\n{\n    \"aggregations\": {\n        \"calculations_per_entry\": {\n            \"histogram\": {\n                \"quantity\": \"properties.n_calculations\",\n                \"interval\": 10\n            }\n        }\n    }\n}\n```\n\nThe used quantity must be a float or int typed quantity. An interval is\nmandatory and determines the bucket size."
          },
          "date_histogram": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DateHistogramAggregation"
              },
              {
                "type": "null"
              }
            ],
            "description": "A `date_histogram` aggregation is like a normal `histogram` but for date valued\nquantities.:\n\n```json\n{\n    \"aggregations\": {\n        \"upload_create_times\": {\n            \"date_histogram\": {\n                \"quantity\": \"upload_create_time\",\n                \"interval\": \"1M\"\n            }\n        }\n    }\n}\n```\n\nThe used quantity must be a datetime typed quantity. Intervals are strings\nthat determine a time period. The default is one month, `1M`."
          },
          "auto_date_histogram": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AutoDateHistogramAggregation"
              },
              {
                "type": "null"
              }
            ],
            "description": "A `auto_date_histogram` aggregation is like a normal\n`date_histogram` but instead of providing an explicit time step,\nyou can provide a target number of buckets.:\n\n```json\n{\n    \"aggregations\": {\n        \"upload_create_times\": {\n            \"auto_date_histogram\": {\n                \"quantity\": \"upload_create_time\",\n                \"buckets\": \"10\"\n            }\n        }\n    }\n}\n```\n\nThe used quantity must be a datetime typed quantity. Buckets are\ninteger numbers that determine the targeted amount of buckets.\nNotice that number of buckets returned will always be less than or\nequal to this target number. The default is to target 10 buckets."
          },
          "min_max": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MinMaxAggregation"
              },
              {
                "type": "null"
              }
            ],
            "description": "A `min_max` aggregation allows to get the minumum and maximum quantity values:\n\n```json\n{\n    \"aggregations\": {\n        \"calculations_per_entry\": {\n            \"min_max\": {\n                \"quantity\": \"results.properties.n_calculations\"\n            }\n        }\n    }\n}\n```\n\nThe used quantity must be a float or int typed quantity."
          },
          "statistics": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StatisticsAggregation"
              },
              {
                "type": "null"
              }
            ],
            "description": "A `statistics` aggregation allows to get metrics (sums or cardinalities) from all data\nthat matches the search.\n\n```json\n{\n    \"aggregations\": {\n        \"statistics\": {\n            \"global\": {\n                \"metrics\": [\"results.properties.n_calculations\", \"results.material.material_id\"]\n            }\n        }\n    }\n}\n```"
          }
        },
        "type": "object",
        "title": "Aggregation"
      },
      "AggregationPagination": {
        "properties": {
          "page_size": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page Size",
            "description": "The page size, e.g. the maximum number of items contained in one response.\nA `page_size` of 0 will return no results.",
            "default": 10
          },
          "order_by": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Order By",
            "description": "Either the string \"count\", \"value\", or the name of a quantity. If omitted the buckets\nwill be ordered by the item \"count\".\n\nIf you provide a quantity, all items\nin a bucket must have the same value for this quantity. For example, aggregating\nentries on `upload_id` and ordering with the buckets by `upload_create_time` is fine,\nbecause all entries in an upload have the same `upload_create_time`. The API cannot\ncheck this rule and the results will be unpredictable.\n\nIf you want to order by the bucket values, you can either use \"value\" or use\nthe aggregation quantity to `order_by`. The result will be the same, because\nthe bucket values are the quantity values."
          },
          "order": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Direction"
              },
              {
                "type": "null"
              }
            ],
            "description": "The ordering direction of the results based on `order_by`. Its either\nascending `asc` or descending `desc`. Default is `asc`.",
            "default": "asc"
          },
          "page_after_value": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page After Value",
            "description": "This attribute defines the position after which the page begins, and is used\nto navigate through the total list of results.\n\nWhen requesting the first page, no value should be provided for\n`page_after_value`. Each response will contain a value `next_page_after_value`,\nwhich can be used to obtain the next page (by setting `page_after_value` in\nyour next request to this value).\n\nThe field is encoded as a string, and the format of `page_after_value` and\n`next_page_after_value` depends on which API method is used.\n\nSome API functions additionally allows a simplified navigation, by specifying\nthe page number in the key `page`. It is however always possible to use\n`page_after_value` and `next_page_after_value` to iterate through the results."
          },
          "page": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page",
            "description": "The number of the page (1-based). When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used."
          },
          "page_offset": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page Offset",
            "description": "The number of skipped entries. When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page_offset` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used."
          }
        },
        "type": "object",
        "title": "AggregationPagination"
      },
      "AggregationResponse": {
        "properties": {
          "terms": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/TermsAggregationResponse"
              },
              {
                "type": "null"
              }
            ]
          },
          "histogram": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/HistogramAggregationResponse"
              },
              {
                "type": "null"
              }
            ]
          },
          "date_histogram": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DateHistogramAggregationResponse"
              },
              {
                "type": "null"
              }
            ]
          },
          "auto_date_histogram": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AutoDateHistogramAggregationResponse"
              },
              {
                "type": "null"
              }
            ]
          },
          "min_max": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MinMaxAggregationResponse"
              },
              {
                "type": "null"
              }
            ]
          },
          "statistics": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StatisticsAggregationResponse"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "title": "AggregationResponse"
      },
      "All": {
        "properties": {
          "all": {
            "items": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "number"
                },
                {
                  "type": "boolean"
                },
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "format": "date-time"
                }
              ]
            },
            "type": "array",
            "title": "All"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "All"
      },
      "And-Input": {
        "properties": {
          "and": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/And-Input"
                },
                {
                  "$ref": "#/components/schemas/Or-Input"
                },
                {
                  "$ref": "#/components/schemas/Not-Input"
                },
                {
                  "$ref": "#/components/schemas/Nested-Input"
                },
                {
                  "$ref": "#/components/schemas/Criteria"
                },
                {
                  "$ref": "#/components/schemas/Empty"
                },
                {
                  "additionalProperties": {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "type": "number"
                      },
                      {
                        "type": "boolean"
                      },
                      {
                        "type": "string"
                      },
                      {
                        "type": "string",
                        "format": "date-time"
                      },
                      {
                        "items": {
                          "anyOf": [
                            {
                              "type": "integer"
                            },
                            {
                              "type": "number"
                            },
                            {
                              "type": "boolean"
                            },
                            {
                              "type": "string"
                            },
                            {
                              "type": "string",
                              "format": "date-time"
                            }
                          ]
                        },
                        "type": "array"
                      },
                      {
                        "$ref": "#/components/schemas/Range"
                      },
                      {
                        "$ref": "#/components/schemas/Any_"
                      },
                      {
                        "$ref": "#/components/schemas/All"
                      },
                      {
                        "$ref": "#/components/schemas/None_"
                      },
                      {
                        "type": "object"
                      }
                    ]
                  },
                  "type": "object"
                }
              ]
            },
            "type": "array",
            "title": "And"
          }
        },
        "type": "object",
        "title": "And"
      },
      "And-Output": {
        "properties": {
          "and": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/And-Output"
                },
                {
                  "$ref": "#/components/schemas/Or-Output"
                },
                {
                  "$ref": "#/components/schemas/Not-Output"
                },
                {
                  "$ref": "#/components/schemas/Nested-Output"
                },
                {
                  "$ref": "#/components/schemas/Criteria"
                },
                {
                  "$ref": "#/components/schemas/Empty"
                },
                {
                  "additionalProperties": {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "type": "number"
                      },
                      {
                        "type": "boolean"
                      },
                      {
                        "type": "string"
                      },
                      {
                        "type": "string",
                        "format": "date-time"
                      },
                      {
                        "items": {
                          "anyOf": [
                            {
                              "type": "integer"
                            },
                            {
                              "type": "number"
                            },
                            {
                              "type": "boolean"
                            },
                            {
                              "type": "string"
                            },
                            {
                              "type": "string",
                              "format": "date-time"
                            }
                          ]
                        },
                        "type": "array"
                      },
                      {
                        "$ref": "#/components/schemas/Range"
                      },
                      {
                        "$ref": "#/components/schemas/Any_"
                      },
                      {
                        "$ref": "#/components/schemas/All"
                      },
                      {
                        "$ref": "#/components/schemas/None_"
                      },
                      {
                        "type": "object"
                      }
                    ]
                  },
                  "type": "object"
                }
              ]
            },
            "type": "array",
            "title": "And"
          }
        },
        "type": "object",
        "title": "And"
      },
      "Any_": {
        "properties": {
          "any": {
            "items": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "number"
                },
                {
                  "type": "boolean"
                },
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "format": "date-time"
                }
              ]
            },
            "type": "array",
            "title": "Any"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "Any_"
      },
      "AppToken": {
        "properties": {
          "app_token": {
            "type": "string",
            "title": "App Token"
          }
        },
        "type": "object",
        "required": [
          "app_token"
        ],
        "title": "AppToken"
      },
      "ArchiveChange": {
        "properties": {
          "path": {
            "type": "string",
            "title": "Path"
          },
          "new_value": {},
          "action": {
            "$ref": "#/components/schemas/ArchiveChangeAction",
            "default": "upsert"
          }
        },
        "type": "object",
        "required": [
          "path"
        ],
        "title": "ArchiveChange"
      },
      "ArchiveChangeAction": {
        "type": "string",
        "enum": [
          "upsert",
          "remove"
        ],
        "title": "ArchiveChangeAction"
      },
      "AutoDateHistogramAggregation": {
        "properties": {
          "quantity": {
            "type": "string",
            "title": "Quantity",
            "description": "The mandatory name of the quantity for the aggregation. Aggregations\ncan only be computed for those search metadata that have discrete values;\nan aggregation buckets entries that have the same value for this quantity."
          },
          "exclude_from_search": {
            "type": "boolean",
            "title": "Exclude From Search",
            "description": "If set to true, top-level search criteria involving the aggregation quantity, will not\nbe applied for this aggregation. Therefore, the aggregation will return all\nvalues for the quantity, even if the possible values where filtered by the query.\n\nThere are two limitations. This is only supported with queries that start with a\ndictionary. It will not work for queries with a boolean operator. It can only\nexclude top-level criteria at the root of the query dictionary. Nested criteria,\ne.g. within complex and/or constructs, cannot be considered. Using this might also\nprohibit pagination with page_after_value on aggregations in the same request.",
            "default": false
          },
          "metrics": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metrics",
            "description": "By default the returned aggregations will provide the number of entries for each\nvalue. You can add more metrics. For each metric an additional number will be\nprovided for each value. Metrics are also based on search metadata. Depending on\nthe metric the number will represent either a sum (`calculations` for the number\nof individual calculation in each code run) or an amount of different values\n(i.e. `materials` for the amount of different material hashes).",
            "default": []
          },
          "buckets": {
            "type": "integer",
            "title": "Buckets",
            "description": "The target number of buckets. The interval of the buckets is\nautomatically chosen to best achieve that target. The number of buckets\nreturned will always be less than or equal to this target number.",
            "default": 10
          }
        },
        "type": "object",
        "required": [
          "quantity"
        ],
        "title": "AutoDateHistogramAggregation"
      },
      "AutoDateHistogramAggregationResponse": {
        "properties": {
          "quantity": {
            "type": "string",
            "title": "Quantity",
            "description": "The mandatory name of the quantity for the aggregation. Aggregations\ncan only be computed for those search metadata that have discrete values;\nan aggregation buckets entries that have the same value for this quantity."
          },
          "exclude_from_search": {
            "type": "boolean",
            "title": "Exclude From Search",
            "description": "If set to true, top-level search criteria involving the aggregation quantity, will not\nbe applied for this aggregation. Therefore, the aggregation will return all\nvalues for the quantity, even if the possible values where filtered by the query.\n\nThere are two limitations. This is only supported with queries that start with a\ndictionary. It will not work for queries with a boolean operator. It can only\nexclude top-level criteria at the root of the query dictionary. Nested criteria,\ne.g. within complex and/or constructs, cannot be considered. Using this might also\nprohibit pagination with page_after_value on aggregations in the same request.",
            "default": false
          },
          "metrics": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metrics",
            "description": "By default the returned aggregations will provide the number of entries for each\nvalue. You can add more metrics. For each metric an additional number will be\nprovided for each value. Metrics are also based on search metadata. Depending on\nthe metric the number will represent either a sum (`calculations` for the number\nof individual calculation in each code run) or an amount of different values\n(i.e. `materials` for the amount of different material hashes).",
            "default": []
          },
          "buckets": {
            "type": "integer",
            "title": "Buckets",
            "description": "The target number of buckets. The interval of the buckets is\nautomatically chosen to best achieve that target. The number of buckets\nreturned will always be less than or equal to this target number.",
            "default": 10
          },
          "data": {
            "items": {
              "$ref": "#/components/schemas/Bucket"
            },
            "type": "array",
            "title": "Data",
            "description": "The aggregation data as a list."
          },
          "interval": {
            "type": "string",
            "title": "Interval",
            "description": "The interval that was used for the bucketing."
          }
        },
        "type": "object",
        "required": [
          "quantity"
        ],
        "title": "AutoDateHistogramAggregationResponse"
      },
      "Body_get_token_auth_token_post": {
        "properties": {
          "grant_type": {
            "anyOf": [
              {
                "type": "string",
                "pattern": "^password$"
              },
              {
                "type": "null"
              }
            ],
            "title": "Grant Type"
          },
          "username": {
            "type": "string",
            "title": "Username"
          },
          "password": {
            "type": "string",
            "title": "Password"
          },
          "scope": {
            "type": "string",
            "title": "Scope",
            "default": ""
          },
          "client_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Client Id"
          },
          "client_secret": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Client Secret"
          }
        },
        "type": "object",
        "required": [
          "username",
          "password"
        ],
        "title": "Body_get_token_auth_token_post"
      },
      "Body_post_upload_bundle_uploads_bundle_post": {
        "properties": {
          "file": {
            "items": {
              "type": "string",
              "format": "binary"
            },
            "type": "array",
            "title": "File"
          }
        },
        "type": "object",
        "title": "Body_post_upload_bundle_uploads_bundle_post"
      },
      "Body_post_upload_uploads_post": {
        "properties": {
          "file": {
            "items": {
              "type": "string",
              "format": "binary"
            },
            "type": "array",
            "title": "File"
          }
        },
        "type": "object",
        "title": "Body_post_upload_uploads_post"
      },
      "Body_put_upload_raw_path_uploads__upload_id__raw__path__put": {
        "properties": {
          "file": {
            "items": {
              "type": "string",
              "format": "binary"
            },
            "type": "array",
            "title": "File"
          }
        },
        "type": "object",
        "title": "Body_put_upload_raw_path_uploads__upload_id__raw__path__put"
      },
      "Bounds": {
        "properties": {
          "min": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Min",
            "description": "Start value for the histogram."
          },
          "max": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Max",
            "description": "Ending value for the histogram."
          }
        },
        "type": "object",
        "title": "Bounds"
      },
      "Bucket": {
        "properties": {
          "entries": {
            "anyOf": [
              {
                "items": {
                  "type": "object"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Entries",
            "description": "The entries that were requested for each value."
          },
          "count": {
            "type": "integer",
            "title": "Count",
            "description": "The amount of entries with this value."
          },
          "nested_count": {
            "type": "integer",
            "title": "Nested Count",
            "description": "The amount of nested entries with this values. Is the same as count for\naggregations on non nested quantities."
          },
          "metrics": {
            "anyOf": [
              {
                "additionalProperties": {
                  "type": "integer"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metrics"
          },
          "value": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "number"
              },
              {
                "type": "string"
              }
            ],
            "title": "Value"
          }
        },
        "type": "object",
        "required": [
          "value"
        ],
        "title": "Bucket"
      },
      "CodeInfoModel": {
        "properties": {
          "code_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Code Name",
            "description": "Name of the code or input format"
          },
          "code_homepage": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Code Homepage",
            "description": "Homepage of the code or input format"
          }
        },
        "type": "object",
        "title": "CodeInfoModel"
      },
      "CodeResponse": {
        "properties": {
          "curl": {
            "type": "string",
            "title": "Curl"
          },
          "requests": {
            "type": "string",
            "title": "Requests"
          },
          "nomad_lab": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Nomad Lab"
          }
        },
        "type": "object",
        "required": [
          "curl",
          "requests"
        ],
        "title": "CodeResponse"
      },
      "Criteria": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          },
          "value": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "number"
              },
              {
                "type": "boolean"
              },
              {
                "type": "string"
              },
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "items": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "number"
                    },
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "string"
                    },
                    {
                      "type": "string",
                      "format": "date-time"
                    }
                  ]
                },
                "type": "array"
              },
              {
                "$ref": "#/components/schemas/Range"
              },
              {
                "$ref": "#/components/schemas/Any_"
              },
              {
                "$ref": "#/components/schemas/All"
              },
              {
                "$ref": "#/components/schemas/None_"
              },
              {
                "type": "object"
              }
            ],
            "title": "Value"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "name",
          "value"
        ],
        "title": "Criteria"
      },
      "Dataset": {
        "properties": {
          "dataset_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Dataset Id",
            "description": "The unique identifier for this dataset as a string. It should be\na randomly generated UUID, similar to other nomad ids."
          },
          "dataset_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Dataset Name",
            "description": "The human-readable name of the dataset as string. The dataset name must be\nunique for the user."
          },
          "user_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "User Id",
            "description": "The unique user_id of the owner and creator of this dataset. The owner\nmust not change after creation."
          },
          "doi": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Doi",
            "description": "The optional Document Object Identifier (DOI) associated with this dataset.\nNomad can register DOIs that link back to the respective representation of\nthe dataset in the nomad UI. This quantity holds the string representation of\nthis DOI. There is only one per dataset. The DOI is just the DOI name, not its\nfull URL, e.g. \"10.17172/nomad/2019.10.29-1\"."
          },
          "pid": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Pid",
            "description": "The original NOMAD CoE Repository dataset PID. Old DOIs still reference\ndatasets based on this id. Is not used for new datasets."
          },
          "dataset_create_time": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Dataset Create Time",
            "description": "The date when the dataset was first created."
          },
          "dataset_modified_time": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Dataset Modified Time",
            "description": "The date when the dataset was last modified. An owned dataset\ncan only be extended after a DOI was assigned. A foreign dataset cannot be changed\nonce a DOI was assigned."
          },
          "dataset_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Dataset Type",
            "description": "The type determined if a dataset is owned, i.e. was created by\nthe authors of the contained entries; or if a dataset is foreign,\ni.e. it was created by someone not necessarily related to the entries."
          },
          "query": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Query"
          },
          "entries": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Entries"
          }
        },
        "type": "object",
        "title": "Dataset"
      },
      "DatasetCreate": {
        "properties": {
          "dataset_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Dataset Name",
            "description": "The new name for the dataset."
          },
          "dataset_type": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DatasetType"
              },
              {
                "type": "null"
              }
            ]
          },
          "query": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/And-Input"
              },
              {
                "$ref": "#/components/schemas/Or-Input"
              },
              {
                "$ref": "#/components/schemas/Not-Input"
              },
              {
                "$ref": "#/components/schemas/Nested-Input"
              },
              {
                "$ref": "#/components/schemas/Criteria"
              },
              {
                "$ref": "#/components/schemas/Empty"
              },
              {
                "additionalProperties": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "number"
                    },
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "string"
                    },
                    {
                      "type": "string",
                      "format": "date-time"
                    },
                    {
                      "items": {
                        "anyOf": [
                          {
                            "type": "integer"
                          },
                          {
                            "type": "number"
                          },
                          {
                            "type": "boolean"
                          },
                          {
                            "type": "string"
                          },
                          {
                            "type": "string",
                            "format": "date-time"
                          }
                        ]
                      },
                      "type": "array"
                    },
                    {
                      "$ref": "#/components/schemas/Range"
                    },
                    {
                      "$ref": "#/components/schemas/Any_"
                    },
                    {
                      "$ref": "#/components/schemas/All"
                    },
                    {
                      "$ref": "#/components/schemas/None_"
                    },
                    {
                      "type": "object"
                    }
                  ]
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Query"
          },
          "entries": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Entries"
          }
        },
        "type": "object",
        "title": "DatasetCreate"
      },
      "DatasetPagination": {
        "properties": {
          "page_size": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page Size",
            "description": "The page size, e.g. the maximum number of items contained in one response.\nA `page_size` of 0 will return no results.",
            "default": 10
          },
          "order_by": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Order By",
            "description": "The results are ordered by the values of this field. If omitted, default\nordering is applied."
          },
          "order": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Direction"
              },
              {
                "type": "null"
              }
            ],
            "description": "The ordering direction of the results based on `order_by`. Its either\nascending `asc` or descending `desc`. Default is `asc`.",
            "default": "asc"
          },
          "page_after_value": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page After Value",
            "description": "This attribute defines the position after which the page begins, and is used\nto navigate through the total list of results.\n\nWhen requesting the first page, no value should be provided for\n`page_after_value`. Each response will contain a value `next_page_after_value`,\nwhich can be used to obtain the next page (by setting `page_after_value` in\nyour next request to this value).\n\nThe field is encoded as a string, and the format of `page_after_value` and\n`next_page_after_value` depends on which API method is used.\n\nSome API functions additionally allows a simplified navigation, by specifying\nthe page number in the key `page`. It is however always possible to use\n`page_after_value` and `next_page_after_value` to iterate through the results."
          },
          "page": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page",
            "description": "The number of the page (1-based). When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used."
          },
          "page_offset": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page Offset",
            "description": "The number of skipped entries. When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page_offset` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used."
          }
        },
        "type": "object",
        "title": "DatasetPagination"
      },
      "DatasetQuery": {
        "properties": {
          "dataset_id": {
            "type": "string",
            "title": "Dataset Id"
          },
          "dataset_name": {
            "type": "string",
            "title": "Dataset Name"
          },
          "user_id": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "User Id"
          },
          "dataset_type": {
            "type": "string",
            "title": "Dataset Type"
          },
          "doi": {
            "type": "string",
            "title": "Doi"
          },
          "prefix": {
            "type": "string",
            "title": "Prefix"
          }
        },
        "type": "object",
        "title": "DatasetQuery"
      },
      "DatasetRequestOptions": {
        "properties": {
          "pagination": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DatasetPagination"
              },
              {
                "type": "null"
              }
            ]
          },
          "query": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DatasetQuery"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "title": "DatasetRequestOptions"
      },
      "DatasetResponse": {
        "properties": {
          "dataset_id": {
            "type": "string",
            "title": "Dataset Id",
            "description": "The unique dataset id. "
          },
          "data": {
            "$ref": "#/components/schemas/Dataset"
          }
        },
        "type": "object",
        "required": [
          "dataset_id",
          "data"
        ],
        "title": "DatasetResponse"
      },
      "DatasetResponseOptions": {
        "properties": {
          "pagination": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PaginationResponse"
              },
              {
                "type": "null"
              }
            ]
          },
          "query": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DatasetQuery"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "title": "DatasetResponseOptions"
      },
      "DatasetType": {
        "type": "string",
        "enum": [
          "owned",
          "foreign"
        ],
        "title": "DatasetType"
      },
      "DatasetsResponse": {
        "properties": {
          "pagination": {
            "$ref": "#/components/schemas/PaginationResponse"
          },
          "data": {
            "items": {
              "$ref": "#/components/schemas/Dataset"
            },
            "type": "array",
            "title": "Data"
          }
        },
        "type": "object",
        "title": "DatasetsResponse"
      },
      "DateHistogramAggregation": {
        "properties": {
          "quantity": {
            "type": "string",
            "title": "Quantity",
            "description": "The mandatory name of the quantity for the aggregation. Aggregations\ncan only be computed for those search metadata that have discrete values;\nan aggregation buckets entries that have the same value for this quantity."
          },
          "exclude_from_search": {
            "type": "boolean",
            "title": "Exclude From Search",
            "description": "If set to true, top-level search criteria involving the aggregation quantity, will not\nbe applied for this aggregation. Therefore, the aggregation will return all\nvalues for the quantity, even if the possible values where filtered by the query.\n\nThere are two limitations. This is only supported with queries that start with a\ndictionary. It will not work for queries with a boolean operator. It can only\nexclude top-level criteria at the root of the query dictionary. Nested criteria,\ne.g. within complex and/or constructs, cannot be considered. Using this might also\nprohibit pagination with page_after_value on aggregations in the same request.",
            "default": false
          },
          "metrics": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metrics",
            "description": "By default the returned aggregations will provide the number of entries for each\nvalue. You can add more metrics. For each metric an additional number will be\nprovided for each value. Metrics are also based on search metadata. Depending on\nthe metric the number will represent either a sum (`calculations` for the number\nof individual calculation in each code run) or an amount of different values\n(i.e. `materials` for the amount of different material hashes).",
            "default": []
          },
          "interval": {
            "type": "string",
            "title": "Interval",
            "default": "1M"
          }
        },
        "type": "object",
        "required": [
          "quantity"
        ],
        "title": "DateHistogramAggregation"
      },
      "DateHistogramAggregationResponse": {
        "properties": {
          "quantity": {
            "type": "string",
            "title": "Quantity",
            "description": "The mandatory name of the quantity for the aggregation. Aggregations\ncan only be computed for those search metadata that have discrete values;\nan aggregation buckets entries that have the same value for this quantity."
          },
          "exclude_from_search": {
            "type": "boolean",
            "title": "Exclude From Search",
            "description": "If set to true, top-level search criteria involving the aggregation quantity, will not\nbe applied for this aggregation. Therefore, the aggregation will return all\nvalues for the quantity, even if the possible values where filtered by the query.\n\nThere are two limitations. This is only supported with queries that start with a\ndictionary. It will not work for queries with a boolean operator. It can only\nexclude top-level criteria at the root of the query dictionary. Nested criteria,\ne.g. within complex and/or constructs, cannot be considered. Using this might also\nprohibit pagination with page_after_value on aggregations in the same request.",
            "default": false
          },
          "metrics": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metrics",
            "description": "By default the returned aggregations will provide the number of entries for each\nvalue. You can add more metrics. For each metric an additional number will be\nprovided for each value. Metrics are also based on search metadata. Depending on\nthe metric the number will represent either a sum (`calculations` for the number\nof individual calculation in each code run) or an amount of different values\n(i.e. `materials` for the amount of different material hashes).",
            "default": []
          },
          "interval": {
            "type": "string",
            "title": "Interval",
            "default": "1M"
          },
          "data": {
            "items": {
              "$ref": "#/components/schemas/Bucket"
            },
            "type": "array",
            "title": "Data",
            "description": "The aggregation data as a list."
          }
        },
        "type": "object",
        "required": [
          "quantity"
        ],
        "title": "DateHistogramAggregationResponse"
      },
      "DefinitionType": {
        "type": "string",
        "enum": [
          "specialized_only",
          "both",
          "none"
        ],
        "title": "DefinitionType"
      },
      "DeleteEntryFilesRequest": {
        "properties": {
          "owner": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Owner"
              },
              {
                "type": "null"
              }
            ],
            "default": "all"
          },
          "query": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/And-Input"
              },
              {
                "$ref": "#/components/schemas/Or-Input"
              },
              {
                "$ref": "#/components/schemas/Not-Input"
              },
              {
                "$ref": "#/components/schemas/Nested-Input"
              },
              {
                "$ref": "#/components/schemas/Criteria"
              },
              {
                "$ref": "#/components/schemas/Empty"
              },
              {
                "additionalProperties": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "number"
                    },
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "string"
                    },
                    {
                      "type": "string",
                      "format": "date-time"
                    },
                    {
                      "items": {
                        "anyOf": [
                          {
                            "type": "integer"
                          },
                          {
                            "type": "number"
                          },
                          {
                            "type": "boolean"
                          },
                          {
                            "type": "string"
                          },
                          {
                            "type": "string",
                            "format": "date-time"
                          }
                        ]
                      },
                      "type": "array"
                    },
                    {
                      "$ref": "#/components/schemas/Range"
                    },
                    {
                      "$ref": "#/components/schemas/Any_"
                    },
                    {
                      "$ref": "#/components/schemas/All"
                    },
                    {
                      "$ref": "#/components/schemas/None_"
                    },
                    {
                      "type": "object"
                    }
                  ]
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Query",
            "description": "A query can be a very simple list of parameters. Different parameters or values of the same parameter are combined\nwith a logical **and**.\nThe following query would search for all entries that are VASP calculations,\ncontain *Na* **and** *Cl*, **and** are authored by *Stefano Curtarolo*\n**and** *Chris Wolverton*.\n```json\n{\n    \"results.material.elements\": [\"Na\", \"Cl\"],\n    \"results.method.simulation.program_name\": \"VASP\",\n    \"authors\": [\"Stefano Curtarolo\", \"Chris Wolverton\"]\n}\n```\n\nA short cut to change the logical combination of values in a list, is to\nadd a suffix to the quantity `:any`:\n```json\n{\n    \"results.material.elements\": [\"Na\", \"Cl\"],\n    \"results.method.simulation.program_name\": \"VASP\",\n    \"authors:any\": [\"Stefano Curtarolo\", \"Chris Wolverton\"]\n}\n```\n\nOtherwise, you can also write complex logical combinations of parameters like this:\n```json\n{\n    \"and\": [\n        {\n            \"or\": [\n                {\n                    \"results.material.elements\": [\"Cl\", \"Na\"]\n                },\n                {\n                    \"results.material.elements\": [\"H\", \"O\"]\n                }\n            ]\n        },\n        {\n            \"not\": {\n                \"results.material.symmetry.crystal_system\": \"cubic\"\n            }\n        }\n    ]\n}\n```\nOther short-cut prefixes are `none:` and `any:` (the default).\n\nBy default all quantity values have to **equal** the given values to match. For\nsome values you can also use comparison operators like this:\n```json\n{\n    \"upload_create_time\": {\n        \"gt\": \"2020-01-01\",\n        \"lt\": \"2020-08-01\"\n    },\n    \"results.properties.geometry_optimization.final_energy_difference\": {\n        \"lte\": 1.23e-18\n    }\n}\n```\n\nor shorter with suffixes:\n```json\n{\n    \"upload_create_time:gt\": \"2020-01-01\",\n    \"upload_create_time:lt\": \"2020-08-01\",\n    \"results.properties.geometry_optimization.final_energy_difference:lte\": 1.23e-18\n}\n```\n\nThe searchable quantities are a subset of the NOMAD Archive quantities defined\nin the NOMAD Metainfo. The searchable quantities also depend on the API endpoint.\n\nThere is also an additional query parameter that you can use to formulate queries based\non the optimade filter language:\n```json\n{\n    \"optimade_filter\": \"nelements >= 2 AND elements HAS ALL 'Ti', 'O'\"\n}\n```"
          },
          "include_parent_folders": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Include Parent Folders",
            "description": "If the delete operation should include not only the mainfiles of the selected entries,\nbut also their folders.",
            "default": false
          }
        },
        "type": "object",
        "title": "DeleteEntryFilesRequest",
        "description": "Defines a request to delete entry files."
      },
      "Direction": {
        "type": "string",
        "enum": [
          "asc",
          "desc"
        ],
        "title": "Direction",
        "description": "Order direction, either ascending (`asc`) or descending (`desc`)"
      },
      "DirectiveType": {
        "type": "string",
        "enum": [
          "plain",
          "resolved"
        ],
        "title": "DirectiveType"
      },
      "DirectoryResponseOptions": {
        "properties": {
          "pagination": {
            "$ref": "#/components/schemas/PaginationResponse"
          }
        },
        "type": "object",
        "required": [
          "pagination"
        ],
        "title": "DirectoryResponseOptions"
      },
      "Empty": {
        "properties": {},
        "additionalProperties": false,
        "type": "object",
        "title": "Empty"
      },
      "EntriesArchive": {
        "properties": {
          "owner": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Owner"
              },
              {
                "type": "null"
              }
            ],
            "default": "public"
          },
          "query": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/And-Input"
              },
              {
                "$ref": "#/components/schemas/Or-Input"
              },
              {
                "$ref": "#/components/schemas/Not-Input"
              },
              {
                "$ref": "#/components/schemas/Nested-Input"
              },
              {
                "$ref": "#/components/schemas/Criteria"
              },
              {
                "$ref": "#/components/schemas/Empty"
              },
              {
                "additionalProperties": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "number"
                    },
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "string"
                    },
                    {
                      "type": "string",
                      "format": "date-time"
                    },
                    {
                      "items": {
                        "anyOf": [
                          {
                            "type": "integer"
                          },
                          {
                            "type": "number"
                          },
                          {
                            "type": "boolean"
                          },
                          {
                            "type": "string"
                          },
                          {
                            "type": "string",
                            "format": "date-time"
                          }
                        ]
                      },
                      "type": "array"
                    },
                    {
                      "$ref": "#/components/schemas/Range"
                    },
                    {
                      "$ref": "#/components/schemas/Any_"
                    },
                    {
                      "$ref": "#/components/schemas/All"
                    },
                    {
                      "$ref": "#/components/schemas/None_"
                    },
                    {
                      "type": "object"
                    }
                  ]
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Query",
            "description": "A query can be a very simple list of parameters. Different parameters or values of the same parameter are combined\nwith a logical **and**.\nThe following query would search for all entries that are VASP calculations,\ncontain *Na* **and** *Cl*, **and** are authored by *Stefano Curtarolo*\n**and** *Chris Wolverton*.\n```json\n{\n    \"results.material.elements\": [\"Na\", \"Cl\"],\n    \"results.method.simulation.program_name\": \"VASP\",\n    \"authors\": [\"Stefano Curtarolo\", \"Chris Wolverton\"]\n}\n```\n\nA short cut to change the logical combination of values in a list, is to\nadd a suffix to the quantity `:any`:\n```json\n{\n    \"results.material.elements\": [\"Na\", \"Cl\"],\n    \"results.method.simulation.program_name\": \"VASP\",\n    \"authors:any\": [\"Stefano Curtarolo\", \"Chris Wolverton\"]\n}\n```\n\nOtherwise, you can also write complex logical combinations of parameters like this:\n```json\n{\n    \"and\": [\n        {\n            \"or\": [\n                {\n                    \"results.material.elements\": [\"Cl\", \"Na\"]\n                },\n                {\n                    \"results.material.elements\": [\"H\", \"O\"]\n                }\n            ]\n        },\n        {\n            \"not\": {\n                \"results.material.symmetry.crystal_system\": \"cubic\"\n            }\n        }\n    ]\n}\n```\nOther short-cut prefixes are `none:` and `any:` (the default).\n\nBy default all quantity values have to **equal** the given values to match. For\nsome values you can also use comparison operators like this:\n```json\n{\n    \"upload_create_time\": {\n        \"gt\": \"2020-01-01\",\n        \"lt\": \"2020-08-01\"\n    },\n    \"results.properties.geometry_optimization.final_energy_difference\": {\n        \"lte\": 1.23e-18\n    }\n}\n```\n\nor shorter with suffixes:\n```json\n{\n    \"upload_create_time:gt\": \"2020-01-01\",\n    \"upload_create_time:lt\": \"2020-08-01\",\n    \"results.properties.geometry_optimization.final_energy_difference:lte\": 1.23e-18\n}\n```\n\nThe searchable quantities are a subset of the NOMAD Archive quantities defined\nin the NOMAD Metainfo. The searchable quantities also depend on the API endpoint.\n\nThere is also an additional query parameter that you can use to formulate queries based\non the optimade filter language:\n```json\n{\n    \"optimade_filter\": \"nelements >= 2 AND elements HAS ALL 'Ti', 'O'\"\n}\n```"
          },
          "pagination": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MetadataPagination"
              },
              {
                "type": "null"
              }
            ]
          },
          "required": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Required",
            "description": "The `required` part allows you to specify what parts of the requested archives\nshould be returned. The NOMAD Archive is a hierarchical data format and\nyou can *require* certain branches (i.e. *sections*) in the hierarchy.\nBy specifying certain sections with specific contents or all contents (via\nthe directive `\"*\"`), you can determine what sections and what quantities should\nbe returned. The default is the whole archive, i.e., `\"*\"`.\n\nFor example to specify that you are only interested in the `metadata`\nuse:\n\n```json\n{\n    \"metadata\": \"*\"\n}\n```\n\nOr to only get the `energy_total` from each individual entry, use:\n```json\n{\n    \"run\": {\n        \"configuration\": {\n            \"energy\": \"*\"\n        }\n    }\n}\n```\n\nYou can also request certain parts of a list, e.g. the last calculation:\n```json\n{\n    \"run\": {\n        \"calculation[-1]\": \"*\"\n    }\n}\n```\n\nThese required specifications are also very useful to get workflow results.\nThis works because we can use references (e.g. workflow to final result calculation)\nand the API will resolve these references and return the respective data.\nFor example just the total energy value and reduced formula from the resulting\ncalculation:\n```json\n{\n    \"workflow\": {\n        \"calculation_result_ref\": {\n            \"energy\": \"*\",\n            \"system_ref\": {\n                \"value\": {\n                    \"chemical_composition\": \"*\"\n                }\n            }\n        }\n    }\n}\n```\n\nYou can also resolve all references in a branch with the `include-resolved`\ndirective. This will resolve all references in the branch, and also all references\nin referenced sections:\n```json\n{\n    \"workflow\":\n        \"calculation_result_ref\": \"include-resolved\"\n    }\n}\n```\n\nBy default, the targets of \"resolved\" references are added to the archive at\ntheir original hierarchy positions.\nThis means, all references are still references, but they are resolvable within\nthe returned data, since they targets are now part of the data. Another option\nis to add\n`\"resolve-inplace\": true` to the root of required. Here, the reference targets will\nreplace the references:\n```json\n{\n    \"resolve-inplace\": true,\n    \"workflow\":\n        \"calculation_result_ref\": \"include-resolved\"\n    }\n}\n```",
            "default": "*"
          }
        },
        "type": "object",
        "title": "EntriesArchive"
      },
      "EntriesArchiveDownload": {
        "properties": {
          "required": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Required",
            "description": "The `required` part allows you to specify what parts of the requested archives\nshould be returned. The NOMAD Archive is a hierarchical data format and\nyou can *require* certain branches (i.e. *sections*) in the hierarchy.\nBy specifying certain sections with specific contents or all contents (via\nthe directive `\"*\"`), you can determine what sections and what quantities should\nbe returned. The default is the whole archive, i.e., `\"*\"`.\n\nFor example to specify that you are only interested in the `metadata`\nuse:\n\n```json\n{\n    \"metadata\": \"*\"\n}\n```\n\nOr to only get the `energy_total` from each individual entry, use:\n```json\n{\n    \"run\": {\n        \"configuration\": {\n            \"energy\": \"*\"\n        }\n    }\n}\n```\n\nYou can also request certain parts of a list, e.g. the last calculation:\n```json\n{\n    \"run\": {\n        \"calculation[-1]\": \"*\"\n    }\n}\n```\n\nThese required specifications are also very useful to get workflow results.\nThis works because we can use references (e.g. workflow to final result calculation)\nand the API will resolve these references and return the respective data.\nFor example just the total energy value and reduced formula from the resulting\ncalculation:\n```json\n{\n    \"workflow\": {\n        \"calculation_result_ref\": {\n            \"energy\": \"*\",\n            \"system_ref\": {\n                \"value\": {\n                    \"chemical_composition\": \"*\"\n                }\n            }\n        }\n    }\n}\n```\n\nYou can also resolve all references in a branch with the `include-resolved`\ndirective. This will resolve all references in the branch, and also all references\nin referenced sections:\n```json\n{\n    \"workflow\":\n        \"calculation_result_ref\": \"include-resolved\"\n    }\n}\n```\n\nBy default, the targets of \"resolved\" references are added to the archive at\ntheir original hierarchy positions.\nThis means, all references are still references, but they are resolvable within\nthe returned data, since they targets are now part of the data. Another option\nis to add\n`\"resolve-inplace\": true` to the root of required. Here, the reference targets will\nreplace the references:\n```json\n{\n    \"resolve-inplace\": true,\n    \"workflow\":\n        \"calculation_result_ref\": \"include-resolved\"\n    }\n}\n```",
            "default": "*"
          },
          "owner": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Owner"
              },
              {
                "type": "null"
              }
            ],
            "default": "public"
          },
          "query": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/And-Input"
              },
              {
                "$ref": "#/components/schemas/Or-Input"
              },
              {
                "$ref": "#/components/schemas/Not-Input"
              },
              {
                "$ref": "#/components/schemas/Nested-Input"
              },
              {
                "$ref": "#/components/schemas/Criteria"
              },
              {
                "$ref": "#/components/schemas/Empty"
              },
              {
                "additionalProperties": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "number"
                    },
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "string"
                    },
                    {
                      "type": "string",
                      "format": "date-time"
                    },
                    {
                      "items": {
                        "anyOf": [
                          {
                            "type": "integer"
                          },
                          {
                            "type": "number"
                          },
                          {
                            "type": "boolean"
                          },
                          {
                            "type": "string"
                          },
                          {
                            "type": "string",
                            "format": "date-time"
                          }
                        ]
                      },
                      "type": "array"
                    },
                    {
                      "$ref": "#/components/schemas/Range"
                    },
                    {
                      "$ref": "#/components/schemas/Any_"
                    },
                    {
                      "$ref": "#/components/schemas/All"
                    },
                    {
                      "$ref": "#/components/schemas/None_"
                    },
                    {
                      "type": "object"
                    }
                  ]
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Query",
            "description": "A query can be a very simple list of parameters. Different parameters or values of the same parameter are combined\nwith a logical **and**.\nThe following query would search for all entries that are VASP calculations,\ncontain *Na* **and** *Cl*, **and** are authored by *Stefano Curtarolo*\n**and** *Chris Wolverton*.\n```json\n{\n    \"results.material.elements\": [\"Na\", \"Cl\"],\n    \"results.method.simulation.program_name\": \"VASP\",\n    \"authors\": [\"Stefano Curtarolo\", \"Chris Wolverton\"]\n}\n```\n\nA short cut to change the logical combination of values in a list, is to\nadd a suffix to the quantity `:any`:\n```json\n{\n    \"results.material.elements\": [\"Na\", \"Cl\"],\n    \"results.method.simulation.program_name\": \"VASP\",\n    \"authors:any\": [\"Stefano Curtarolo\", \"Chris Wolverton\"]\n}\n```\n\nOtherwise, you can also write complex logical combinations of parameters like this:\n```json\n{\n    \"and\": [\n        {\n            \"or\": [\n                {\n                    \"results.material.elements\": [\"Cl\", \"Na\"]\n                },\n                {\n                    \"results.material.elements\": [\"H\", \"O\"]\n                }\n            ]\n        },\n        {\n            \"not\": {\n                \"results.material.symmetry.crystal_system\": \"cubic\"\n            }\n        }\n    ]\n}\n```\nOther short-cut prefixes are `none:` and `any:` (the default).\n\nBy default all quantity values have to **equal** the given values to match. For\nsome values you can also use comparison operators like this:\n```json\n{\n    \"upload_create_time\": {\n        \"gt\": \"2020-01-01\",\n        \"lt\": \"2020-08-01\"\n    },\n    \"results.properties.geometry_optimization.final_energy_difference\": {\n        \"lte\": 1.23e-18\n    }\n}\n```\n\nor shorter with suffixes:\n```json\n{\n    \"upload_create_time:gt\": \"2020-01-01\",\n    \"upload_create_time:lt\": \"2020-08-01\",\n    \"results.properties.geometry_optimization.final_energy_difference:lte\": 1.23e-18\n}\n```\n\nThe searchable quantities are a subset of the NOMAD Archive quantities defined\nin the NOMAD Metainfo. The searchable quantities also depend on the API endpoint.\n\nThere is also an additional query parameter that you can use to formulate queries based\non the optimade filter language:\n```json\n{\n    \"optimade_filter\": \"nelements >= 2 AND elements HAS ALL 'Ti', 'O'\"\n}\n```"
          },
          "files": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Files"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "title": "EntriesArchiveDownload"
      },
      "EntriesArchiveResponse": {
        "properties": {
          "owner": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Owner"
              },
              {
                "type": "null"
              }
            ],
            "default": "public"
          },
          "query": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/And-Output"
              },
              {
                "$ref": "#/components/schemas/Or-Output"
              },
              {
                "$ref": "#/components/schemas/Not-Output"
              },
              {
                "$ref": "#/components/schemas/Nested-Output"
              },
              {
                "$ref": "#/components/schemas/Criteria"
              },
              {
                "$ref": "#/components/schemas/Empty"
              },
              {
                "additionalProperties": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "number"
                    },
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "string"
                    },
                    {
                      "type": "string",
                      "format": "date-time"
                    },
                    {
                      "items": {
                        "anyOf": [
                          {
                            "type": "integer"
                          },
                          {
                            "type": "number"
                          },
                          {
                            "type": "boolean"
                          },
                          {
                            "type": "string"
                          },
                          {
                            "type": "string",
                            "format": "date-time"
                          }
                        ]
                      },
                      "type": "array"
                    },
                    {
                      "$ref": "#/components/schemas/Range"
                    },
                    {
                      "$ref": "#/components/schemas/Any_"
                    },
                    {
                      "$ref": "#/components/schemas/All"
                    },
                    {
                      "$ref": "#/components/schemas/None_"
                    },
                    {
                      "type": "object"
                    }
                  ]
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Query",
            "description": "A query can be a very simple list of parameters. Different parameters or values of the same parameter are combined\nwith a logical **and**.\nThe following query would search for all entries that are VASP calculations,\ncontain *Na* **and** *Cl*, **and** are authored by *Stefano Curtarolo*\n**and** *Chris Wolverton*.\n```json\n{\n    \"results.material.elements\": [\"Na\", \"Cl\"],\n    \"results.method.simulation.program_name\": \"VASP\",\n    \"authors\": [\"Stefano Curtarolo\", \"Chris Wolverton\"]\n}\n```\n\nA short cut to change the logical combination of values in a list, is to\nadd a suffix to the quantity `:any`:\n```json\n{\n    \"results.material.elements\": [\"Na\", \"Cl\"],\n    \"results.method.simulation.program_name\": \"VASP\",\n    \"authors:any\": [\"Stefano Curtarolo\", \"Chris Wolverton\"]\n}\n```\n\nOtherwise, you can also write complex logical combinations of parameters like this:\n```json\n{\n    \"and\": [\n        {\n            \"or\": [\n                {\n                    \"results.material.elements\": [\"Cl\", \"Na\"]\n                },\n                {\n                    \"results.material.elements\": [\"H\", \"O\"]\n                }\n            ]\n        },\n        {\n            \"not\": {\n                \"results.material.symmetry.crystal_system\": \"cubic\"\n            }\n        }\n    ]\n}\n```\nOther short-cut prefixes are `none:` and `any:` (the default).\n\nBy default all quantity values have to **equal** the given values to match. For\nsome values you can also use comparison operators like this:\n```json\n{\n    \"upload_create_time\": {\n        \"gt\": \"2020-01-01\",\n        \"lt\": \"2020-08-01\"\n    },\n    \"results.properties.geometry_optimization.final_energy_difference\": {\n        \"lte\": 1.23e-18\n    }\n}\n```\n\nor shorter with suffixes:\n```json\n{\n    \"upload_create_time:gt\": \"2020-01-01\",\n    \"upload_create_time:lt\": \"2020-08-01\",\n    \"results.properties.geometry_optimization.final_energy_difference:lte\": 1.23e-18\n}\n```\n\nThe searchable quantities are a subset of the NOMAD Archive quantities defined\nin the NOMAD Metainfo. The searchable quantities also depend on the API endpoint.\n\nThere is also an additional query parameter that you can use to formulate queries based\non the optimade filter language:\n```json\n{\n    \"optimade_filter\": \"nelements >= 2 AND elements HAS ALL 'Ti', 'O'\"\n}\n```"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationResponse"
          },
          "required": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Required",
            "description": "The `required` part allows you to specify what parts of the requested archives\nshould be returned. The NOMAD Archive is a hierarchical data format and\nyou can *require* certain branches (i.e. *sections*) in the hierarchy.\nBy specifying certain sections with specific contents or all contents (via\nthe directive `\"*\"`), you can determine what sections and what quantities should\nbe returned. The default is the whole archive, i.e., `\"*\"`.\n\nFor example to specify that you are only interested in the `metadata`\nuse:\n\n```json\n{\n    \"metadata\": \"*\"\n}\n```\n\nOr to only get the `energy_total` from each individual entry, use:\n```json\n{\n    \"run\": {\n        \"configuration\": {\n            \"energy\": \"*\"\n        }\n    }\n}\n```\n\nYou can also request certain parts of a list, e.g. the last calculation:\n```json\n{\n    \"run\": {\n        \"calculation[-1]\": \"*\"\n    }\n}\n```\n\nThese required specifications are also very useful to get workflow results.\nThis works because we can use references (e.g. workflow to final result calculation)\nand the API will resolve these references and return the respective data.\nFor example just the total energy value and reduced formula from the resulting\ncalculation:\n```json\n{\n    \"workflow\": {\n        \"calculation_result_ref\": {\n            \"energy\": \"*\",\n            \"system_ref\": {\n                \"value\": {\n                    \"chemical_composition\": \"*\"\n                }\n            }\n        }\n    }\n}\n```\n\nYou can also resolve all references in a branch with the `include-resolved`\ndirective. This will resolve all references in the branch, and also all references\nin referenced sections:\n```json\n{\n    \"workflow\":\n        \"calculation_result_ref\": \"include-resolved\"\n    }\n}\n```\n\nBy default, the targets of \"resolved\" references are added to the archive at\ntheir original hierarchy positions.\nThis means, all references are still references, but they are resolvable within\nthe returned data, since they targets are now part of the data. Another option\nis to add\n`\"resolve-inplace\": true` to the root of required. Here, the reference targets will\nreplace the references:\n```json\n{\n    \"resolve-inplace\": true,\n    \"workflow\":\n        \"calculation_result_ref\": \"include-resolved\"\n    }\n}\n```",
            "default": "*"
          },
          "data": {
            "items": {
              "$ref": "#/components/schemas/EntryArchive"
            },
            "type": "array",
            "title": "Data"
          }
        },
        "type": "object",
        "title": "EntriesArchiveResponse"
      },
      "EntriesRaw": {
        "properties": {
          "owner": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Owner"
              },
              {
                "type": "null"
              }
            ],
            "default": "public"
          },
          "query": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/And-Input"
              },
              {
                "$ref": "#/components/schemas/Or-Input"
              },
              {
                "$ref": "#/components/schemas/Not-Input"
              },
              {
                "$ref": "#/components/schemas/Nested-Input"
              },
              {
                "$ref": "#/components/schemas/Criteria"
              },
              {
                "$ref": "#/components/schemas/Empty"
              },
              {
                "additionalProperties": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "number"
                    },
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "string"
                    },
                    {
                      "type": "string",
                      "format": "date-time"
                    },
                    {
                      "items": {
                        "anyOf": [
                          {
                            "type": "integer"
                          },
                          {
                            "type": "number"
                          },
                          {
                            "type": "boolean"
                          },
                          {
                            "type": "string"
                          },
                          {
                            "type": "string",
                            "format": "date-time"
                          }
                        ]
                      },
                      "type": "array"
                    },
                    {
                      "$ref": "#/components/schemas/Range"
                    },
                    {
                      "$ref": "#/components/schemas/Any_"
                    },
                    {
                      "$ref": "#/components/schemas/All"
                    },
                    {
                      "$ref": "#/components/schemas/None_"
                    },
                    {
                      "type": "object"
                    }
                  ]
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Query",
            "description": "A query can be a very simple list of parameters. Different parameters or values of the same parameter are combined\nwith a logical **and**.\nThe following query would search for all entries that are VASP calculations,\ncontain *Na* **and** *Cl*, **and** are authored by *Stefano Curtarolo*\n**and** *Chris Wolverton*.\n```json\n{\n    \"results.material.elements\": [\"Na\", \"Cl\"],\n    \"results.method.simulation.program_name\": \"VASP\",\n    \"authors\": [\"Stefano Curtarolo\", \"Chris Wolverton\"]\n}\n```\n\nA short cut to change the logical combination of values in a list, is to\nadd a suffix to the quantity `:any`:\n```json\n{\n    \"results.material.elements\": [\"Na\", \"Cl\"],\n    \"results.method.simulation.program_name\": \"VASP\",\n    \"authors:any\": [\"Stefano Curtarolo\", \"Chris Wolverton\"]\n}\n```\n\nOtherwise, you can also write complex logical combinations of parameters like this:\n```json\n{\n    \"and\": [\n        {\n            \"or\": [\n                {\n                    \"results.material.elements\": [\"Cl\", \"Na\"]\n                },\n                {\n                    \"results.material.elements\": [\"H\", \"O\"]\n                }\n            ]\n        },\n        {\n            \"not\": {\n                \"results.material.symmetry.crystal_system\": \"cubic\"\n            }\n        }\n    ]\n}\n```\nOther short-cut prefixes are `none:` and `any:` (the default).\n\nBy default all quantity values have to **equal** the given values to match. For\nsome values you can also use comparison operators like this:\n```json\n{\n    \"upload_create_time\": {\n        \"gt\": \"2020-01-01\",\n        \"lt\": \"2020-08-01\"\n    },\n    \"results.properties.geometry_optimization.final_energy_difference\": {\n        \"lte\": 1.23e-18\n    }\n}\n```\n\nor shorter with suffixes:\n```json\n{\n    \"upload_create_time:gt\": \"2020-01-01\",\n    \"upload_create_time:lt\": \"2020-08-01\",\n    \"results.properties.geometry_optimization.final_energy_difference:lte\": 1.23e-18\n}\n```\n\nThe searchable quantities are a subset of the NOMAD Archive quantities defined\nin the NOMAD Metainfo. The searchable quantities also depend on the API endpoint.\n\nThere is also an additional query parameter that you can use to formulate queries based\non the optimade filter language:\n```json\n{\n    \"optimade_filter\": \"nelements >= 2 AND elements HAS ALL 'Ti', 'O'\"\n}\n```"
          },
          "files": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Files"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "title": "EntriesRaw"
      },
      "EntriesRawDir": {
        "properties": {
          "owner": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Owner"
              },
              {
                "type": "null"
              }
            ],
            "default": "public"
          },
          "query": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/And-Input"
              },
              {
                "$ref": "#/components/schemas/Or-Input"
              },
              {
                "$ref": "#/components/schemas/Not-Input"
              },
              {
                "$ref": "#/components/schemas/Nested-Input"
              },
              {
                "$ref": "#/components/schemas/Criteria"
              },
              {
                "$ref": "#/components/schemas/Empty"
              },
              {
                "additionalProperties": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "number"
                    },
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "string"
                    },
                    {
                      "type": "string",
                      "format": "date-time"
                    },
                    {
                      "items": {
                        "anyOf": [
                          {
                            "type": "integer"
                          },
                          {
                            "type": "number"
                          },
                          {
                            "type": "boolean"
                          },
                          {
                            "type": "string"
                          },
                          {
                            "type": "string",
                            "format": "date-time"
                          }
                        ]
                      },
                      "type": "array"
                    },
                    {
                      "$ref": "#/components/schemas/Range"
                    },
                    {
                      "$ref": "#/components/schemas/Any_"
                    },
                    {
                      "$ref": "#/components/schemas/All"
                    },
                    {
                      "$ref": "#/components/schemas/None_"
                    },
                    {
                      "type": "object"
                    }
                  ]
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Query",
            "description": "A query can be a very simple list of parameters. Different parameters or values of the same parameter are combined\nwith a logical **and**.\nThe following query would search for all entries that are VASP calculations,\ncontain *Na* **and** *Cl*, **and** are authored by *Stefano Curtarolo*\n**and** *Chris Wolverton*.\n```json\n{\n    \"results.material.elements\": [\"Na\", \"Cl\"],\n    \"results.method.simulation.program_name\": \"VASP\",\n    \"authors\": [\"Stefano Curtarolo\", \"Chris Wolverton\"]\n}\n```\n\nA short cut to change the logical combination of values in a list, is to\nadd a suffix to the quantity `:any`:\n```json\n{\n    \"results.material.elements\": [\"Na\", \"Cl\"],\n    \"results.method.simulation.program_name\": \"VASP\",\n    \"authors:any\": [\"Stefano Curtarolo\", \"Chris Wolverton\"]\n}\n```\n\nOtherwise, you can also write complex logical combinations of parameters like this:\n```json\n{\n    \"and\": [\n        {\n            \"or\": [\n                {\n                    \"results.material.elements\": [\"Cl\", \"Na\"]\n                },\n                {\n                    \"results.material.elements\": [\"H\", \"O\"]\n                }\n            ]\n        },\n        {\n            \"not\": {\n                \"results.material.symmetry.crystal_system\": \"cubic\"\n            }\n        }\n    ]\n}\n```\nOther short-cut prefixes are `none:` and `any:` (the default).\n\nBy default all quantity values have to **equal** the given values to match. For\nsome values you can also use comparison operators like this:\n```json\n{\n    \"upload_create_time\": {\n        \"gt\": \"2020-01-01\",\n        \"lt\": \"2020-08-01\"\n    },\n    \"results.properties.geometry_optimization.final_energy_difference\": {\n        \"lte\": 1.23e-18\n    }\n}\n```\n\nor shorter with suffixes:\n```json\n{\n    \"upload_create_time:gt\": \"2020-01-01\",\n    \"upload_create_time:lt\": \"2020-08-01\",\n    \"results.properties.geometry_optimization.final_energy_difference:lte\": 1.23e-18\n}\n```\n\nThe searchable quantities are a subset of the NOMAD Archive quantities defined\nin the NOMAD Metainfo. The searchable quantities also depend on the API endpoint.\n\nThere is also an additional query parameter that you can use to formulate queries based\non the optimade filter language:\n```json\n{\n    \"optimade_filter\": \"nelements >= 2 AND elements HAS ALL 'Ti', 'O'\"\n}\n```"
          },
          "pagination": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MetadataPagination"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "title": "EntriesRawDir"
      },
      "EntriesRawDirResponse": {
        "properties": {
          "owner": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Owner"
              },
              {
                "type": "null"
              }
            ],
            "default": "public"
          },
          "query": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/And-Output"
              },
              {
                "$ref": "#/components/schemas/Or-Output"
              },
              {
                "$ref": "#/components/schemas/Not-Output"
              },
              {
                "$ref": "#/components/schemas/Nested-Output"
              },
              {
                "$ref": "#/components/schemas/Criteria"
              },
              {
                "$ref": "#/components/schemas/Empty"
              },
              {
                "additionalProperties": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "number"
                    },
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "string"
                    },
                    {
                      "type": "string",
                      "format": "date-time"
                    },
                    {
                      "items": {
                        "anyOf": [
                          {
                            "type": "integer"
                          },
                          {
                            "type": "number"
                          },
                          {
                            "type": "boolean"
                          },
                          {
                            "type": "string"
                          },
                          {
                            "type": "string",
                            "format": "date-time"
                          }
                        ]
                      },
                      "type": "array"
                    },
                    {
                      "$ref": "#/components/schemas/Range"
                    },
                    {
                      "$ref": "#/components/schemas/Any_"
                    },
                    {
                      "$ref": "#/components/schemas/All"
                    },
                    {
                      "$ref": "#/components/schemas/None_"
                    },
                    {
                      "type": "object"
                    }
                  ]
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Query",
            "description": "A query can be a very simple list of parameters. Different parameters or values of the same parameter are combined\nwith a logical **and**.\nThe following query would search for all entries that are VASP calculations,\ncontain *Na* **and** *Cl*, **and** are authored by *Stefano Curtarolo*\n**and** *Chris Wolverton*.\n```json\n{\n    \"results.material.elements\": [\"Na\", \"Cl\"],\n    \"results.method.simulation.program_name\": \"VASP\",\n    \"authors\": [\"Stefano Curtarolo\", \"Chris Wolverton\"]\n}\n```\n\nA short cut to change the logical combination of values in a list, is to\nadd a suffix to the quantity `:any`:\n```json\n{\n    \"results.material.elements\": [\"Na\", \"Cl\"],\n    \"results.method.simulation.program_name\": \"VASP\",\n    \"authors:any\": [\"Stefano Curtarolo\", \"Chris Wolverton\"]\n}\n```\n\nOtherwise, you can also write complex logical combinations of parameters like this:\n```json\n{\n    \"and\": [\n        {\n            \"or\": [\n                {\n                    \"results.material.elements\": [\"Cl\", \"Na\"]\n                },\n                {\n                    \"results.material.elements\": [\"H\", \"O\"]\n                }\n            ]\n        },\n        {\n            \"not\": {\n                \"results.material.symmetry.crystal_system\": \"cubic\"\n            }\n        }\n    ]\n}\n```\nOther short-cut prefixes are `none:` and `any:` (the default).\n\nBy default all quantity values have to **equal** the given values to match. For\nsome values you can also use comparison operators like this:\n```json\n{\n    \"upload_create_time\": {\n        \"gt\": \"2020-01-01\",\n        \"lt\": \"2020-08-01\"\n    },\n    \"results.properties.geometry_optimization.final_energy_difference\": {\n        \"lte\": 1.23e-18\n    }\n}\n```\n\nor shorter with suffixes:\n```json\n{\n    \"upload_create_time:gt\": \"2020-01-01\",\n    \"upload_create_time:lt\": \"2020-08-01\",\n    \"results.properties.geometry_optimization.final_energy_difference:lte\": 1.23e-18\n}\n```\n\nThe searchable quantities are a subset of the NOMAD Archive quantities defined\nin the NOMAD Metainfo. The searchable quantities also depend on the API endpoint.\n\nThere is also an additional query parameter that you can use to formulate queries based\non the optimade filter language:\n```json\n{\n    \"optimade_filter\": \"nelements >= 2 AND elements HAS ALL 'Ti', 'O'\"\n}\n```"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationResponse"
          },
          "data": {
            "items": {
              "$ref": "#/components/schemas/EntryRawDir"
            },
            "type": "array",
            "title": "Data"
          }
        },
        "type": "object",
        "title": "EntriesRawDirResponse"
      },
      "EntriesRequestOptions": {
        "properties": {
          "pagination": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EntryProcDataPagination"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "title": "EntriesRequestOptions"
      },
      "EntriesResponseOptions": {
        "properties": {
          "pagination": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PaginationResponse"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "title": "EntriesResponseOptions"
      },
      "EntryArchive": {
        "properties": {
          "entry_id": {
            "type": "string",
            "title": "Entry Id"
          },
          "upload_id": {
            "type": "string",
            "title": "Upload Id"
          },
          "parser_name": {
            "type": "string",
            "title": "Parser Name"
          },
          "archive": {
            "type": "object",
            "title": "Archive"
          }
        },
        "type": "object",
        "title": "EntryArchive"
      },
      "EntryArchiveRequest": {
        "properties": {
          "required": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Required",
            "description": "The `required` part allows you to specify what parts of the requested archives\nshould be returned. The NOMAD Archive is a hierarchical data format and\nyou can *require* certain branches (i.e. *sections*) in the hierarchy.\nBy specifying certain sections with specific contents or all contents (via\nthe directive `\"*\"`), you can determine what sections and what quantities should\nbe returned. The default is the whole archive, i.e., `\"*\"`.\n\nFor example to specify that you are only interested in the `metadata`\nuse:\n\n```json\n{\n    \"metadata\": \"*\"\n}\n```\n\nOr to only get the `energy_total` from each individual entry, use:\n```json\n{\n    \"run\": {\n        \"configuration\": {\n            \"energy\": \"*\"\n        }\n    }\n}\n```\n\nYou can also request certain parts of a list, e.g. the last calculation:\n```json\n{\n    \"run\": {\n        \"calculation[-1]\": \"*\"\n    }\n}\n```\n\nThese required specifications are also very useful to get workflow results.\nThis works because we can use references (e.g. workflow to final result calculation)\nand the API will resolve these references and return the respective data.\nFor example just the total energy value and reduced formula from the resulting\ncalculation:\n```json\n{\n    \"workflow\": {\n        \"calculation_result_ref\": {\n            \"energy\": \"*\",\n            \"system_ref\": {\n                \"value\": {\n                    \"chemical_composition\": \"*\"\n                }\n            }\n        }\n    }\n}\n```\n\nYou can also resolve all references in a branch with the `include-resolved`\ndirective. This will resolve all references in the branch, and also all references\nin referenced sections:\n```json\n{\n    \"workflow\":\n        \"calculation_result_ref\": \"include-resolved\"\n    }\n}\n```\n\nBy default, the targets of \"resolved\" references are added to the archive at\ntheir original hierarchy positions.\nThis means, all references are still references, but they are resolvable within\nthe returned data, since they targets are now part of the data. Another option\nis to add\n`\"resolve-inplace\": true` to the root of required. Here, the reference targets will\nreplace the references:\n```json\n{\n    \"resolve-inplace\": true,\n    \"workflow\":\n        \"calculation_result_ref\": \"include-resolved\"\n    }\n}\n```",
            "default": "*"
          }
        },
        "type": "object",
        "title": "EntryArchiveRequest"
      },
      "EntryArchiveResponse": {
        "properties": {
          "required": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Required",
            "description": "The `required` part allows you to specify what parts of the requested archives\nshould be returned. The NOMAD Archive is a hierarchical data format and\nyou can *require* certain branches (i.e. *sections*) in the hierarchy.\nBy specifying certain sections with specific contents or all contents (via\nthe directive `\"*\"`), you can determine what sections and what quantities should\nbe returned. The default is the whole archive, i.e., `\"*\"`.\n\nFor example to specify that you are only interested in the `metadata`\nuse:\n\n```json\n{\n    \"metadata\": \"*\"\n}\n```\n\nOr to only get the `energy_total` from each individual entry, use:\n```json\n{\n    \"run\": {\n        \"configuration\": {\n            \"energy\": \"*\"\n        }\n    }\n}\n```\n\nYou can also request certain parts of a list, e.g. the last calculation:\n```json\n{\n    \"run\": {\n        \"calculation[-1]\": \"*\"\n    }\n}\n```\n\nThese required specifications are also very useful to get workflow results.\nThis works because we can use references (e.g. workflow to final result calculation)\nand the API will resolve these references and return the respective data.\nFor example just the total energy value and reduced formula from the resulting\ncalculation:\n```json\n{\n    \"workflow\": {\n        \"calculation_result_ref\": {\n            \"energy\": \"*\",\n            \"system_ref\": {\n                \"value\": {\n                    \"chemical_composition\": \"*\"\n                }\n            }\n        }\n    }\n}\n```\n\nYou can also resolve all references in a branch with the `include-resolved`\ndirective. This will resolve all references in the branch, and also all references\nin referenced sections:\n```json\n{\n    \"workflow\":\n        \"calculation_result_ref\": \"include-resolved\"\n    }\n}\n```\n\nBy default, the targets of \"resolved\" references are added to the archive at\ntheir original hierarchy positions.\nThis means, all references are still references, but they are resolvable within\nthe returned data, since they targets are now part of the data. Another option\nis to add\n`\"resolve-inplace\": true` to the root of required. Here, the reference targets will\nreplace the references:\n```json\n{\n    \"resolve-inplace\": true,\n    \"workflow\":\n        \"calculation_result_ref\": \"include-resolved\"\n    }\n}\n```",
            "default": "*"
          },
          "entry_id": {
            "type": "string",
            "title": "Entry Id"
          },
          "data": {
            "$ref": "#/components/schemas/EntryArchive"
          }
        },
        "type": "object",
        "required": [
          "entry_id"
        ],
        "title": "EntryArchiveResponse"
      },
      "EntryEdit": {
        "properties": {
          "changes": {
            "items": {
              "$ref": "#/components/schemas/ArchiveChange"
            },
            "type": "array",
            "title": "Changes"
          }
        },
        "type": "object",
        "required": [
          "changes"
        ],
        "title": "EntryEdit"
      },
      "EntryEditResponse": {
        "properties": {
          "changes": {
            "items": {
              "$ref": "#/components/schemas/ArchiveChange"
            },
            "type": "array",
            "title": "Changes"
          },
          "entry_id": {
            "type": "string",
            "title": "Entry Id"
          }
        },
        "type": "object",
        "required": [
          "changes",
          "entry_id"
        ],
        "title": "EntryEditResponse"
      },
      "EntryMetadataEdit": {
        "properties": {
          "owner": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Owner"
              },
              {
                "type": "null"
              }
            ],
            "default": "public"
          },
          "query": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/And-Input"
              },
              {
                "$ref": "#/components/schemas/Or-Input"
              },
              {
                "$ref": "#/components/schemas/Not-Input"
              },
              {
                "$ref": "#/components/schemas/Nested-Input"
              },
              {
                "$ref": "#/components/schemas/Criteria"
              },
              {
                "$ref": "#/components/schemas/Empty"
              },
              {
                "additionalProperties": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "number"
                    },
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "string"
                    },
                    {
                      "type": "string",
                      "format": "date-time"
                    },
                    {
                      "items": {
                        "anyOf": [
                          {
                            "type": "integer"
                          },
                          {
                            "type": "number"
                          },
                          {
                            "type": "boolean"
                          },
                          {
                            "type": "string"
                          },
                          {
                            "type": "string",
                            "format": "date-time"
                          }
                        ]
                      },
                      "type": "array"
                    },
                    {
                      "$ref": "#/components/schemas/Range"
                    },
                    {
                      "$ref": "#/components/schemas/Any_"
                    },
                    {
                      "$ref": "#/components/schemas/All"
                    },
                    {
                      "$ref": "#/components/schemas/None_"
                    },
                    {
                      "type": "object"
                    }
                  ]
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Query",
            "description": "A query can be a very simple list of parameters. Different parameters or values of the same parameter are combined\nwith a logical **and**.\nThe following query would search for all entries that are VASP calculations,\ncontain *Na* **and** *Cl*, **and** are authored by *Stefano Curtarolo*\n**and** *Chris Wolverton*.\n```json\n{\n    \"results.material.elements\": [\"Na\", \"Cl\"],\n    \"results.method.simulation.program_name\": \"VASP\",\n    \"authors\": [\"Stefano Curtarolo\", \"Chris Wolverton\"]\n}\n```\n\nA short cut to change the logical combination of values in a list, is to\nadd a suffix to the quantity `:any`:\n```json\n{\n    \"results.material.elements\": [\"Na\", \"Cl\"],\n    \"results.method.simulation.program_name\": \"VASP\",\n    \"authors:any\": [\"Stefano Curtarolo\", \"Chris Wolverton\"]\n}\n```\n\nOtherwise, you can also write complex logical combinations of parameters like this:\n```json\n{\n    \"and\": [\n        {\n            \"or\": [\n                {\n                    \"results.material.elements\": [\"Cl\", \"Na\"]\n                },\n                {\n                    \"results.material.elements\": [\"H\", \"O\"]\n                }\n            ]\n        },\n        {\n            \"not\": {\n                \"results.material.symmetry.crystal_system\": \"cubic\"\n            }\n        }\n    ]\n}\n```\nOther short-cut prefixes are `none:` and `any:` (the default).\n\nBy default all quantity values have to **equal** the given values to match. For\nsome values you can also use comparison operators like this:\n```json\n{\n    \"upload_create_time\": {\n        \"gt\": \"2020-01-01\",\n        \"lt\": \"2020-08-01\"\n    },\n    \"results.properties.geometry_optimization.final_energy_difference\": {\n        \"lte\": 1.23e-18\n    }\n}\n```\n\nor shorter with suffixes:\n```json\n{\n    \"upload_create_time:gt\": \"2020-01-01\",\n    \"upload_create_time:lt\": \"2020-08-01\",\n    \"results.properties.geometry_optimization.final_energy_difference:lte\": 1.23e-18\n}\n```\n\nThe searchable quantities are a subset of the NOMAD Archive quantities defined\nin the NOMAD Metainfo. The searchable quantities also depend on the API endpoint.\n\nThere is also an additional query parameter that you can use to formulate queries based\non the optimade filter language:\n```json\n{\n    \"optimade_filter\": \"nelements >= 2 AND elements HAS ALL 'Ti', 'O'\"\n}\n```"
          },
          "verify": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Verify",
            "description": "If true, no action is performed.",
            "default": false
          },
          "actions": {
            "$ref": "#/components/schemas/EntryMetadataEditActions",
            "description": "Each action specifies a single value (even for multi valued quantities)."
          }
        },
        "type": "object",
        "title": "EntryMetadataEdit"
      },
      "EntryMetadataEditActionField": {
        "properties": {
          "value": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Value",
            "description": "The value/values that is set as a string."
          },
          "success": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Success",
            "description": "If this can/could be done. Only in API response."
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Message",
            "description": "A message that details the action result. Only in API response."
          }
        },
        "type": "object",
        "title": "EntryMetadataEditActionField"
      },
      "EntryMetadataEditActions": {
        "properties": {
          "entry_create_time": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EntryMetadataEditActionField"
              },
              {
                "type": "null"
              }
            ]
          },
          "external_db": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EntryMetadataEditActionField"
              },
              {
                "type": "null"
              }
            ]
          },
          "license": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EntryMetadataEditActionField"
              },
              {
                "type": "null"
              }
            ]
          },
          "reviewer_groups": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/EntryMetadataEditActionField"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Reviewer Groups"
          },
          "external_id": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EntryMetadataEditActionField"
              },
              {
                "type": "null"
              }
            ]
          },
          "coauthors": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/EntryMetadataEditActionField"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Coauthors"
          },
          "references": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/EntryMetadataEditActionField"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "References"
          },
          "coauthor_groups": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/EntryMetadataEditActionField"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Coauthor Groups"
          },
          "main_author": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EntryMetadataEditActionField"
              },
              {
                "type": "null"
              }
            ]
          },
          "reviewers": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/EntryMetadataEditActionField"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Reviewers"
          },
          "comment": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EntryMetadataEditActionField"
              },
              {
                "type": "null"
              }
            ]
          },
          "embargo_length": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EntryMetadataEditActionField"
              },
              {
                "type": "null"
              }
            ]
          },
          "publish_time": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EntryMetadataEditActionField"
              },
              {
                "type": "null"
              }
            ]
          },
          "datasets": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/EntryMetadataEditActionField"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Datasets"
          },
          "upload_name": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EntryMetadataEditActionField"
              },
              {
                "type": "null"
              }
            ]
          },
          "upload_create_time": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EntryMetadataEditActionField"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "title": "EntryMetadataEditActions"
      },
      "EntryMetadataEditResponse": {
        "properties": {
          "owner": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Owner"
              },
              {
                "type": "null"
              }
            ],
            "default": "public"
          },
          "query": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/And-Output"
              },
              {
                "$ref": "#/components/schemas/Or-Output"
              },
              {
                "$ref": "#/components/schemas/Not-Output"
              },
              {
                "$ref": "#/components/schemas/Nested-Output"
              },
              {
                "$ref": "#/components/schemas/Criteria"
              },
              {
                "$ref": "#/components/schemas/Empty"
              },
              {
                "additionalProperties": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "number"
                    },
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "string"
                    },
                    {
                      "type": "string",
                      "format": "date-time"
                    },
                    {
                      "items": {
                        "anyOf": [
                          {
                            "type": "integer"
                          },
                          {
                            "type": "number"
                          },
                          {
                            "type": "boolean"
                          },
                          {
                            "type": "string"
                          },
                          {
                            "type": "string",
                            "format": "date-time"
                          }
                        ]
                      },
                      "type": "array"
                    },
                    {
                      "$ref": "#/components/schemas/Range"
                    },
                    {
                      "$ref": "#/components/schemas/Any_"
                    },
                    {
                      "$ref": "#/components/schemas/All"
                    },
                    {
                      "$ref": "#/components/schemas/None_"
                    },
                    {
                      "type": "object"
                    }
                  ]
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Query",
            "description": "A query can be a very simple list of parameters. Different parameters or values of the same parameter are combined\nwith a logical **and**.\nThe following query would search for all entries that are VASP calculations,\ncontain *Na* **and** *Cl*, **and** are authored by *Stefano Curtarolo*\n**and** *Chris Wolverton*.\n```json\n{\n    \"results.material.elements\": [\"Na\", \"Cl\"],\n    \"results.method.simulation.program_name\": \"VASP\",\n    \"authors\": [\"Stefano Curtarolo\", \"Chris Wolverton\"]\n}\n```\n\nA short cut to change the logical combination of values in a list, is to\nadd a suffix to the quantity `:any`:\n```json\n{\n    \"results.material.elements\": [\"Na\", \"Cl\"],\n    \"results.method.simulation.program_name\": \"VASP\",\n    \"authors:any\": [\"Stefano Curtarolo\", \"Chris Wolverton\"]\n}\n```\n\nOtherwise, you can also write complex logical combinations of parameters like this:\n```json\n{\n    \"and\": [\n        {\n            \"or\": [\n                {\n                    \"results.material.elements\": [\"Cl\", \"Na\"]\n                },\n                {\n                    \"results.material.elements\": [\"H\", \"O\"]\n                }\n            ]\n        },\n        {\n            \"not\": {\n                \"results.material.symmetry.crystal_system\": \"cubic\"\n            }\n        }\n    ]\n}\n```\nOther short-cut prefixes are `none:` and `any:` (the default).\n\nBy default all quantity values have to **equal** the given values to match. For\nsome values you can also use comparison operators like this:\n```json\n{\n    \"upload_create_time\": {\n        \"gt\": \"2020-01-01\",\n        \"lt\": \"2020-08-01\"\n    },\n    \"results.properties.geometry_optimization.final_energy_difference\": {\n        \"lte\": 1.23e-18\n    }\n}\n```\n\nor shorter with suffixes:\n```json\n{\n    \"upload_create_time:gt\": \"2020-01-01\",\n    \"upload_create_time:lt\": \"2020-08-01\",\n    \"results.properties.geometry_optimization.final_energy_difference:lte\": 1.23e-18\n}\n```\n\nThe searchable quantities are a subset of the NOMAD Archive quantities defined\nin the NOMAD Metainfo. The searchable quantities also depend on the API endpoint.\n\nThere is also an additional query parameter that you can use to formulate queries based\non the optimade filter language:\n```json\n{\n    \"optimade_filter\": \"nelements >= 2 AND elements HAS ALL 'Ti', 'O'\"\n}\n```"
          },
          "verify": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Verify",
            "description": "If true, no action is performed.",
            "default": false
          },
          "actions": {
            "$ref": "#/components/schemas/EntryMetadataEditActions",
            "description": "Each action specifies a single value (even for multi valued quantities)."
          },
          "success": {
            "type": "boolean",
            "title": "Success",
            "description": "If the overall edit can/could be done. Only in API response."
          },
          "message": {
            "type": "string",
            "title": "Message",
            "description": "A message that details the overall edit result. Only in API response."
          }
        },
        "type": "object",
        "title": "EntryMetadataEditResponse"
      },
      "EntryMetadataResponse": {
        "properties": {
          "entry_id": {
            "type": "string",
            "title": "Entry Id"
          },
          "required": {
            "$ref": "#/components/schemas/MetadataRequired"
          },
          "data": {
            "title": "Data",
            "description": "The entry metadata as dictionary."
          }
        },
        "type": "object",
        "title": "EntryMetadataResponse"
      },
      "EntryProcData": {
        "properties": {
          "process_running": {
            "type": "boolean",
            "title": "Process Running",
            "description": "If a process is running"
          },
          "current_process": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Current Process",
            "description": "Name of the current or last completed process"
          },
          "process_status": {
            "type": "string",
            "title": "Process Status",
            "description": "The status of the current or last completed process",
            "default": "READY"
          },
          "last_status_message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Status Message",
            "description": "A short, human readable message from the current process, with information about what the current process is doing, or information about the completion (successful or not) of the last process, if no process is currently running."
          },
          "errors": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Errors",
            "description": "A list of error messages that occurred during the last processing"
          },
          "warnings": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Warnings",
            "description": "A list of warning messages that occurred during the last processing"
          },
          "complete_time": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Complete Time",
            "description": "Date and time of the completion of the last process"
          },
          "entry_id": {
            "type": "string",
            "title": "Entry Id"
          },
          "entry_create_time": {
            "type": "string",
            "format": "date-time",
            "title": "Entry Create Time"
          },
          "mainfile": {
            "type": "string",
            "title": "Mainfile"
          },
          "mainfile_key": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Mainfile Key"
          },
          "upload_id": {
            "type": "string",
            "title": "Upload Id"
          },
          "parser_name": {
            "type": "string",
            "title": "Parser Name"
          },
          "entry_metadata": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Entry Metadata"
          }
        },
        "type": "object",
        "required": [
          "process_running",
          "errors",
          "warnings",
          "entry_id",
          "entry_create_time",
          "mainfile",
          "upload_id",
          "parser_name"
        ],
        "title": "EntryProcData"
      },
      "EntryProcDataPagination": {
        "properties": {
          "page_size": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page Size",
            "description": "The page size, e.g. the maximum number of items contained in one response.\nA `page_size` of 0 will return no results.",
            "default": 10
          },
          "order_by": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Order By",
            "description": "The results are ordered by the values of this field. If omitted, default\nordering is applied."
          },
          "order": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Direction"
              },
              {
                "type": "null"
              }
            ],
            "description": "The ordering direction of the results based on `order_by`. Its either\nascending `asc` or descending `desc`. Default is `asc`.",
            "default": "asc"
          },
          "page_after_value": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page After Value",
            "description": "This attribute defines the position after which the page begins, and is used\nto navigate through the total list of results.\n\nWhen requesting the first page, no value should be provided for\n`page_after_value`. Each response will contain a value `next_page_after_value`,\nwhich can be used to obtain the next page (by setting `page_after_value` in\nyour next request to this value).\n\nThe field is encoded as a string, and the format of `page_after_value` and\n`next_page_after_value` depends on which API method is used.\n\nSome API functions additionally allows a simplified navigation, by specifying\nthe page number in the key `page`. It is however always possible to use\n`page_after_value` and `next_page_after_value` to iterate through the results."
          },
          "page": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page",
            "description": "The number of the page (1-based). When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used."
          },
          "page_offset": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page Offset",
            "description": "The number of skipped entries. When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page_offset` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used."
          }
        },
        "type": "object",
        "title": "EntryProcDataPagination"
      },
      "EntryProcDataQueryResponse": {
        "properties": {
          "pagination": {
            "$ref": "#/components/schemas/PaginationResponse"
          },
          "processing_successful": {
            "type": "integer",
            "title": "Processing Successful",
            "description": "Number of entries that has been processed successfully."
          },
          "processing_failed": {
            "type": "integer",
            "title": "Processing Failed",
            "description": "Number of entries that failed to process."
          },
          "upload": {
            "$ref": "#/components/schemas/UploadProcData",
            "description": "The upload processing data of the upload."
          },
          "data": {
            "items": {
              "$ref": "#/components/schemas/EntryProcData"
            },
            "type": "array",
            "title": "Data",
            "description": "The entries data as a list. Each item is a dictionary with the data for one entry."
          }
        },
        "type": "object",
        "required": [
          "pagination"
        ],
        "title": "EntryProcDataQueryResponse"
      },
      "EntryProcDataResponse": {
        "properties": {
          "entry_id": {
            "type": "string",
            "title": "Entry Id"
          },
          "data": {
            "$ref": "#/components/schemas/EntryProcData"
          }
        },
        "type": "object",
        "required": [
          "entry_id",
          "data"
        ],
        "title": "EntryProcDataResponse"
      },
      "EntryQuery": {
        "properties": {
          "mainfile": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Mainfile",
            "description": "\n    Provide a list of regex patterns to match the mainfile. Case sensitive.\n    "
          },
          "parser_name": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Parser Name",
            "description": "\n    Provide a list of regex patterns to match the parser names. Case sensitive.\n    "
          },
          "references": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "References",
            "description": "\n    Provide a list of regex patterns to match the references. Case sensitive.\n    "
          }
        },
        "type": "object",
        "title": "EntryQuery"
      },
      "EntryRawDir": {
        "properties": {
          "entry_id": {
            "type": "string",
            "title": "Entry Id"
          },
          "upload_id": {
            "type": "string",
            "title": "Upload Id"
          },
          "mainfile": {
            "type": "string",
            "title": "Mainfile"
          },
          "mainfile_key": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Mainfile Key"
          },
          "files": {
            "items": {
              "$ref": "#/components/schemas/EntryRawDirFile"
            },
            "type": "array",
            "title": "Files"
          }
        },
        "type": "object",
        "title": "EntryRawDir"
      },
      "EntryRawDirFile": {
        "properties": {
          "path": {
            "type": "string",
            "title": "Path"
          },
          "size": {
            "type": "integer",
            "title": "Size"
          }
        },
        "type": "object",
        "title": "EntryRawDirFile"
      },
      "EntryRawDirResponse": {
        "properties": {
          "entry_id": {
            "type": "string",
            "title": "Entry Id"
          },
          "data": {
            "$ref": "#/components/schemas/EntryRawDir"
          }
        },
        "type": "object",
        "required": [
          "entry_id",
          "data"
        ],
        "title": "EntryRawDirResponse"
      },
      "Error": {
        "properties": {
          "error_type": {
            "type": "string",
            "title": "Error Type"
          },
          "message": {
            "type": "string",
            "title": "Message"
          }
        },
        "type": "object",
        "required": [
          "error_type",
          "message"
        ],
        "title": "Error"
      },
      "Files": {
        "properties": {
          "compress": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Compress",
            "description": "By default the returned zip file is not compressed. This allows to enable compression.\nCompression will reduce the rate at which data is provided, often below\nthe rate of the compression. Therefore, compression is only sensible if the\nnetwork connection is limited.",
            "default": false
          },
          "glob_pattern": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Glob Pattern",
            "description": "An optional *glob* (or unix style path) pattern that is used to filter the\nreturned files. Only files matching the pattern are returned. The pattern is only\napplied to the end of the full path. Internally\n[fnmatch](https://docs.python.org/3/library/fnmatch.html) is used."
          },
          "re_pattern": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Re Pattern",
            "description": "An optional regexp that is used to filter the returned files. Only files matching\nthe pattern are returned. The pattern is applied in search mode to the full\npath of the files. With `$` and `^` you can control if you want to match the\nwhole path.\n\nA re pattern will replace a given glob pattern."
          },
          "include_files": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Include Files",
            "description": "Optional list of file names. Only files with these names are included in the\nresults. This will overwrite any given glob or re pattern."
          }
        },
        "type": "object",
        "title": "Files",
        "description": "Configures the download of files."
      },
      "FormatEnum": {
        "type": "string",
        "enum": [
          "cif",
          "xyz",
          "pdb"
        ],
        "title": "FormatEnum"
      },
      "GraphDatasetRequest": {
        "properties": {
          "dataset_id": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Dataset Id"
          },
          "dataset_name": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Dataset Name"
          },
          "user_id": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "User Id"
          },
          "doi": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Doi"
          },
          "pid": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Pid"
          },
          "dataset_create_time": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Dataset Create Time"
          },
          "dataset_modified_time": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Dataset Modified Time"
          },
          "dataset_type": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Dataset Type"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "GraphDatasetRequest"
      },
      "GraphDatasetResponse": {
        "properties": {
          "dataset_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Dataset Id"
          },
          "dataset_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Dataset Name"
          },
          "user_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "User Id"
          },
          "doi": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Doi"
          },
          "pid": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Pid"
          },
          "dataset_create_time": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Dataset Create Time"
          },
          "dataset_modified_time": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Dataset Modified Time"
          },
          "dataset_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Dataset Type"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "GraphDatasetResponse"
      },
      "GraphDatasetsRequest": {
        "properties": {
          "m_request": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DatasetRequestOptions"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": {
          "anyOf": [
            {
              "$ref": "#/$defs/nomad__app__v1__models__graph__graph_models__GraphDatasetRequest-Input__1"
            },
            {
              "type": "string",
              "enum": [
                "*"
              ]
            },
            {
              "$ref": "#/components/schemas/DatasetRequestOptions"
            }
          ]
        },
        "type": "object",
        "title": "GraphDatasetsRequest"
      },
      "GraphDatasetsResponse": {
        "properties": {
          "m_response": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DatasetResponseOptions"
              },
              {
                "type": "null"
              }
            ]
          },
          "m_errors": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/Error"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "M Errors"
          }
        },
        "additionalProperties": {
          "anyOf": [
            {
              "$ref": "#/$defs/nomad__app__v1__models__graph__graph_models__GraphDatasetResponse-Input__1"
            },
            {
              "type": "string",
              "enum": [
                "*"
              ]
            },
            {
              "$ref": "#/components/schemas/DatasetResponseOptions"
            }
          ]
        },
        "type": "object",
        "title": "GraphDatasetsResponse"
      },
      "GraphDirectoryRequest": {
        "properties": {
          "m_is": {
            "anyOf": [
              {
                "type": "string",
                "const": "Directory"
              },
              {
                "type": "null"
              }
            ],
            "title": "M Is"
          },
          "m_request": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/RequestConfig"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": {
          "anyOf": [
            {
              "$ref": "#/$defs/nomad__app__v1__models__graph__graph_models__GraphDirectoryRequest-Input__1"
            },
            {
              "$ref": "#/$defs/nomad__app__v1__models__graph__graph_models__GraphFileRequest-Input__1"
            },
            {
              "type": "string",
              "enum": [
                "*"
              ]
            },
            {
              "$ref": "#/components/schemas/RequestConfig"
            }
          ]
        },
        "type": "object",
        "title": "GraphDirectoryRequest"
      },
      "GraphDirectoryResponse": {
        "properties": {
          "m_errors": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/Error"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "M Errors"
          },
          "m_is": {
            "anyOf": [
              {
                "type": "string",
                "const": "Directory"
              },
              {
                "type": "null"
              }
            ],
            "title": "M Is"
          },
          "m_response": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DirectoryResponseOptions"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": {
          "anyOf": [
            {
              "$ref": "#/$defs/nomad__app__v1__models__graph__graph_models__GraphDirectoryResponse-Input__1"
            },
            {
              "$ref": "#/$defs/nomad__app__v1__models__graph__graph_models__GraphFileResponse-Input__1"
            },
            {
              "type": "string",
              "enum": [
                "*"
              ]
            },
            {
              "$ref": "#/components/schemas/DirectoryResponseOptions"
            }
          ]
        },
        "type": "object",
        "title": "GraphDirectoryResponse"
      },
      "GraphEntriesRequest": {
        "properties": {
          "m_request": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EntriesRequestOptions"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": {
          "anyOf": [
            {
              "$ref": "#/$defs/nomad__app__v1__models__graph__graph_models__GraphEntryRequest-Input__1"
            },
            {
              "type": "string",
              "enum": [
                "*"
              ]
            },
            {
              "$ref": "#/components/schemas/EntriesRequestOptions"
            }
          ]
        },
        "type": "object",
        "title": "GraphEntriesRequest"
      },
      "GraphEntriesResponse": {
        "properties": {
          "m_response": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EntriesResponseOptions"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": {
          "anyOf": [
            {
              "$ref": "#/$defs/nomad__app__v1__models__graph__graph_models__GraphEntryResponse-Input__1"
            },
            {
              "type": "string",
              "enum": [
                "*"
              ]
            },
            {
              "$ref": "#/components/schemas/EntriesResponseOptions"
            }
          ]
        },
        "type": "object",
        "title": "GraphEntriesResponse"
      },
      "GraphEntryMetadataRequest": {
        "properties": {
          "entry": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphEntryRequest"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": true,
        "type": "object",
        "title": "GraphEntryMetadataRequest"
      },
      "GraphEntryMetadataResponse": {
        "properties": {
          "entry": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphEntryResponse"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": true,
        "type": "object",
        "title": "GraphEntryMetadataResponse"
      },
      "GraphEntryRequest": {
        "properties": {
          "process_running": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Process Running"
          },
          "current_process": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Current Process"
          },
          "process_status": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Process Status"
          },
          "last_status_message": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Status Message"
          },
          "errors": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Errors"
          },
          "warnings": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Warnings"
          },
          "complete_time": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Complete Time"
          },
          "entry_id": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Entry Id"
          },
          "entry_create_time": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Entry Create Time"
          },
          "mainfile_path": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Mainfile Path"
          },
          "mainfile_key": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Mainfile Key"
          },
          "upload_id": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Upload Id"
          },
          "parser_name": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Parser Name"
          },
          "mainfile": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphFileRequest"
              },
              {
                "type": "null"
              }
            ]
          },
          "upload": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphUploadRequest"
              },
              {
                "type": "null"
              }
            ]
          },
          "archive": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MSectionRequest"
              },
              {
                "type": "null"
              }
            ]
          },
          "metadata": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphEntryMetadataRequest"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "GraphEntryRequest"
      },
      "GraphEntryResponse": {
        "properties": {
          "process_running": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Process Running"
          },
          "current_process": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Current Process"
          },
          "process_status": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Process Status"
          },
          "last_status_message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Status Message"
          },
          "errors": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Errors"
          },
          "warnings": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Warnings"
          },
          "complete_time": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Complete Time"
          },
          "entry_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Entry Id"
          },
          "entry_create_time": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Entry Create Time"
          },
          "mainfile_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Mainfile Path"
          },
          "mainfile_key": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Mainfile Key"
          },
          "upload_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Upload Id"
          },
          "parser_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Parser Name"
          },
          "m_errors": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/Error"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "M Errors"
          },
          "mainfile": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphFileResponse"
              },
              {
                "type": "null"
              }
            ]
          },
          "upload": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphUploadResponse"
              },
              {
                "type": "null"
              }
            ]
          },
          "archive": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MSectionResponse"
              },
              {
                "type": "null"
              }
            ]
          },
          "metadata": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphEntryMetadataResponse"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "GraphEntryResponse"
      },
      "GraphFileRequest": {
        "properties": {
          "m_is": {
            "anyOf": [
              {
                "type": "string",
                "const": "File"
              },
              {
                "type": "null"
              }
            ],
            "title": "M Is"
          },
          "m_request": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/RequestConfig"
              },
              {
                "type": "null"
              }
            ]
          },
          "path": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Path"
          },
          "size": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Size"
          },
          "entry": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphEntryRequest"
              },
              {
                "type": "null"
              }
            ]
          },
          "parent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphDirectoryRequest"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "GraphFileRequest"
      },
      "GraphFileResponse": {
        "properties": {
          "m_errors": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/Error"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "M Errors"
          },
          "m_is": {
            "anyOf": [
              {
                "type": "string",
                "const": "File"
              },
              {
                "type": "null"
              }
            ],
            "title": "M Is"
          },
          "path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Path"
          },
          "size": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Size"
          },
          "entry": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphEntryResponse"
              },
              {
                "type": "null"
              }
            ]
          },
          "parent": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphDirectoryResponse"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "GraphFileResponse"
      },
      "GraphGroupRequest": {
        "properties": {
          "group_id": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Group Id"
          },
          "group_name": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Group Name"
          },
          "owner": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphUserRequest"
              },
              {
                "type": "null"
              }
            ]
          },
          "members": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Members"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "GraphGroupRequest"
      },
      "GraphGroupResponse": {
        "properties": {
          "group_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Group Id"
          },
          "group_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Group Name"
          },
          "owner": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphUserResponse"
              },
              {
                "type": "null"
              }
            ]
          },
          "members": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/GraphUserResponse"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Members"
          },
          "m_errors": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/Error"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "M Errors"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "GraphGroupResponse"
      },
      "GraphGroupsRequest": {
        "properties": {
          "m_request": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GroupRequestOptions"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": {
          "anyOf": [
            {
              "$ref": "#/$defs/nomad__app__v1__models__graph__graph_models__GraphGroupRequest-Input__1"
            },
            {
              "type": "string",
              "enum": [
                "*"
              ]
            },
            {
              "$ref": "#/components/schemas/GroupRequestOptions"
            }
          ]
        },
        "type": "object",
        "title": "GraphGroupsRequest"
      },
      "GraphGroupsResponse": {
        "properties": {
          "m_errors": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/Error"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "M Errors"
          },
          "m_response": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GroupResponseOptions"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": {
          "anyOf": [
            {
              "$ref": "#/$defs/nomad__app__v1__models__graph__graph_models__GraphGroupResponse-Input__1"
            },
            {
              "type": "string",
              "enum": [
                "*"
              ]
            },
            {
              "$ref": "#/components/schemas/GroupResponseOptions"
            }
          ]
        },
        "type": "object",
        "title": "GraphGroupsResponse"
      },
      "GraphMetainfoRequest": {
        "properties": {
          "m_request": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MetainfoRequestOptions"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": {
          "anyOf": [
            {
              "$ref": "#/$defs/nomad__app__v1__models__graph__graph_models__MSectionRequest-Input__1"
            },
            {
              "type": "string",
              "enum": [
                "*"
              ]
            },
            {
              "$ref": "#/components/schemas/MetainfoRequestOptions"
            }
          ]
        },
        "type": "object",
        "title": "GraphMetainfoRequest"
      },
      "GraphMetainfoResponse": {
        "properties": {
          "m_response": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MetainfoResponseOptions"
              },
              {
                "type": "null"
              }
            ]
          },
          "m_errors": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/Error"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "M Errors"
          }
        },
        "additionalProperties": {
          "anyOf": [
            {
              "$ref": "#/$defs/nomad__app__v1__models__graph__graph_models__MSectionResponse-Input__1"
            },
            {
              "type": "string",
              "enum": [
                "*"
              ]
            },
            {
              "$ref": "#/components/schemas/MetainfoResponseOptions"
            }
          ]
        },
        "type": "object",
        "title": "GraphMetainfoResponse"
      },
      "GraphRequest": {
        "properties": {
          "users": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphUsersRequest"
              },
              {
                "type": "null"
              }
            ]
          },
          "entries": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphEntriesRequest"
              },
              {
                "type": "null"
              }
            ]
          },
          "uploads": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphUploadsRequest"
              },
              {
                "type": "null"
              }
            ]
          },
          "datasets": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphDatasetsRequest"
              },
              {
                "type": "null"
              }
            ]
          },
          "search": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphSearchRequest"
              },
              {
                "type": "null"
              }
            ]
          },
          "metainfo": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphMetainfoRequest"
              },
              {
                "type": "null"
              }
            ]
          },
          "groups": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphGroupsRequest"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "GraphRequest"
      },
      "GraphResponse": {
        "properties": {
          "users": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphUsersResponse"
              },
              {
                "type": "null"
              }
            ]
          },
          "entries": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphEntriesResponse"
              },
              {
                "type": "null"
              }
            ]
          },
          "uploads": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphUploadsResponse"
              },
              {
                "type": "null"
              }
            ]
          },
          "datasets": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphDatasetsResponse"
              },
              {
                "type": "null"
              }
            ]
          },
          "search": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphSearchResponse"
              },
              {
                "type": "null"
              }
            ]
          },
          "metainfo": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphMetainfoResponse"
              },
              {
                "type": "null"
              }
            ]
          },
          "groups": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphGroupsResponse"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "GraphResponse"
      },
      "GraphSearchRequest": {
        "properties": {
          "m_request": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SearchRequestOptions"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": {
          "anyOf": [
            {
              "$ref": "#/$defs/nomad__app__v1__models__graph__graph_models__GraphEntryMetadataRequest-Input__1"
            },
            {
              "type": "string",
              "enum": [
                "*"
              ]
            },
            {
              "$ref": "#/components/schemas/SearchRequestOptions"
            }
          ]
        },
        "type": "object",
        "title": "GraphSearchRequest"
      },
      "GraphSearchResponse": {
        "properties": {
          "m_response": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SearchResponseOptions"
              },
              {
                "type": "null"
              }
            ]
          },
          "m_errors": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/Error"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "M Errors"
          }
        },
        "additionalProperties": {
          "anyOf": [
            {
              "$ref": "#/$defs/nomad__app__v1__models__graph__graph_models__GraphEntryMetadataResponse-Input__1"
            },
            {
              "type": "string",
              "enum": [
                "*"
              ]
            },
            {
              "$ref": "#/components/schemas/SearchResponseOptions"
            }
          ]
        },
        "type": "object",
        "title": "GraphSearchResponse"
      },
      "GraphUploadRequest": {
        "properties": {
          "process_running": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Process Running"
          },
          "current_process": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Current Process"
          },
          "process_status": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Process Status"
          },
          "last_status_message": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Status Message"
          },
          "errors": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Errors"
          },
          "warnings": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Warnings"
          },
          "complete_time": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Complete Time"
          },
          "upload_id": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Upload Id"
          },
          "upload_name": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Upload Name"
          },
          "upload_create_time": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Upload Create Time"
          },
          "main_author": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphUserRequest"
              },
              {
                "type": "null"
              }
            ]
          },
          "coauthors": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Coauthors"
          },
          "coauthor_groups": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Coauthor Groups"
          },
          "reviewers": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Reviewers"
          },
          "reviewer_groups": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Reviewer Groups"
          },
          "writers": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Writers"
          },
          "writer_groups": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Writer Groups"
          },
          "viewers": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Viewers"
          },
          "viewer_groups": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Viewer Groups"
          },
          "published": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Published"
          },
          "published_to": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Published To"
          },
          "publish_time": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Publish Time"
          },
          "with_embargo": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "With Embargo"
          },
          "embargo_length": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Embargo Length"
          },
          "license": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "License"
          },
          "n_entries": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "N Entries"
          },
          "upload_files_server_path": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Upload Files Server Path"
          },
          "processing_successful": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Processing Successful"
          },
          "processing_failed": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Processing Failed"
          },
          "entries": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphEntriesRequest"
              },
              {
                "type": "null"
              }
            ]
          },
          "files": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphDirectoryRequest"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "GraphUploadRequest"
      },
      "GraphUploadResponse": {
        "properties": {
          "process_running": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Process Running"
          },
          "current_process": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Current Process"
          },
          "process_status": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Process Status"
          },
          "last_status_message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Status Message"
          },
          "errors": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Errors"
          },
          "warnings": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Warnings"
          },
          "complete_time": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Complete Time"
          },
          "upload_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Upload Id"
          },
          "upload_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Upload Name"
          },
          "upload_create_time": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Upload Create Time"
          },
          "main_author": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphUserResponse"
              },
              {
                "type": "null"
              }
            ]
          },
          "coauthors": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/GraphUserResponse"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Coauthors"
          },
          "coauthor_groups": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Coauthor Groups"
          },
          "reviewers": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/GraphUserResponse"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Reviewers"
          },
          "reviewer_groups": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Reviewer Groups"
          },
          "writers": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/GraphUserResponse"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Writers"
          },
          "writer_groups": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Writer Groups"
          },
          "viewers": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/GraphUserResponse"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Viewers"
          },
          "viewer_groups": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Viewer Groups"
          },
          "published": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Published"
          },
          "published_to": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Published To"
          },
          "publish_time": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Publish Time"
          },
          "with_embargo": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "With Embargo"
          },
          "embargo_length": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Embargo Length"
          },
          "license": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "License"
          },
          "n_entries": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "N Entries"
          },
          "upload_files_server_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Upload Files Server Path"
          },
          "processing_successful": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Processing Successful"
          },
          "processing_failed": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Processing Failed"
          },
          "entries": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphEntriesResponse"
              },
              {
                "type": "null"
              }
            ]
          },
          "files": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphDirectoryResponse"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "GraphUploadResponse"
      },
      "GraphUploadsRequest": {
        "properties": {
          "m_request": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UploadRequestOptions"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": {
          "anyOf": [
            {
              "$ref": "#/$defs/nomad__app__v1__models__graph__graph_models__GraphUploadRequest-Input__1"
            },
            {
              "type": "string",
              "enum": [
                "*"
              ]
            },
            {
              "$ref": "#/components/schemas/UploadRequestOptions"
            }
          ]
        },
        "type": "object",
        "title": "GraphUploadsRequest"
      },
      "GraphUploadsResponse": {
        "properties": {
          "m_response": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UploadResponseOptions"
              },
              {
                "type": "null"
              }
            ]
          },
          "m_errors": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/Error"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "M Errors"
          }
        },
        "additionalProperties": {
          "anyOf": [
            {
              "$ref": "#/$defs/nomad__app__v1__models__graph__graph_models__GraphUploadResponse-Input__1"
            },
            {
              "type": "string",
              "enum": [
                "*"
              ]
            },
            {
              "$ref": "#/components/schemas/UploadResponseOptions"
            }
          ]
        },
        "type": "object",
        "title": "GraphUploadsResponse"
      },
      "GraphUserRequest": {
        "properties": {
          "name": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Name"
          },
          "first_name": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "First Name"
          },
          "last_name": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Name"
          },
          "email": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Email"
          },
          "affiliation": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Affiliation"
          },
          "affiliation_address": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Affiliation Address"
          },
          "user_id": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "User Id"
          },
          "username": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Username"
          },
          "created": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Created"
          },
          "repo_user_id": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Repo User Id"
          },
          "is_admin": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Admin"
          },
          "is_oasis_admin": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Oasis Admin"
          },
          "uploads": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphUploadsRequest"
              },
              {
                "type": "null"
              }
            ]
          },
          "datasets": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphDatasetsRequest"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "GraphUserRequest"
      },
      "GraphUserResponse": {
        "properties": {
          "name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Name"
          },
          "first_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "First Name"
          },
          "last_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Name"
          },
          "email": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Email"
          },
          "affiliation": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Affiliation"
          },
          "affiliation_address": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Affiliation Address"
          },
          "user_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "User Id"
          },
          "username": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Username"
          },
          "created": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Created"
          },
          "repo_user_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Repo User Id"
          },
          "is_admin": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Admin"
          },
          "is_oasis_admin": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Oasis Admin"
          },
          "uploads": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphUploadsResponse"
              },
              {
                "type": "null"
              }
            ]
          },
          "datasets": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GraphDatasetsResponse"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "GraphUserResponse"
      },
      "GraphUsersRequest": {
        "properties": {},
        "additionalProperties": {
          "anyOf": [
            {
              "$ref": "#/$defs/nomad__app__v1__models__graph__graph_models__GraphUserRequest-Input__1"
            },
            {
              "type": "string",
              "enum": [
                "*"
              ]
            }
          ]
        },
        "type": "object",
        "title": "GraphUsersRequest"
      },
      "GraphUsersResponse": {
        "properties": {
          "m_errors": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/Error"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "M Errors"
          }
        },
        "additionalProperties": {
          "anyOf": [
            {
              "$ref": "#/$defs/nomad__app__v1__models__graph__graph_models__GraphUserResponse-Input__1"
            },
            {
              "type": "string",
              "enum": [
                "*"
              ]
            }
          ]
        },
        "type": "object",
        "title": "GraphUsersResponse"
      },
      "GroupRequestOptions": {
        "properties": {
          "pagination": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UserGroupPagination"
              },
              {
                "type": "null"
              }
            ]
          },
          "query": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UserGroupQuery"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "pagination",
          "query"
        ],
        "title": "GroupRequestOptions"
      },
      "GroupResponseOptions": {
        "properties": {
          "pagination": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PaginationResponse"
              },
              {
                "type": "null"
              }
            ]
          },
          "query": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UserGroupQuery"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "pagination",
          "query"
        ],
        "title": "GroupResponseOptions"
      },
      "HTTPExceptionModel": {
        "properties": {
          "detail": {
            "type": "string",
            "title": "Detail"
          }
        },
        "type": "object",
        "required": [
          "detail"
        ],
        "title": "HTTPExceptionModel"
      },
      "HTTPValidationError": {
        "properties": {
          "detail": {
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "type": "array",
            "title": "Detail"
          }
        },
        "type": "object",
        "title": "HTTPValidationError"
      },
      "HistogramAggregation": {
        "properties": {
          "quantity": {
            "type": "string",
            "title": "Quantity",
            "description": "The mandatory name of the quantity for the aggregation. Aggregations\ncan only be computed for those search metadata that have discrete values;\nan aggregation buckets entries that have the same value for this quantity."
          },
          "exclude_from_search": {
            "type": "boolean",
            "title": "Exclude From Search",
            "description": "If set to true, top-level search criteria involving the aggregation quantity, will not\nbe applied for this aggregation. Therefore, the aggregation will return all\nvalues for the quantity, even if the possible values where filtered by the query.\n\nThere are two limitations. This is only supported with queries that start with a\ndictionary. It will not work for queries with a boolean operator. It can only\nexclude top-level criteria at the root of the query dictionary. Nested criteria,\ne.g. within complex and/or constructs, cannot be considered. Using this might also\nprohibit pagination with page_after_value on aggregations in the same request.",
            "default": false
          },
          "metrics": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metrics",
            "description": "By default the returned aggregations will provide the number of entries for each\nvalue. You can add more metrics. For each metric an additional number will be\nprovided for each value. Metrics are also based on search metadata. Depending on\nthe metric the number will represent either a sum (`calculations` for the number\nof individual calculation in each code run) or an amount of different values\n(i.e. `materials` for the amount of different material hashes).",
            "default": []
          },
          "interval": {
            "anyOf": [
              {
                "type": "number",
                "exclusiveMinimum": 0
              },
              {
                "type": "null"
              }
            ],
            "title": "Interval",
            "description": "The histogram bucketing interval. Provide either this or the number\nof buckets."
          },
          "buckets": {
            "anyOf": [
              {
                "type": "integer",
                "exclusiveMinimum": 0
              },
              {
                "type": "null"
              }
            ],
            "title": "Buckets",
            "description": "The number of buckets to use. Provide either this or the interval.\nThe interval for the bucketing is automatically chosen to achieve\nthe target number of buckets. Notice that for integer data types\n(int, long, date), the returned number of buckets may be smaller\nthan the requested amount if the histogram range is smaller than\nthe number of buckets. This setting will override the interval."
          },
          "offset": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Offset"
          },
          "extended_bounds": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Bounds"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "quantity"
        ],
        "title": "HistogramAggregation"
      },
      "HistogramAggregationResponse": {
        "properties": {
          "quantity": {
            "type": "string",
            "title": "Quantity",
            "description": "The mandatory name of the quantity for the aggregation. Aggregations\ncan only be computed for those search metadata that have discrete values;\nan aggregation buckets entries that have the same value for this quantity."
          },
          "exclude_from_search": {
            "type": "boolean",
            "title": "Exclude From Search",
            "description": "If set to true, top-level search criteria involving the aggregation quantity, will not\nbe applied for this aggregation. Therefore, the aggregation will return all\nvalues for the quantity, even if the possible values where filtered by the query.\n\nThere are two limitations. This is only supported with queries that start with a\ndictionary. It will not work for queries with a boolean operator. It can only\nexclude top-level criteria at the root of the query dictionary. Nested criteria,\ne.g. within complex and/or constructs, cannot be considered. Using this might also\nprohibit pagination with page_after_value on aggregations in the same request.",
            "default": false
          },
          "metrics": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metrics",
            "description": "By default the returned aggregations will provide the number of entries for each\nvalue. You can add more metrics. For each metric an additional number will be\nprovided for each value. Metrics are also based on search metadata. Depending on\nthe metric the number will represent either a sum (`calculations` for the number\nof individual calculation in each code run) or an amount of different values\n(i.e. `materials` for the amount of different material hashes).",
            "default": []
          },
          "interval": {
            "anyOf": [
              {
                "type": "number",
                "exclusiveMinimum": 0
              },
              {
                "type": "null"
              }
            ],
            "title": "Interval",
            "description": "The histogram bucketing interval. Provide either this or the number\nof buckets."
          },
          "buckets": {
            "anyOf": [
              {
                "type": "integer",
                "exclusiveMinimum": 0
              },
              {
                "type": "null"
              }
            ],
            "title": "Buckets",
            "description": "The number of buckets to use. Provide either this or the interval.\nThe interval for the bucketing is automatically chosen to achieve\nthe target number of buckets. Notice that for integer data types\n(int, long, date), the returned number of buckets may be smaller\nthan the requested amount if the histogram range is smaller than\nthe number of buckets. This setting will override the interval."
          },
          "offset": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Offset"
          },
          "extended_bounds": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Bounds"
              },
              {
                "type": "null"
              }
            ]
          },
          "data": {
            "items": {
              "$ref": "#/components/schemas/Bucket"
            },
            "type": "array",
            "title": "Data",
            "description": "The aggregation data as a list."
          }
        },
        "type": "object",
        "required": [
          "quantity"
        ],
        "title": "HistogramAggregationResponse"
      },
      "InfoModel": {
        "properties": {
          "parsers": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Parsers"
          },
          "metainfo_packages": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Metainfo Packages"
          },
          "codes": {
            "items": {
              "$ref": "#/components/schemas/CodeInfoModel"
            },
            "type": "array",
            "title": "Codes"
          },
          "normalizers": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Normalizers"
          },
          "plugin_entry_points": {
            "items": {
              "type": "object"
            },
            "type": "array",
            "title": "Plugin Entry Points",
            "description": "List of plugin entry points that are activated in this deployment."
          },
          "plugin_packages": {
            "items": {
              "type": "object"
            },
            "type": "array",
            "title": "Plugin Packages",
            "description": "List of plugin packages that are installed in this deployment."
          },
          "statistics": {
            "$ref": "#/components/schemas/StatisticsModel",
            "description": "General NOMAD statistics"
          },
          "search_quantities": {
            "type": "object",
            "title": "Search Quantities"
          },
          "version": {
            "type": "string",
            "title": "Version"
          },
          "deployment": {
            "type": "string",
            "title": "Deployment"
          },
          "oasis": {
            "type": "boolean",
            "title": "Oasis"
          },
          "git": {
            "type": "object",
            "title": "Git",
            "description": "A deprecated field that always contains an empty value to retain some compatibility\nwith older GUIs."
          }
        },
        "type": "object",
        "required": [
          "parsers",
          "metainfo_packages",
          "codes",
          "normalizers",
          "search_quantities",
          "version",
          "deployment",
          "oasis"
        ],
        "title": "InfoModel"
      },
      "MDefRequest": {
        "properties": {
          "m_request": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/RequestConfig"
              },
              {
                "type": "null"
              }
            ]
          },
          "m_def": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "M Def"
          },
          "m_def_id": {
            "anyOf": [
              {
                "type": "string",
                "const": "*"
              },
              {
                "type": "null"
              }
            ],
            "title": "M Def Id"
          }
        },
        "additionalProperties": true,
        "type": "object",
        "title": "MDefRequest"
      },
      "MDefResponse": {
        "properties": {
          "m_errors": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/Error"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "M Errors"
          },
          "m_def": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "M Def"
          },
          "m_def_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "M Def Id"
          }
        },
        "additionalProperties": true,
        "type": "object",
        "title": "MDefResponse"
      },
      "MSectionRequest": {
        "properties": {
          "m_request": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/RequestConfig"
              },
              {
                "type": "null"
              }
            ]
          },
          "m_def": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MDefRequest"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": true,
        "type": "object",
        "title": "MSectionRequest"
      },
      "MSectionResponse": {
        "properties": {
          "m_errors": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/Error"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "M Errors"
          },
          "m_def": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MDefResponse"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": true,
        "type": "object",
        "title": "MSectionResponse"
      },
      "MaterialMetadataResponse": {
        "properties": {
          "material_id": {
            "type": "string",
            "title": "Material Id"
          },
          "required": {
            "$ref": "#/components/schemas/MetadataRequired"
          },
          "data": {
            "title": "Data",
            "description": "The material metadata as dictionary."
          }
        },
        "type": "object",
        "title": "MaterialMetadataResponse"
      },
      "Metadata": {
        "properties": {
          "owner": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Owner"
              },
              {
                "type": "null"
              }
            ],
            "default": "public"
          },
          "query": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/And-Input"
              },
              {
                "$ref": "#/components/schemas/Or-Input"
              },
              {
                "$ref": "#/components/schemas/Not-Input"
              },
              {
                "$ref": "#/components/schemas/Nested-Input"
              },
              {
                "$ref": "#/components/schemas/Criteria"
              },
              {
                "$ref": "#/components/schemas/Empty"
              },
              {
                "additionalProperties": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "number"
                    },
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "string"
                    },
                    {
                      "type": "string",
                      "format": "date-time"
                    },
                    {
                      "items": {
                        "anyOf": [
                          {
                            "type": "integer"
                          },
                          {
                            "type": "number"
                          },
                          {
                            "type": "boolean"
                          },
                          {
                            "type": "string"
                          },
                          {
                            "type": "string",
                            "format": "date-time"
                          }
                        ]
                      },
                      "type": "array"
                    },
                    {
                      "$ref": "#/components/schemas/Range"
                    },
                    {
                      "$ref": "#/components/schemas/Any_"
                    },
                    {
                      "$ref": "#/components/schemas/All"
                    },
                    {
                      "$ref": "#/components/schemas/None_"
                    },
                    {
                      "type": "object"
                    }
                  ]
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Query",
            "description": "A query can be a very simple list of parameters. Different parameters or values of the same parameter are combined\nwith a logical **and**.\nThe following query would search for all entries that are VASP calculations,\ncontain *Na* **and** *Cl*, **and** are authored by *Stefano Curtarolo*\n**and** *Chris Wolverton*.\n```json\n{\n    \"results.material.elements\": [\"Na\", \"Cl\"],\n    \"results.method.simulation.program_name\": \"VASP\",\n    \"authors\": [\"Stefano Curtarolo\", \"Chris Wolverton\"]\n}\n```\n\nA short cut to change the logical combination of values in a list, is to\nadd a suffix to the quantity `:any`:\n```json\n{\n    \"results.material.elements\": [\"Na\", \"Cl\"],\n    \"results.method.simulation.program_name\": \"VASP\",\n    \"authors:any\": [\"Stefano Curtarolo\", \"Chris Wolverton\"]\n}\n```\n\nOtherwise, you can also write complex logical combinations of parameters like this:\n```json\n{\n    \"and\": [\n        {\n            \"or\": [\n                {\n                    \"results.material.elements\": [\"Cl\", \"Na\"]\n                },\n                {\n                    \"results.material.elements\": [\"H\", \"O\"]\n                }\n            ]\n        },\n        {\n            \"not\": {\n                \"results.material.symmetry.crystal_system\": \"cubic\"\n            }\n        }\n    ]\n}\n```\nOther short-cut prefixes are `none:` and `any:` (the default).\n\nBy default all quantity values have to **equal** the given values to match. For\nsome values you can also use comparison operators like this:\n```json\n{\n    \"upload_create_time\": {\n        \"gt\": \"2020-01-01\",\n        \"lt\": \"2020-08-01\"\n    },\n    \"results.properties.geometry_optimization.final_energy_difference\": {\n        \"lte\": 1.23e-18\n    }\n}\n```\n\nor shorter with suffixes:\n```json\n{\n    \"upload_create_time:gt\": \"2020-01-01\",\n    \"upload_create_time:lt\": \"2020-08-01\",\n    \"results.properties.geometry_optimization.final_energy_difference:lte\": 1.23e-18\n}\n```\n\nThe searchable quantities are a subset of the NOMAD Archive quantities defined\nin the NOMAD Metainfo. The searchable quantities also depend on the API endpoint.\n\nThere is also an additional query parameter that you can use to formulate queries based\non the optimade filter language:\n```json\n{\n    \"optimade_filter\": \"nelements >= 2 AND elements HAS ALL 'Ti', 'O'\"\n}\n```"
          },
          "pagination": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MetadataPagination"
              },
              {
                "type": "null"
              }
            ]
          },
          "required": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MetadataRequired"
              },
              {
                "type": "null"
              }
            ]
          },
          "aggregations": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/Aggregation"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Aggregations",
            "description": "Defines additional aggregations to return. There are different types of\naggregations: `terms`, `histogram`, `data_histogram`, `min_max`.",
            "default": {}
          }
        },
        "type": "object",
        "title": "Metadata"
      },
      "MetadataEditActions": {
        "properties": {
          "entry_create_time": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Entry Create Time",
            "description": "**NOTE:** Only editable by admin user"
          },
          "external_db": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "External Db"
          },
          "license": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "License",
            "description": "**NOTE:** Only editable by admin user"
          },
          "reviewer_groups": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "$ref": "#/components/schemas/MetadataEditListAction"
              },
              {
                "type": "null"
              }
            ],
            "title": "Reviewer Groups"
          },
          "external_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "External Id"
          },
          "coauthors": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "$ref": "#/components/schemas/MetadataEditListAction"
              },
              {
                "type": "null"
              }
            ],
            "title": "Coauthors"
          },
          "references": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "$ref": "#/components/schemas/MetadataEditListAction"
              },
              {
                "type": "null"
              }
            ],
            "title": "References"
          },
          "coauthor_groups": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "$ref": "#/components/schemas/MetadataEditListAction"
              },
              {
                "type": "null"
              }
            ],
            "title": "Coauthor Groups"
          },
          "main_author": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Main Author",
            "description": "**NOTE:** Only editable by admin user"
          },
          "reviewers": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "$ref": "#/components/schemas/MetadataEditListAction"
              },
              {
                "type": "null"
              }
            ],
            "title": "Reviewers"
          },
          "comment": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Comment"
          },
          "embargo_length": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Embargo Length"
          },
          "publish_time": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Publish Time",
            "description": "**NOTE:** Only editable by admin user"
          },
          "datasets": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "$ref": "#/components/schemas/MetadataEditListAction"
              },
              {
                "type": "null"
              }
            ],
            "title": "Datasets"
          },
          "upload_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Upload Name"
          },
          "upload_create_time": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Upload Create Time",
            "description": "**NOTE:** Only editable by admin user"
          }
        },
        "type": "object",
        "title": "MetadataEditActions"
      },
      "MetadataEditListAction": {
        "properties": {
          "set": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Set",
            "description": "Value(s) to set. Note, a set-operation overwrites the old list with the provided list.\nIf a set-operation is specified, it is therefore not possible to also specify an\nadd- or remove-operation."
          },
          "add": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Add",
            "description": "Value(s) to add to the list"
          },
          "remove": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Remove",
            "description": "Value(s) to remove from the list"
          }
        },
        "type": "object",
        "title": "MetadataEditListAction",
        "description": "Defines an action to perform on a list quantity. This enables users to add and remove values."
      },
      "MetadataEditRequest-Input": {
        "properties": {
          "owner": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Owner"
              },
              {
                "type": "null"
              }
            ],
            "default": "public"
          },
          "query": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/And-Input"
              },
              {
                "$ref": "#/components/schemas/Or-Input"
              },
              {
                "$ref": "#/components/schemas/Not-Input"
              },
              {
                "$ref": "#/components/schemas/Nested-Input"
              },
              {
                "$ref": "#/components/schemas/Criteria"
              },
              {
                "$ref": "#/components/schemas/Empty"
              },
              {
                "additionalProperties": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "number"
                    },
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "string"
                    },
                    {
                      "type": "string",
                      "format": "date-time"
                    },
                    {
                      "items": {
                        "anyOf": [
                          {
                            "type": "integer"
                          },
                          {
                            "type": "number"
                          },
                          {
                            "type": "boolean"
                          },
                          {
                            "type": "string"
                          },
                          {
                            "type": "string",
                            "format": "date-time"
                          }
                        ]
                      },
                      "type": "array"
                    },
                    {
                      "$ref": "#/components/schemas/Range"
                    },
                    {
                      "$ref": "#/components/schemas/Any_"
                    },
                    {
                      "$ref": "#/components/schemas/All"
                    },
                    {
                      "$ref": "#/components/schemas/None_"
                    },
                    {
                      "type": "object"
                    }
                  ]
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Query",
            "description": "A query can be a very simple list of parameters. Different parameters or values of the same parameter are combined\nwith a logical **and**.\nThe following query would search for all entries that are VASP calculations,\ncontain *Na* **and** *Cl*, **and** are authored by *Stefano Curtarolo*\n**and** *Chris Wolverton*.\n```json\n{\n    \"results.material.elements\": [\"Na\", \"Cl\"],\n    \"results.method.simulation.program_name\": \"VASP\",\n    \"authors\": [\"Stefano Curtarolo\", \"Chris Wolverton\"]\n}\n```\n\nA short cut to change the logical combination of values in a list, is to\nadd a suffix to the quantity `:any`:\n```json\n{\n    \"results.material.elements\": [\"Na\", \"Cl\"],\n    \"results.method.simulation.program_name\": \"VASP\",\n    \"authors:any\": [\"Stefano Curtarolo\", \"Chris Wolverton\"]\n}\n```\n\nOtherwise, you can also write complex logical combinations of parameters like this:\n```json\n{\n    \"and\": [\n        {\n            \"or\": [\n                {\n                    \"results.material.elements\": [\"Cl\", \"Na\"]\n                },\n                {\n                    \"results.material.elements\": [\"H\", \"O\"]\n                }\n            ]\n        },\n        {\n            \"not\": {\n                \"results.material.symmetry.crystal_system\": \"cubic\"\n            }\n        }\n    ]\n}\n```\nOther short-cut prefixes are `none:` and `any:` (the default).\n\nBy default all quantity values have to **equal** the given values to match. For\nsome values you can also use comparison operators like this:\n```json\n{\n    \"upload_create_time\": {\n        \"gt\": \"2020-01-01\",\n        \"lt\": \"2020-08-01\"\n    },\n    \"results.properties.geometry_optimization.final_energy_difference\": {\n        \"lte\": 1.23e-18\n    }\n}\n```\n\nor shorter with suffixes:\n```json\n{\n    \"upload_create_time:gt\": \"2020-01-01\",\n    \"upload_create_time:lt\": \"2020-08-01\",\n    \"results.properties.geometry_optimization.final_energy_difference:lte\": 1.23e-18\n}\n```\n\nThe searchable quantities are a subset of the NOMAD Archive quantities defined\nin the NOMAD Metainfo. The searchable quantities also depend on the API endpoint.\n\nThere is also an additional query parameter that you can use to formulate queries based\non the optimade filter language:\n```json\n{\n    \"optimade_filter\": \"nelements >= 2 AND elements HAS ALL 'Ti', 'O'\"\n}\n```"
          },
          "metadata": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MetadataEditActions"
              },
              {
                "type": "null"
              }
            ],
            "description": "Metadata to set, on the upload and/or selected entries."
          },
          "entries": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/MetadataEditActions"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Entries",
            "description": "An optional dictionary, specifying metadata to set on individual entries. The field\n`entries_metadata_key` defines which type of key is used in the dictionary to identify\nthe entries. Note, only quantities defined on the entry level can be set using this method."
          },
          "entries_key": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Entries Key",
            "description": "Defines which type of key is used in `entries_metadata`. Default is `entry_id`.",
            "default": "entry_id"
          },
          "verify_only": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Verify Only",
            "description": "Do not execute the request, just verifies it and provides detailed feedback on\nencountered errors etc.",
            "default": false
          }
        },
        "type": "object",
        "title": "MetadataEditRequest",
        "description": "Defines a request to edit metadata."
      },
      "MetadataEditRequest-Output": {
        "properties": {
          "owner": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Owner"
              },
              {
                "type": "null"
              }
            ],
            "default": "public"
          },
          "query": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/And-Output"
              },
              {
                "$ref": "#/components/schemas/Or-Output"
              },
              {
                "$ref": "#/components/schemas/Not-Output"
              },
              {
                "$ref": "#/components/schemas/Nested-Output"
              },
              {
                "$ref": "#/components/schemas/Criteria"
              },
              {
                "$ref": "#/components/schemas/Empty"
              },
              {
                "additionalProperties": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "number"
                    },
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "string"
                    },
                    {
                      "type": "string",
                      "format": "date-time"
                    },
                    {
                      "items": {
                        "anyOf": [
                          {
                            "type": "integer"
                          },
                          {
                            "type": "number"
                          },
                          {
                            "type": "boolean"
                          },
                          {
                            "type": "string"
                          },
                          {
                            "type": "string",
                            "format": "date-time"
                          }
                        ]
                      },
                      "type": "array"
                    },
                    {
                      "$ref": "#/components/schemas/Range"
                    },
                    {
                      "$ref": "#/components/schemas/Any_"
                    },
                    {
                      "$ref": "#/components/schemas/All"
                    },
                    {
                      "$ref": "#/components/schemas/None_"
                    },
                    {
                      "type": "object"
                    }
                  ]
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Query",
            "description": "A query can be a very simple list of parameters. Different parameters or values of the same parameter are combined\nwith a logical **and**.\nThe following query would search for all entries that are VASP calculations,\ncontain *Na* **and** *Cl*, **and** are authored by *Stefano Curtarolo*\n**and** *Chris Wolverton*.\n```json\n{\n    \"results.material.elements\": [\"Na\", \"Cl\"],\n    \"results.method.simulation.program_name\": \"VASP\",\n    \"authors\": [\"Stefano Curtarolo\", \"Chris Wolverton\"]\n}\n```\n\nA short cut to change the logical combination of values in a list, is to\nadd a suffix to the quantity `:any`:\n```json\n{\n    \"results.material.elements\": [\"Na\", \"Cl\"],\n    \"results.method.simulation.program_name\": \"VASP\",\n    \"authors:any\": [\"Stefano Curtarolo\", \"Chris Wolverton\"]\n}\n```\n\nOtherwise, you can also write complex logical combinations of parameters like this:\n```json\n{\n    \"and\": [\n        {\n            \"or\": [\n                {\n                    \"results.material.elements\": [\"Cl\", \"Na\"]\n                },\n                {\n                    \"results.material.elements\": [\"H\", \"O\"]\n                }\n            ]\n        },\n        {\n            \"not\": {\n                \"results.material.symmetry.crystal_system\": \"cubic\"\n            }\n        }\n    ]\n}\n```\nOther short-cut prefixes are `none:` and `any:` (the default).\n\nBy default all quantity values have to **equal** the given values to match. For\nsome values you can also use comparison operators like this:\n```json\n{\n    \"upload_create_time\": {\n        \"gt\": \"2020-01-01\",\n        \"lt\": \"2020-08-01\"\n    },\n    \"results.properties.geometry_optimization.final_energy_difference\": {\n        \"lte\": 1.23e-18\n    }\n}\n```\n\nor shorter with suffixes:\n```json\n{\n    \"upload_create_time:gt\": \"2020-01-01\",\n    \"upload_create_time:lt\": \"2020-08-01\",\n    \"results.properties.geometry_optimization.final_energy_difference:lte\": 1.23e-18\n}\n```\n\nThe searchable quantities are a subset of the NOMAD Archive quantities defined\nin the NOMAD Metainfo. The searchable quantities also depend on the API endpoint.\n\nThere is also an additional query parameter that you can use to formulate queries based\non the optimade filter language:\n```json\n{\n    \"optimade_filter\": \"nelements >= 2 AND elements HAS ALL 'Ti', 'O'\"\n}\n```"
          },
          "metadata": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MetadataEditActions"
              },
              {
                "type": "null"
              }
            ],
            "description": "Metadata to set, on the upload and/or selected entries."
          },
          "entries": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/MetadataEditActions"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Entries",
            "description": "An optional dictionary, specifying metadata to set on individual entries. The field\n`entries_metadata_key` defines which type of key is used in the dictionary to identify\nthe entries. Note, only quantities defined on the entry level can be set using this method."
          },
          "entries_key": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Entries Key",
            "description": "Defines which type of key is used in `entries_metadata`. Default is `entry_id`.",
            "default": "entry_id"
          },
          "verify_only": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Verify Only",
            "description": "Do not execute the request, just verifies it and provides detailed feedback on\nencountered errors etc.",
            "default": false
          }
        },
        "type": "object",
        "title": "MetadataEditRequest",
        "description": "Defines a request to edit metadata."
      },
      "MetadataPagination": {
        "properties": {
          "page_size": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page Size",
            "description": "The page size, e.g. the maximum number of items contained in one response.\nA `page_size` of 0 will return no results.",
            "default": 10
          },
          "order_by": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Order By",
            "description": "The results are ordered by the values of this field. You can order\nby any indexed scalar value, or one following two special fields:\n\n - `_score`: Sorts by relevance score.\n - `_doc`: Use when sorting does not matter, gives the best performance.\n\nIf omitted, default ordering is applied."
          },
          "order": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Direction"
              },
              {
                "type": "null"
              }
            ],
            "description": "The ordering direction of the results based on `order_by`. Its either\nascending `asc` or descending `desc`. Default is `asc`.",
            "default": "asc"
          },
          "page_after_value": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page After Value",
            "description": "This attribute defines the position after which the page begins, and is used\nto navigate through the total list of results.\n\nWhen requesting the first page, no value should be provided for\n`page_after_value`. Each response will contain a value `next_page_after_value`,\nwhich can be used to obtain the next page (by setting `page_after_value` in\nyour next request to this value).\n\nThe field is encoded as a string, and the format of `page_after_value` and\n`next_page_after_value` depends on which API method is used.\n\nSome API functions additionally allows a simplified navigation, by specifying\nthe page number in the key `page`. It is however always possible to use\n`page_after_value` and `next_page_after_value` to iterate through the results."
          },
          "page": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page",
            "description": "For simple, index-based pagination, this should contain the number of the\nrequested page (1-based). When provided in a request, this attribute can be\nused instead of `page_after_value` to jump to a particular results page.\n\nHowever, you can only retrieve up to the 10.000th entry with a page number.\nOnly one, `page`, `page_offset` or `page_after_value`, can be used."
          },
          "page_offset": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page Offset",
            "description": "Return the page that follows the given number of entries. Overwrites\n`page` and `page_after_value`.\n\nHowever, you can only retrieve up to the 10.000th entry.\nOnly one, `page`, `page_offset` or `page_after_value`, can be used."
          }
        },
        "type": "object",
        "title": "MetadataPagination"
      },
      "MetadataRequired": {
        "properties": {
          "include": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Include",
            "description": "Quantities to include for each result. Only those quantities will be\nreturned. At least one id quantity (e.g. `entry_id`) will always be included."
          },
          "exclude": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Exclude",
            "description": "Quantities to exclude for each result. Only all other quantities will\nbe returned. The entity's id quantity (e.g. `entry_id`) cannot be excluded."
          }
        },
        "type": "object",
        "title": "MetadataRequired",
        "description": "Defines which metadata quantities are included or excluded in the response."
      },
      "MetadataResponse": {
        "properties": {
          "owner": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Owner"
              },
              {
                "type": "null"
              }
            ],
            "default": "public"
          },
          "query": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/And-Output"
              },
              {
                "$ref": "#/components/schemas/Or-Output"
              },
              {
                "$ref": "#/components/schemas/Not-Output"
              },
              {
                "$ref": "#/components/schemas/Nested-Output"
              },
              {
                "$ref": "#/components/schemas/Criteria"
              },
              {
                "$ref": "#/components/schemas/Empty"
              },
              {
                "additionalProperties": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "number"
                    },
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "string"
                    },
                    {
                      "type": "string",
                      "format": "date-time"
                    },
                    {
                      "items": {
                        "anyOf": [
                          {
                            "type": "integer"
                          },
                          {
                            "type": "number"
                          },
                          {
                            "type": "boolean"
                          },
                          {
                            "type": "string"
                          },
                          {
                            "type": "string",
                            "format": "date-time"
                          }
                        ]
                      },
                      "type": "array"
                    },
                    {
                      "$ref": "#/components/schemas/Range"
                    },
                    {
                      "$ref": "#/components/schemas/Any_"
                    },
                    {
                      "$ref": "#/components/schemas/All"
                    },
                    {
                      "$ref": "#/components/schemas/None_"
                    },
                    {
                      "type": "object"
                    }
                  ]
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Query",
            "description": "A query can be a very simple list of parameters. Different parameters or values of the same parameter are combined\nwith a logical **and**.\nThe following query would search for all entries that are VASP calculations,\ncontain *Na* **and** *Cl*, **and** are authored by *Stefano Curtarolo*\n**and** *Chris Wolverton*.\n```json\n{\n    \"results.material.elements\": [\"Na\", \"Cl\"],\n    \"results.method.simulation.program_name\": \"VASP\",\n    \"authors\": [\"Stefano Curtarolo\", \"Chris Wolverton\"]\n}\n```\n\nA short cut to change the logical combination of values in a list, is to\nadd a suffix to the quantity `:any`:\n```json\n{\n    \"results.material.elements\": [\"Na\", \"Cl\"],\n    \"results.method.simulation.program_name\": \"VASP\",\n    \"authors:any\": [\"Stefano Curtarolo\", \"Chris Wolverton\"]\n}\n```\n\nOtherwise, you can also write complex logical combinations of parameters like this:\n```json\n{\n    \"and\": [\n        {\n            \"or\": [\n                {\n                    \"results.material.elements\": [\"Cl\", \"Na\"]\n                },\n                {\n                    \"results.material.elements\": [\"H\", \"O\"]\n                }\n            ]\n        },\n        {\n            \"not\": {\n                \"results.material.symmetry.crystal_system\": \"cubic\"\n            }\n        }\n    ]\n}\n```\nOther short-cut prefixes are `none:` and `any:` (the default).\n\nBy default all quantity values have to **equal** the given values to match. For\nsome values you can also use comparison operators like this:\n```json\n{\n    \"upload_create_time\": {\n        \"gt\": \"2020-01-01\",\n        \"lt\": \"2020-08-01\"\n    },\n    \"results.properties.geometry_optimization.final_energy_difference\": {\n        \"lte\": 1.23e-18\n    }\n}\n```\n\nor shorter with suffixes:\n```json\n{\n    \"upload_create_time:gt\": \"2020-01-01\",\n    \"upload_create_time:lt\": \"2020-08-01\",\n    \"results.properties.geometry_optimization.final_energy_difference:lte\": 1.23e-18\n}\n```\n\nThe searchable quantities are a subset of the NOMAD Archive quantities defined\nin the NOMAD Metainfo. The searchable quantities also depend on the API endpoint.\n\nThere is also an additional query parameter that you can use to formulate queries based\non the optimade filter language:\n```json\n{\n    \"optimade_filter\": \"nelements >= 2 AND elements HAS ALL 'Ti', 'O'\"\n}\n```"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationResponse"
          },
          "required": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MetadataRequired"
              },
              {
                "type": "null"
              }
            ]
          },
          "aggregations": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/AggregationResponse"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Aggregations"
          },
          "data": {
            "items": {
              "type": "object"
            },
            "type": "array",
            "title": "Data",
            "description": "The entries data as a list. Each item is a dictionary with the metadata for each\nentry."
          },
          "code": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CodeResponse"
              },
              {
                "type": "null"
              }
            ]
          },
          "es_query": {
            "title": "Es Query",
            "description": "The elasticsearch query that was used to retrieve the results."
          }
        },
        "type": "object",
        "title": "MetadataResponse"
      },
      "MetainfoPagination": {
        "properties": {
          "page_size": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page Size",
            "description": "The page size, e.g. the maximum number of items contained in one response.\nA `page_size` of 0 will return no results.",
            "default": 10
          },
          "order_by": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Order By",
            "description": "The results are ordered by the values of this field. If omitted, default\nordering is applied."
          },
          "order": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Direction"
              },
              {
                "type": "null"
              }
            ],
            "description": "The ordering direction of the results based on `order_by`. Its either\nascending `asc` or descending `desc`. Default is `asc`.",
            "default": "asc"
          },
          "page_after_value": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page After Value",
            "description": "This attribute defines the position after which the page begins, and is used\nto navigate through the total list of results.\n\nWhen requesting the first page, no value should be provided for\n`page_after_value`. Each response will contain a value `next_page_after_value`,\nwhich can be used to obtain the next page (by setting `page_after_value` in\nyour next request to this value).\n\nThe field is encoded as a string, and the format of `page_after_value` and\n`next_page_after_value` depends on which API method is used.\n\nSome API functions additionally allows a simplified navigation, by specifying\nthe page number in the key `page`. It is however always possible to use\n`page_after_value` and `next_page_after_value` to iterate through the results."
          },
          "page": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page",
            "description": "The number of the page (1-based). When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used."
          },
          "page_offset": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page Offset",
            "description": "The number of skipped entries. When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page_offset` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used."
          }
        },
        "type": "object",
        "title": "MetainfoPagination"
      },
      "MetainfoQuery": {
        "properties": {},
        "type": "object",
        "title": "MetainfoQuery"
      },
      "MetainfoRequestOptions": {
        "properties": {
          "pagination": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MetainfoPagination"
              },
              {
                "type": "null"
              }
            ]
          },
          "query": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MetainfoQuery"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "title": "MetainfoRequestOptions"
      },
      "MetainfoResponseOptions": {
        "properties": {
          "pagination": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PaginationResponse"
              },
              {
                "type": "null"
              }
            ]
          },
          "query": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MetainfoQuery"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "title": "MetainfoResponseOptions"
      },
      "MinMaxAggregation": {
        "properties": {
          "quantity": {
            "type": "string",
            "title": "Quantity",
            "description": "The mandatory name of the quantity for the aggregation. Aggregations\ncan only be computed for those search metadata that have discrete values;\nan aggregation buckets entries that have the same value for this quantity."
          },
          "exclude_from_search": {
            "type": "boolean",
            "title": "Exclude From Search",
            "description": "If set to true, top-level search criteria involving the aggregation quantity, will not\nbe applied for this aggregation. Therefore, the aggregation will return all\nvalues for the quantity, even if the possible values where filtered by the query.\n\nThere are two limitations. This is only supported with queries that start with a\ndictionary. It will not work for queries with a boolean operator. It can only\nexclude top-level criteria at the root of the query dictionary. Nested criteria,\ne.g. within complex and/or constructs, cannot be considered. Using this might also\nprohibit pagination with page_after_value on aggregations in the same request.",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "quantity"
        ],
        "title": "MinMaxAggregation"
      },
      "MinMaxAggregationResponse": {
        "properties": {
          "quantity": {
            "type": "string",
            "title": "Quantity",
            "description": "The mandatory name of the quantity for the aggregation. Aggregations\ncan only be computed for those search metadata that have discrete values;\nan aggregation buckets entries that have the same value for this quantity."
          },
          "exclude_from_search": {
            "type": "boolean",
            "title": "Exclude From Search",
            "description": "If set to true, top-level search criteria involving the aggregation quantity, will not\nbe applied for this aggregation. Therefore, the aggregation will return all\nvalues for the quantity, even if the possible values where filtered by the query.\n\nThere are two limitations. This is only supported with queries that start with a\ndictionary. It will not work for queries with a boolean operator. It can only\nexclude top-level criteria at the root of the query dictionary. Nested criteria,\ne.g. within complex and/or constructs, cannot be considered. Using this might also\nprohibit pagination with page_after_value on aggregations in the same request.",
            "default": false
          },
          "data": {
            "items": {
              "anyOf": [
                {
                  "type": "number"
                },
                {
                  "type": "null"
                }
              ]
            },
            "type": "array",
            "title": "Data"
          }
        },
        "type": "object",
        "required": [
          "quantity",
          "data"
        ],
        "title": "MinMaxAggregationResponse"
      },
      "NORTHExternalMount": {
        "properties": {
          "host_path": {
            "type": "string",
            "title": "Host Path"
          },
          "bind": {
            "type": "string",
            "title": "Bind"
          },
          "mode": {
            "$ref": "#/components/schemas/ReadMode",
            "default": "ro"
          }
        },
        "type": "object",
        "required": [
          "host_path",
          "bind"
        ],
        "title": "NORTHExternalMount"
      },
      "NORTHToolMaintainer": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          },
          "email": {
            "type": "string",
            "title": "Email"
          }
        },
        "type": "object",
        "required": [
          "name",
          "email"
        ],
        "title": "NORTHToolMaintainer"
      },
      "Nested-Input": {
        "properties": {
          "prefix": {
            "type": "string",
            "title": "Prefix"
          },
          "query": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/And-Input"
              },
              {
                "$ref": "#/components/schemas/Or-Input"
              },
              {
                "$ref": "#/components/schemas/Not-Input"
              },
              {
                "$ref": "#/components/schemas/Nested-Input"
              },
              {
                "$ref": "#/components/schemas/Criteria"
              },
              {
                "$ref": "#/components/schemas/Empty"
              },
              {
                "additionalProperties": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "number"
                    },
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "string"
                    },
                    {
                      "type": "string",
                      "format": "date-time"
                    },
                    {
                      "items": {
                        "anyOf": [
                          {
                            "type": "integer"
                          },
                          {
                            "type": "number"
                          },
                          {
                            "type": "boolean"
                          },
                          {
                            "type": "string"
                          },
                          {
                            "type": "string",
                            "format": "date-time"
                          }
                        ]
                      },
                      "type": "array"
                    },
                    {
                      "$ref": "#/components/schemas/Range"
                    },
                    {
                      "$ref": "#/components/schemas/Any_"
                    },
                    {
                      "$ref": "#/components/schemas/All"
                    },
                    {
                      "$ref": "#/components/schemas/None_"
                    },
                    {
                      "type": "object"
                    }
                  ]
                },
                "type": "object"
              }
            ],
            "title": "Query"
          }
        },
        "type": "object",
        "required": [
          "prefix",
          "query"
        ],
        "title": "Nested"
      },
      "Nested-Output": {
        "properties": {
          "prefix": {
            "type": "string",
            "title": "Prefix"
          },
          "query": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/And-Output"
              },
              {
                "$ref": "#/components/schemas/Or-Output"
              },
              {
                "$ref": "#/components/schemas/Not-Output"
              },
              {
                "$ref": "#/components/schemas/Nested-Output"
              },
              {
                "$ref": "#/components/schemas/Criteria"
              },
              {
                "$ref": "#/components/schemas/Empty"
              },
              {
                "additionalProperties": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "number"
                    },
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "string"
                    },
                    {
                      "type": "string",
                      "format": "date-time"
                    },
                    {
                      "items": {
                        "anyOf": [
                          {
                            "type": "integer"
                          },
                          {
                            "type": "number"
                          },
                          {
                            "type": "boolean"
                          },
                          {
                            "type": "string"
                          },
                          {
                            "type": "string",
                            "format": "date-time"
                          }
                        ]
                      },
                      "type": "array"
                    },
                    {
                      "$ref": "#/components/schemas/Range"
                    },
                    {
                      "$ref": "#/components/schemas/Any_"
                    },
                    {
                      "$ref": "#/components/schemas/All"
                    },
                    {
                      "$ref": "#/components/schemas/None_"
                    },
                    {
                      "type": "object"
                    }
                  ]
                },
                "type": "object"
              }
            ],
            "title": "Query"
          }
        },
        "type": "object",
        "required": [
          "prefix",
          "query"
        ],
        "title": "Nested"
      },
      "None_": {
        "properties": {
          "none": {
            "items": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "number"
                },
                {
                  "type": "boolean"
                },
                {
                  "type": "string"
                },
                {
                  "type": "string",
                  "format": "date-time"
                }
              ]
            },
            "type": "array",
            "title": "None"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "None_"
      },
      "Not-Input": {
        "properties": {
          "not": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/And-Input"
              },
              {
                "$ref": "#/components/schemas/Or-Input"
              },
              {
                "$ref": "#/components/schemas/Not-Input"
              },
              {
                "$ref": "#/components/schemas/Nested-Input"
              },
              {
                "$ref": "#/components/schemas/Criteria"
              },
              {
                "$ref": "#/components/schemas/Empty"
              },
              {
                "additionalProperties": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "number"
                    },
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "string"
                    },
                    {
                      "type": "string",
                      "format": "date-time"
                    },
                    {
                      "items": {
                        "anyOf": [
                          {
                            "type": "integer"
                          },
                          {
                            "type": "number"
                          },
                          {
                            "type": "boolean"
                          },
                          {
                            "type": "string"
                          },
                          {
                            "type": "string",
                            "format": "date-time"
                          }
                        ]
                      },
                      "type": "array"
                    },
                    {
                      "$ref": "#/components/schemas/Range"
                    },
                    {
                      "$ref": "#/components/schemas/Any_"
                    },
                    {
                      "$ref": "#/components/schemas/All"
                    },
                    {
                      "$ref": "#/components/schemas/None_"
                    },
                    {
                      "type": "object"
                    }
                  ]
                },
                "type": "object"
              }
            ],
            "title": "Not"
          }
        },
        "type": "object",
        "title": "Not"
      },
      "Not-Output": {
        "properties": {
          "not": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/And-Output"
              },
              {
                "$ref": "#/components/schemas/Or-Output"
              },
              {
                "$ref": "#/components/schemas/Not-Output"
              },
              {
                "$ref": "#/components/schemas/Nested-Output"
              },
              {
                "$ref": "#/components/schemas/Criteria"
              },
              {
                "$ref": "#/components/schemas/Empty"
              },
              {
                "additionalProperties": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "number"
                    },
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "string"
                    },
                    {
                      "type": "string",
                      "format": "date-time"
                    },
                    {
                      "items": {
                        "anyOf": [
                          {
                            "type": "integer"
                          },
                          {
                            "type": "number"
                          },
                          {
                            "type": "boolean"
                          },
                          {
                            "type": "string"
                          },
                          {
                            "type": "string",
                            "format": "date-time"
                          }
                        ]
                      },
                      "type": "array"
                    },
                    {
                      "$ref": "#/components/schemas/Range"
                    },
                    {
                      "$ref": "#/components/schemas/Any_"
                    },
                    {
                      "$ref": "#/components/schemas/All"
                    },
                    {
                      "$ref": "#/components/schemas/None_"
                    },
                    {
                      "type": "object"
                    }
                  ]
                },
                "type": "object"
              }
            ],
            "title": "Not"
          }
        },
        "type": "object",
        "title": "Not"
      },
      "Or-Input": {
        "properties": {
          "or": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/And-Input"
                },
                {
                  "$ref": "#/components/schemas/Or-Input"
                },
                {
                  "$ref": "#/components/schemas/Not-Input"
                },
                {
                  "$ref": "#/components/schemas/Nested-Input"
                },
                {
                  "$ref": "#/components/schemas/Criteria"
                },
                {
                  "$ref": "#/components/schemas/Empty"
                },
                {
                  "additionalProperties": {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "type": "number"
                      },
                      {
                        "type": "boolean"
                      },
                      {
                        "type": "string"
                      },
                      {
                        "type": "string",
                        "format": "date-time"
                      },
                      {
                        "items": {
                          "anyOf": [
                            {
                              "type": "integer"
                            },
                            {
                              "type": "number"
                            },
                            {
                              "type": "boolean"
                            },
                            {
                              "type": "string"
                            },
                            {
                              "type": "string",
                              "format": "date-time"
                            }
                          ]
                        },
                        "type": "array"
                      },
                      {
                        "$ref": "#/components/schemas/Range"
                      },
                      {
                        "$ref": "#/components/schemas/Any_"
                      },
                      {
                        "$ref": "#/components/schemas/All"
                      },
                      {
                        "$ref": "#/components/schemas/None_"
                      },
                      {
                        "type": "object"
                      }
                    ]
                  },
                  "type": "object"
                }
              ]
            },
            "type": "array",
            "title": "Or"
          }
        },
        "type": "object",
        "title": "Or"
      },
      "Or-Output": {
        "properties": {
          "or": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/And-Output"
                },
                {
                  "$ref": "#/components/schemas/Or-Output"
                },
                {
                  "$ref": "#/components/schemas/Not-Output"
                },
                {
                  "$ref": "#/components/schemas/Nested-Output"
                },
                {
                  "$ref": "#/components/schemas/Criteria"
                },
                {
                  "$ref": "#/components/schemas/Empty"
                },
                {
                  "additionalProperties": {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "type": "number"
                      },
                      {
                        "type": "boolean"
                      },
                      {
                        "type": "string"
                      },
                      {
                        "type": "string",
                        "format": "date-time"
                      },
                      {
                        "items": {
                          "anyOf": [
                            {
                              "type": "integer"
                            },
                            {
                              "type": "number"
                            },
                            {
                              "type": "boolean"
                            },
                            {
                              "type": "string"
                            },
                            {
                              "type": "string",
                              "format": "date-time"
                            }
                          ]
                        },
                        "type": "array"
                      },
                      {
                        "$ref": "#/components/schemas/Range"
                      },
                      {
                        "$ref": "#/components/schemas/Any_"
                      },
                      {
                        "$ref": "#/components/schemas/All"
                      },
                      {
                        "$ref": "#/components/schemas/None_"
                      },
                      {
                        "type": "object"
                      }
                    ]
                  },
                  "type": "object"
                }
              ]
            },
            "type": "array",
            "title": "Or"
          }
        },
        "type": "object",
        "title": "Or"
      },
      "Owner": {
        "type": "string",
        "enum": [
          "public",
          "all",
          "visible",
          "shared",
          "user",
          "staging",
          "admin"
        ],
        "title": "Owner",
        "description": "The `owner` allows to limit the scope of the search based on entry ownership.\nThis is useful if you only want to search among all publicly downloadable\nentries or only among your own entries, etc.\n\nThese are the possible owner values and their meaning:\n\n* `admin`: No restriction. Only usable by an admin user.\n* `all`: Published entries (with or without embargo), or entries that belong to you\n    or are shared with you.\n* `public`: Published entries without embargo.\n* `shared`: Entries that belong to you or are shared with you.\n* `staging`: Unpublished entries that belong to you or are shared with you.\n* `user`: Entries that belong to you.\n* `visible`: Published entries without embargo, or unpublished entries that belong to\n    you or are shared with you."
      },
      "PackageDefinitionResponse": {
        "properties": {
          "section_definition_id": {
            "type": "string",
            "title": "Section Definition Id"
          },
          "data": {
            "type": "object",
            "title": "Data"
          }
        },
        "type": "object",
        "title": "PackageDefinitionResponse"
      },
      "PaginationResponse": {
        "properties": {
          "page_size": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page Size",
            "description": "The page size, e.g. the maximum number of items contained in one response.\nA `page_size` of 0 will return no results.",
            "default": 10
          },
          "order_by": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Order By",
            "description": "The results are ordered by the values of this field. If omitted, default\nordering is applied."
          },
          "order": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Direction"
              },
              {
                "type": "null"
              }
            ],
            "description": "The ordering direction of the results based on `order_by`. Its either\nascending `asc` or descending `desc`. Default is `asc`.",
            "default": "asc"
          },
          "page_after_value": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page After Value",
            "description": "This attribute defines the position after which the page begins, and is used\nto navigate through the total list of results.\n\nWhen requesting the first page, no value should be provided for\n`page_after_value`. Each response will contain a value `next_page_after_value`,\nwhich can be used to obtain the next page (by setting `page_after_value` in\nyour next request to this value).\n\nThe field is encoded as a string, and the format of `page_after_value` and\n`next_page_after_value` depends on which API method is used.\n\nSome API functions additionally allows a simplified navigation, by specifying\nthe page number in the key `page`. It is however always possible to use\n`page_after_value` and `next_page_after_value` to iterate through the results."
          },
          "page": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page",
            "description": "The number of the page (1-based). When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used."
          },
          "page_offset": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page Offset",
            "description": "The number of skipped entries. When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page_offset` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used."
          },
          "total": {
            "type": "integer",
            "title": "Total",
            "description": "The total number of results that fit the given query. This is independent of\nany pagination and aggregations."
          },
          "next_page_after_value": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Next Page After Value",
            "description": "The *next* value to be used as `page_after_value` in a follow up requests, to get\nthe next page of results. If no more results are available, `next_page_after_value`\nwill not be set."
          },
          "page_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page Url",
            "description": "The url of the current page. Only applicable for GET requests."
          },
          "next_page_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Next Page Url",
            "description": "The url to get the next page. Only applicable for GET requests."
          },
          "prev_page_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Prev Page Url",
            "description": "The url to get the previous page. **NOTE:** Only applicable for some API methods,\n(namely, where indexing by `page` is possible), and only for GET requests."
          },
          "first_page_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "First Page Url",
            "description": "The url to get the first page. Only applicable for GET requests."
          }
        },
        "type": "object",
        "required": [
          "total"
        ],
        "title": "PaginationResponse"
      },
      "ProcessingData": {
        "properties": {
          "upload_id": {
            "type": "string",
            "title": "Upload Id"
          },
          "path": {
            "type": "string",
            "title": "Path"
          },
          "entry_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Entry Id"
          },
          "parser_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Parser Name"
          },
          "entry": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EntryProcData"
              },
              {
                "type": "null"
              }
            ]
          },
          "archive": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Archive"
          }
        },
        "type": "object",
        "required": [
          "upload_id",
          "path"
        ],
        "title": "ProcessingData"
      },
      "PublicUserInfo": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          },
          "first_name": {
            "type": "string",
            "title": "First Name"
          },
          "last_name": {
            "type": "string",
            "title": "Last Name"
          },
          "affiliation": {
            "type": "string",
            "title": "Affiliation"
          },
          "affiliation_address": {
            "type": "string",
            "title": "Affiliation Address"
          },
          "user_id": {
            "type": "string",
            "title": "User Id"
          },
          "username": {
            "type": "string",
            "title": "Username"
          }
        },
        "type": "object",
        "title": "PublicUserInfo",
        "description": "User information that is publicly available."
      },
      "PutRawFileResponse": {
        "properties": {
          "upload_id": {
            "type": "string",
            "title": "Upload Id",
            "description": "Unique id of the upload."
          },
          "data": {
            "$ref": "#/components/schemas/UploadProcData",
            "description": "The upload data as a dictionary."
          },
          "processing": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ProcessingData"
              },
              {
                "type": "null"
              }
            ],
            "description": "Information about the processing, including the entry (if one was generated) and\n[optionally] the archive data of this entry."
          }
        },
        "type": "object",
        "title": "PutRawFileResponse"
      },
      "Quantity": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The name of the targeted quantity."
          },
          "size": {
            "type": "integer",
            "title": "Size",
            "description": "The maximum number of suggestion results to query for this quantity.",
            "default": 5
          }
        },
        "type": "object",
        "title": "Quantity"
      },
      "Range": {
        "properties": {
          "lt": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "number"
              },
              {
                "type": "string"
              },
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lt"
          },
          "lte": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "number"
              },
              {
                "type": "string"
              },
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lte"
          },
          "gt": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "number"
              },
              {
                "type": "string"
              },
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Gt"
          },
          "gte": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "number"
              },
              {
                "type": "string"
              },
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Gte"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "Range",
        "description": "Represents a finite range which can have open or closed ends. Supports\nseveral datatypes that have a well-defined comparison operator."
      },
      "RawDirDirectoryMetadata": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          },
          "size": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Size"
          },
          "content": {
            "items": {
              "$ref": "#/components/schemas/RawDirElementMetadata"
            },
            "type": "array",
            "title": "Content",
            "examples": [
              [
                {
                  "is_file": false,
                  "name": "a_directory",
                  "size": 456
                },
                {
                  "entry_id": "XYZ",
                  "is_file": true,
                  "name": "a_file.json",
                  "parser_name": "parsers/vasp",
                  "size": 123
                }
              ]
            ]
          }
        },
        "type": "object",
        "required": [
          "name",
          "content"
        ],
        "title": "RawDirDirectoryMetadata",
        "description": "Metadata about a directory"
      },
      "RawDirElementMetadata": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          },
          "size": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Size"
          },
          "entry_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Entry Id",
            "description": "If this is a mainfile: the ID of the corresponding entry."
          },
          "parser_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Parser Name",
            "description": "If this is a mainfile: the name of the matched parser."
          },
          "is_file": {
            "type": "boolean",
            "title": "Is File"
          }
        },
        "type": "object",
        "required": [
          "name",
          "is_file"
        ],
        "title": "RawDirElementMetadata",
        "description": "Metadata about an directory *element*, i.e. a file or a directory"
      },
      "RawDirFileMetadata": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          },
          "size": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Size"
          },
          "entry_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Entry Id",
            "description": "If this is a mainfile: the ID of the corresponding entry."
          },
          "parser_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Parser Name",
            "description": "If this is a mainfile: the name of the matched parser."
          }
        },
        "type": "object",
        "required": [
          "name"
        ],
        "title": "RawDirFileMetadata",
        "description": "Metadata about a file"
      },
      "RawDirPagination": {
        "properties": {
          "page_size": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page Size",
            "description": "The page size, e.g. the maximum number of items contained in one response.\nA `page_size` of 0 will return no results.",
            "default": 10
          },
          "order_by": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Order By",
            "description": "The results are ordered by the values of this field. If omitted, default\nordering is applied."
          },
          "order": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Direction"
              },
              {
                "type": "null"
              }
            ],
            "description": "The ordering direction of the results based on `order_by`. Its either\nascending `asc` or descending `desc`. Default is `asc`.",
            "default": "asc"
          },
          "page_after_value": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page After Value",
            "description": "This attribute defines the position after which the page begins, and is used\nto navigate through the total list of results.\n\nWhen requesting the first page, no value should be provided for\n`page_after_value`. Each response will contain a value `next_page_after_value`,\nwhich can be used to obtain the next page (by setting `page_after_value` in\nyour next request to this value).\n\nThe field is encoded as a string, and the format of `page_after_value` and\n`next_page_after_value` depends on which API method is used.\n\nSome API functions additionally allows a simplified navigation, by specifying\nthe page number in the key `page`. It is however always possible to use\n`page_after_value` and `next_page_after_value` to iterate through the results."
          },
          "page": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page",
            "description": "The number of the page (1-based). When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used."
          },
          "page_offset": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page Offset",
            "description": "The number of skipped entries. When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page_offset` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used."
          }
        },
        "type": "object",
        "title": "RawDirPagination"
      },
      "RawDirResponse": {
        "properties": {
          "path": {
            "type": "string",
            "title": "Path",
            "examples": [
              "The/requested/path"
            ]
          },
          "access": {
            "type": "string",
            "title": "Access"
          },
          "file_metadata": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/RawDirFileMetadata"
              },
              {
                "type": "null"
              }
            ]
          },
          "directory_metadata": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/RawDirDirectoryMetadata"
              },
              {
                "type": "null"
              }
            ]
          },
          "pagination": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PaginationResponse"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "path",
          "access"
        ],
        "title": "RawDirResponse"
      },
      "ReadMode": {
        "type": "string",
        "enum": [
          "ro",
          "rw"
        ],
        "title": "ReadMode"
      },
      "RequestConfig": {
        "properties": {
          "property_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Property Name",
            "description": "\n        The name of the current field, either a quantity or a subsection.\n        This may differ from the key in the query as the key may contain indices.\n        This is for internal use and is automatically set by the `RequestConfig` class.\n        User should NOT set this field.\n        "
          },
          "directive": {
            "$ref": "#/components/schemas/DirectiveType",
            "description": "\n        Indicate whether to include or exclude the current quantity/section.\n        References can be resolved using `resolved`.\n        The `*` is a shortcut of `plain`.\n        ",
            "default": "plain"
          },
          "include": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "uniqueItems": true
              },
              {
                "type": "null"
              }
            ],
            "title": "Include",
            "description": "\n        A list of patterns to match the quantities and subsections of the current section.\n        The quantities/sections that match the include patterns AND do not match the include patterns are included.\n        Only one of `include` and `exclude` can be set.\n        "
          },
          "exclude": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "uniqueItems": true
              },
              {
                "type": "null"
              }
            ],
            "title": "Exclude",
            "description": "\n        A list of patterns to match the quantities and subsections of the current section.\n        The quantities/sections that match the include patterns AND do not match the include patterns are included.\n        Only one of `include` and `exclude` can be set.\n        "
          },
          "depth": {
            "type": "integer",
            "minimum": 0,
            "title": "Depth",
            "description": "\n        Indicate the maximum depth to be retrieved for the current section.\n        If `None`, the depth is unlimited.\n        This option does not apply to primitive quantities, which are always retrieved.\n        "
          },
          "resolve_depth": {
            "type": "integer",
            "minimum": 0,
            "title": "Resolve Depth",
            "description": "\n        Indicate the maximum depth to be resolved for references.\n        If `None`, the depth is unlimited.\n        "
          },
          "resolve_type": {
            "$ref": "#/components/schemas/ResolveType",
            "description": "\n        Indicate how the current data should be interpreted.\n        This option does not affect normal quantities/sections and should be left unassigned in most cases.\n        If a value is assigned, for example `upload`, the target data will be treated as an upload id and\n        the corresponding information will be retrieved.\n        The original data will be left as it is if the assigned resolve type cannot find additional information.\n        "
          },
          "max_list_size": {
            "type": "integer",
            "minimum": 0,
            "title": "Max List Size",
            "description": "\n        Indicate the size limit of lists. If assigned, lists longer than this limit will be ignored.\n        "
          },
          "max_dict_size": {
            "type": "integer",
            "minimum": 0,
            "title": "Max Dict Size",
            "description": "\n        Indicate the size limit of dictionaries. If assigned, dictionaries larger than this limit will be ignored.\n        "
          },
          "resolve_inplace": {
            "type": "boolean",
            "title": "Resolve Inplace",
            "description": "\n        Indicate whether to resolve references in-place.\n        Deprecated, always set to `False`.\n        If `false`, the reference string will be kept unchanged.\n        The resolved quantity/section will be placed in the same archive.\n        ",
            "default": false
          },
          "export_whole_package": {
            "type": "boolean",
            "title": "Export Whole Package",
            "description": "\n        Set to `True` to always get the whole package.\n        Set to `False` to definitions per section basis.\n        ",
            "default": false
          },
          "always_rewrite_references": {
            "type": "boolean",
            "title": "Always Rewrite References",
            "description": "\n        Set to `True` to always rewrite references.\n        This yields a more consistent output but has a performance penalty.\n        ",
            "default": false
          },
          "include_definition": {
            "$ref": "#/components/schemas/DefinitionType",
            "description": "\n        Indicate whether to include the definition of the current section.\n        If `default`, the default original standard definition bundled with the NOMAD will be included.\n        If `custom`, the custom definition will be included.\n        If `both`, both original and custom definitions will be included, with custom definitions taking precedence.\n        If `none`, no definition will be included.\n        ",
            "default": "none"
          },
          "index": {
            "anyOf": [
              {
                "prefixItems": [
                  {
                    "type": "integer"
                  }
                ],
                "type": "array",
                "maxItems": 1,
                "minItems": 1
              },
              {
                "prefixItems": [
                  {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  {
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  }
                ],
                "type": "array",
                "maxItems": 2,
                "minItems": 2
              },
              {
                "type": "null"
              }
            ],
            "title": "Index",
            "description": "\n        The start and end index of the current field if it is a list.\n        Can be a tuple of one index: (index).\n        Or a tuple of two indices: (start, end), in which one of two can be `None`.\n        This index field can be optionally used to slice the list, but the indices in key name has a higher priority.\n        "
          },
          "inherit_from_parent": {
            "type": "boolean",
            "title": "Inherit From Parent",
            "description": "\n        Indicate whether to inherit the configuration from the parent section.\n        This field only applies to the target section only, i.e., it does not propagate to its children.\n        ",
            "default": true
          },
          "pagination": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "$ref": "#/components/schemas/DatasetPagination"
              },
              {
                "$ref": "#/components/schemas/EntryProcDataPagination"
              },
              {
                "$ref": "#/components/schemas/MetadataPagination"
              },
              {
                "$ref": "#/components/schemas/MetainfoPagination"
              },
              {
                "$ref": "#/components/schemas/RawDirPagination"
              },
              {
                "$ref": "#/components/schemas/UploadProcDataPagination"
              },
              {
                "$ref": "#/components/schemas/UserGroupPagination"
              },
              {
                "type": "null"
              }
            ],
            "title": "Pagination",
            "description": "\n        The pagination configuration used for MongoDB search.\n        This setting does not propagate to its children.\n        For Token.ENTRIES, Token.UPLOADS and 'm_datasets', different validation rules apply.\n        Please refer to `DatasetPagination`, `UploadProcDataPagination`, `MetadataPagination` for details.\n        "
          },
          "query": {
            "anyOf": [
              {
                "type": "object"
              },
              {
                "$ref": "#/components/schemas/DatasetQuery"
              },
              {
                "$ref": "#/components/schemas/EntryQuery"
              },
              {
                "$ref": "#/components/schemas/Metadata"
              },
              {
                "$ref": "#/components/schemas/MetainfoQuery"
              },
              {
                "$ref": "#/components/schemas/UploadProcDataQuery"
              },
              {
                "$ref": "#/components/schemas/UserGroupQuery"
              },
              {
                "type": "null"
              }
            ],
            "title": "Query",
            "description": "\n        The query configuration used for either mongo or elastic search.\n        This setting does not propagate to its children.\n        It can only be defined at the root levels including Token.ENTRIES, Token.UPLOADS and 'm_datasets'.\n        For Token.ENTRIES, the query is used in elastic search. It must comply with `WithQuery`.\n        For Token.UPLOADS, the query is used in mongo search. It must comply with `UploadProcDataQuery`.\n        For Token.DATASETS, the query is used in mongo search. It must comply with `DatasetQuery`.\n        For Token.GROUPS, the query is used in mongo search. It must comply with `UserGroupQuery`.\n        "
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "RequestConfig",
        "description": "A class to represent the query configuration.\nAn instance of `RequestConfig` shall be attached to each required field.\nThe `RequestConfig` is used to determine the following.\n    1. Whether the field should be included/excluded.\n    2. For reference, whether the reference should be resolved, and how to resolve it.\nEach field can be handled differently."
      },
      "ResolveType": {
        "type": "string",
        "enum": [
          "upload",
          "user",
          "dataset",
          "entry"
        ],
        "title": "ResolveType"
      },
      "SearchRequestOptions": {
        "properties": {
          "query": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Metadata"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "title": "SearchRequestOptions"
      },
      "SearchResponseOptions": {
        "properties": {
          "query": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/MetadataResponse"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "title": "SearchResponseOptions"
      },
      "SignatureToken": {
        "properties": {
          "signature_token": {
            "type": "string",
            "title": "Signature Token"
          }
        },
        "type": "object",
        "required": [
          "signature_token"
        ],
        "title": "SignatureToken"
      },
      "StatisticsAggregation": {
        "properties": {
          "metrics": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metrics",
            "description": "A list of search quantities to act as metrics on all data. Depending on\nthe metric the number will represent either a sum (`calculations` for the number\nof individual calculation in each code run) or an amount (cardinality) of\ndifferent values (i.e. `materials` for the amount of different material hashes).",
            "default": []
          }
        },
        "type": "object",
        "title": "StatisticsAggregation"
      },
      "StatisticsAggregationResponse": {
        "properties": {
          "metrics": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metrics",
            "description": "A list of search quantities to act as metrics on all data. Depending on\nthe metric the number will represent either a sum (`calculations` for the number\nof individual calculation in each code run) or an amount (cardinality) of\ndifferent values (i.e. `materials` for the amount of different material hashes).",
            "default": []
          },
          "data": {
            "anyOf": [
              {
                "additionalProperties": {
                  "type": "integer"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Data"
          }
        },
        "type": "object",
        "title": "StatisticsAggregationResponse"
      },
      "StatisticsModel": {
        "properties": {
          "n_entries": {
            "type": "integer",
            "title": "N Entries",
            "description": "Number of entries in NOMAD"
          },
          "n_uploads": {
            "type": "integer",
            "title": "N Uploads",
            "description": "Number of uploads in NOMAD"
          },
          "n_quantities": {
            "type": "integer",
            "title": "N Quantities",
            "description": "Accumulated number of quantities over all entries in the Archive"
          },
          "n_calculations": {
            "type": "integer",
            "title": "N Calculations",
            "description": "Accumulated number of calculations, e.g. total energy calculations in the Archive"
          },
          "n_materials": {
            "type": "integer",
            "title": "N Materials",
            "description": "Number of materials in NOMAD"
          }
        },
        "type": "object",
        "title": "StatisticsModel"
      },
      "Suggestion": {
        "properties": {
          "value": {
            "type": "string",
            "title": "Value",
            "description": "The returned suggestion."
          },
          "weight": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Weight",
            "description": "The suggestion weight."
          }
        },
        "type": "object",
        "title": "Suggestion"
      },
      "SuggestionsRequest": {
        "properties": {
          "quantities": {
            "items": {
              "$ref": "#/components/schemas/Quantity"
            },
            "type": "array",
            "title": "Quantities",
            "description": "List of quantities for which the suggestions are retrieved."
          },
          "input": {
            "type": "string",
            "title": "Input",
            "description": "The input that is used as a basis for returning a suggestion."
          }
        },
        "type": "object",
        "title": "SuggestionsRequest"
      },
      "TermsAggregation": {
        "properties": {
          "quantity": {
            "type": "string",
            "title": "Quantity",
            "description": "The mandatory name of the quantity for the aggregation. Aggregations\ncan only be computed for those search metadata that have discrete values;\nan aggregation buckets entries that have the same value for this quantity."
          },
          "exclude_from_search": {
            "type": "boolean",
            "title": "Exclude From Search",
            "description": "If set to true, top-level search criteria involving the aggregation quantity, will not\nbe applied for this aggregation. Therefore, the aggregation will return all\nvalues for the quantity, even if the possible values where filtered by the query.\n\nThere are two limitations. This is only supported with queries that start with a\ndictionary. It will not work for queries with a boolean operator. It can only\nexclude top-level criteria at the root of the query dictionary. Nested criteria,\ne.g. within complex and/or constructs, cannot be considered. Using this might also\nprohibit pagination with page_after_value on aggregations in the same request.",
            "default": false
          },
          "metrics": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metrics",
            "description": "By default the returned aggregations will provide the number of entries for each\nvalue. You can add more metrics. For each metric an additional number will be\nprovided for each value. Metrics are also based on search metadata. Depending on\nthe metric the number will represent either a sum (`calculations` for the number\nof individual calculation in each code run) or an amount of different values\n(i.e. `materials` for the amount of different material hashes).",
            "default": []
          },
          "pagination": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AggregationPagination"
              },
              {
                "type": "null"
              }
            ],
            "description": "Only the data few values are returned for each API call. Aggregation\npagination allows to get all available values by pagination. It also allows to\norder values.\n\nYou can only use pagination (to page through all available values) or size (to\nget the size number of values with the most available data)."
          },
          "size": {
            "anyOf": [
              {
                "type": "integer",
                "exclusiveMinimum": 0
              },
              {
                "type": "null"
              }
            ],
            "title": "Size",
            "description": "The amount of aggregation values is limited. This allows you to configure the\nmaximum number of aggregated values to return. If you need to exaust all\npossible value, use `pagination`."
          },
          "include": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "string",
                "pattern": "^[a-zA-Z0-9_\\-\\s]+$"
              },
              {
                "type": "null"
              }
            ],
            "title": "Include",
            "description": "An optional filter for aggregation values. You can either specify a\nsingle string which must be contained in the aggregation value or then\nprovide an array of keywords for which the aggregation will be created.\n\nThis is only available for non paginated aggregations."
          },
          "entries": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AggregatedEntities"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optionally, a set of entries can be returned for each value. These are basically\nexample entries that have the respective bucket value."
          }
        },
        "type": "object",
        "required": [
          "quantity"
        ],
        "title": "TermsAggregation"
      },
      "TermsAggregationResponse": {
        "properties": {
          "quantity": {
            "type": "string",
            "title": "Quantity",
            "description": "The mandatory name of the quantity for the aggregation. Aggregations\ncan only be computed for those search metadata that have discrete values;\nan aggregation buckets entries that have the same value for this quantity."
          },
          "exclude_from_search": {
            "type": "boolean",
            "title": "Exclude From Search",
            "description": "If set to true, top-level search criteria involving the aggregation quantity, will not\nbe applied for this aggregation. Therefore, the aggregation will return all\nvalues for the quantity, even if the possible values where filtered by the query.\n\nThere are two limitations. This is only supported with queries that start with a\ndictionary. It will not work for queries with a boolean operator. It can only\nexclude top-level criteria at the root of the query dictionary. Nested criteria,\ne.g. within complex and/or constructs, cannot be considered. Using this might also\nprohibit pagination with page_after_value on aggregations in the same request.",
            "default": false
          },
          "metrics": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metrics",
            "description": "By default the returned aggregations will provide the number of entries for each\nvalue. You can add more metrics. For each metric an additional number will be\nprovided for each value. Metrics are also based on search metadata. Depending on\nthe metric the number will represent either a sum (`calculations` for the number\nof individual calculation in each code run) or an amount of different values\n(i.e. `materials` for the amount of different material hashes).",
            "default": []
          },
          "pagination": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PaginationResponse"
              },
              {
                "type": "null"
              }
            ]
          },
          "size": {
            "anyOf": [
              {
                "type": "integer",
                "exclusiveMinimum": 0
              },
              {
                "type": "null"
              }
            ],
            "title": "Size",
            "description": "The amount of aggregation values is limited. This allows you to configure the\nmaximum number of aggregated values to return. If you need to exaust all\npossible value, use `pagination`."
          },
          "include": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "string",
                "pattern": "^[a-zA-Z0-9_\\-\\s]+$"
              },
              {
                "type": "null"
              }
            ],
            "title": "Include",
            "description": "An optional filter for aggregation values. You can either specify a\nsingle string which must be contained in the aggregation value or then\nprovide an array of keywords for which the aggregation will be created.\n\nThis is only available for non paginated aggregations."
          },
          "entries": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AggregatedEntities"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optionally, a set of entries can be returned for each value. These are basically\nexample entries that have the respective bucket value."
          },
          "data": {
            "items": {
              "$ref": "#/components/schemas/Bucket"
            },
            "type": "array",
            "title": "Data",
            "description": "The aggregation data as a list."
          }
        },
        "type": "object",
        "required": [
          "quantity"
        ],
        "title": "TermsAggregationResponse"
      },
      "Token": {
        "properties": {
          "access_token": {
            "type": "string",
            "title": "Access Token"
          },
          "token_type": {
            "type": "string",
            "title": "Token Type"
          }
        },
        "type": "object",
        "required": [
          "access_token",
          "token_type"
        ],
        "title": "Token"
      },
      "ToolModel": {
        "properties": {
          "short_description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Short Description",
            "description": "A short description of the tool, e.g. shown in the NOMAD GUI."
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "A description of the tool, e.g. shown in the NOMAD GUI."
          },
          "image": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Image",
            "description": "The docker image (incl. tags) to use for the tool."
          },
          "cmd": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Cmd",
            "description": "The container cmd that is passed to the spawner."
          },
          "image_pull_policy": {
            "type": "string",
            "title": "Image Pull Policy",
            "description": "The image pull policy used in k8s deployments.",
            "default": "Always"
          },
          "privileged": {
            "type": "boolean",
            "title": "Privileged",
            "description": "Whether the tool needs to run in privileged mode.",
            "default": false
          },
          "default_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Default Url",
            "description": "An optional path prefix that is added to the container URL to reach the tool, e.g. \"/lab\" for jupyterlab."
          },
          "path_prefix": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Path Prefix",
            "description": "An optional path prefix that is added to the container URL to reach the files, e.g. \"lab/tree\" for jupyterlab."
          },
          "with_path": {
            "type": "boolean",
            "title": "With Path",
            "description": "Whether the tool supports a path to a file or directory. This also enables tools to be launched from files in the NOMAD UI.",
            "default": false
          },
          "file_extensions": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "File Extensions",
            "description": "The file extensions of files that this tool should be launchable for.",
            "default": []
          },
          "mount_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Mount Path",
            "description": "The path in the container where uploads and work directories will be mounted, e.g. /home/jovyan for Jupyter containers."
          },
          "icon": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Icon",
            "description": "A URL to an icon that is used to represent the tool in the NOMAD UI."
          },
          "maintainer": {
            "items": {
              "$ref": "#/components/schemas/NORTHToolMaintainer"
            },
            "type": "array",
            "title": "Maintainer",
            "description": "The maintainers of the tool.",
            "default": []
          },
          "external_mounts": {
            "items": {
              "$ref": "#/components/schemas/NORTHExternalMount"
            },
            "type": "array",
            "title": "External Mounts",
            "description": "Additional mounts to be added to tool containers.",
            "default": []
          },
          "name": {
            "type": "string",
            "title": "Name"
          },
          "state": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ToolStateEnum"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "name"
        ],
        "title": "ToolModel"
      },
      "ToolResponseModel": {
        "properties": {
          "tool": {
            "type": "string",
            "title": "Tool"
          },
          "username": {
            "type": "string",
            "title": "Username"
          },
          "upload_mount_dir": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Upload Mount Dir"
          },
          "data": {
            "$ref": "#/components/schemas/ToolModel"
          },
          "upload_id_is_mounted": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Upload Id Is Mounted"
          }
        },
        "type": "object",
        "required": [
          "tool",
          "username",
          "data"
        ],
        "title": "ToolResponseModel"
      },
      "ToolStateEnum": {
        "type": "string",
        "enum": [
          "running",
          "starting",
          "stopping",
          "stopped"
        ],
        "title": "ToolStateEnum"
      },
      "ToolsResponseModel": {
        "properties": {
          "data": {
            "items": {
              "$ref": "#/components/schemas/ToolModel"
            },
            "type": "array",
            "title": "Data",
            "default": []
          }
        },
        "type": "object",
        "title": "ToolsResponseModel"
      },
      "UploadCommandExamplesResponse": {
        "properties": {
          "upload_url": {
            "type": "string",
            "title": "Upload Url"
          },
          "upload_command": {
            "type": "string",
            "title": "Upload Command"
          },
          "upload_command_with_name": {
            "type": "string",
            "title": "Upload Command With Name"
          },
          "upload_progress_command": {
            "type": "string",
            "title": "Upload Progress Command"
          },
          "upload_command_form": {
            "type": "string",
            "title": "Upload Command Form"
          },
          "upload_tar_command": {
            "type": "string",
            "title": "Upload Tar Command"
          }
        },
        "type": "object",
        "required": [
          "upload_url",
          "upload_command",
          "upload_command_with_name",
          "upload_progress_command",
          "upload_command_form",
          "upload_tar_command"
        ],
        "title": "UploadCommandExamplesResponse"
      },
      "UploadProcData": {
        "properties": {
          "process_running": {
            "type": "boolean",
            "title": "Process Running",
            "description": "If a process is running"
          },
          "current_process": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Current Process",
            "description": "Name of the current or last completed process"
          },
          "process_status": {
            "type": "string",
            "title": "Process Status",
            "description": "The status of the current or last completed process",
            "default": "READY"
          },
          "last_status_message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Status Message",
            "description": "A short, human readable message from the current process, with information about what the current process is doing, or information about the completion (successful or not) of the last process, if no process is currently running."
          },
          "errors": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Errors",
            "description": "A list of error messages that occurred during the last processing"
          },
          "warnings": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Warnings",
            "description": "A list of warning messages that occurred during the last processing"
          },
          "complete_time": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Complete Time",
            "description": "Date and time of the completion of the last process"
          },
          "upload_id": {
            "type": "string",
            "title": "Upload Id",
            "description": "The unique id for the upload."
          },
          "upload_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Upload Name",
            "description": "The name of the upload. This can be provided during upload using the `upload_name` query parameter."
          },
          "upload_create_time": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Upload Create Time",
            "description": "Date and time of the creation of the upload."
          },
          "main_author": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Main Author",
            "description": "The main author of the upload."
          },
          "coauthors": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Coauthors",
            "description": "A list of upload coauthors."
          },
          "coauthor_groups": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Coauthor Groups",
            "description": "A list of upload coauthor groups."
          },
          "reviewers": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Reviewers",
            "description": "A list of upload reviewers."
          },
          "reviewer_groups": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Reviewer Groups",
            "description": "A list of upload reviewer groups."
          },
          "writers": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Writers",
            "description": "All writer users (main author, upload coauthors)."
          },
          "writer_groups": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Writer Groups",
            "description": "All writer groups (coauthor groups)."
          },
          "viewers": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Viewers",
            "description": "All viewer users (main author, upload coauthors, and reviewers)"
          },
          "viewer_groups": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Viewer Groups",
            "description": "All viewer groups (coauthor groups, reviewer groups)."
          },
          "published": {
            "type": "boolean",
            "title": "Published",
            "description": "If this upload is already published.",
            "default": false
          },
          "published_to": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Published To",
            "description": "A list of other NOMAD deployments that this upload was uploaded to already."
          },
          "publish_time": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Publish Time",
            "description": "Date and time of publication, if the upload has been published."
          },
          "with_embargo": {
            "type": "boolean",
            "title": "With Embargo",
            "description": "If the upload has an embargo set (embargo_length not equal to zero)."
          },
          "embargo_length": {
            "type": "integer",
            "title": "Embargo Length",
            "description": "The length of the requested embargo, in months. 0 if no embargo is requested."
          },
          "license": {
            "type": "string",
            "title": "License",
            "description": "The license under which this upload is distributed."
          },
          "entries": {
            "type": "integer",
            "title": "Entries",
            "description": "The number of identified entries in this upload.",
            "default": 0
          },
          "upload_files_server_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Upload Files Server Path",
            "description": "The path to the uploads files on the server."
          }
        },
        "type": "object",
        "required": [
          "process_running",
          "errors",
          "warnings",
          "upload_id",
          "with_embargo",
          "embargo_length",
          "license"
        ],
        "title": "UploadProcData"
      },
      "UploadProcDataPagination": {
        "properties": {
          "page_size": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page Size",
            "description": "The page size, e.g. the maximum number of items contained in one response.\nA `page_size` of 0 will return no results.",
            "default": 10
          },
          "order_by": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Order By",
            "description": "The results are ordered by the values of this field. If omitted, default\nordering is applied."
          },
          "order": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Direction"
              },
              {
                "type": "null"
              }
            ],
            "description": "The ordering direction of the results based on `order_by`. Its either\nascending `asc` or descending `desc`. Default is `asc`.",
            "default": "asc"
          },
          "page_after_value": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page After Value",
            "description": "This attribute defines the position after which the page begins, and is used\nto navigate through the total list of results.\n\nWhen requesting the first page, no value should be provided for\n`page_after_value`. Each response will contain a value `next_page_after_value`,\nwhich can be used to obtain the next page (by setting `page_after_value` in\nyour next request to this value).\n\nThe field is encoded as a string, and the format of `page_after_value` and\n`next_page_after_value` depends on which API method is used.\n\nSome API functions additionally allows a simplified navigation, by specifying\nthe page number in the key `page`. It is however always possible to use\n`page_after_value` and `next_page_after_value` to iterate through the results."
          },
          "page": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page",
            "description": "The number of the page (1-based). When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used."
          },
          "page_offset": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page Offset",
            "description": "The number of skipped entries. When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page_offset` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used."
          }
        },
        "type": "object",
        "title": "UploadProcDataPagination"
      },
      "UploadProcDataQuery": {
        "properties": {
          "upload_id": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Upload Id",
            "description": "Search for uploads matching the given id. Multiple values can be specified."
          },
          "upload_name": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Upload Name",
            "description": "Search for uploads matching the given upload_name. Multiple values can be specified."
          },
          "is_processing": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Processing",
            "description": "If True, only include currently processing uploads.\nIf False, do not include currently processing uploads.\nIf unset, include everything."
          },
          "is_published": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Published",
            "description": "If True: only include published uploads.\nIf False: only include unpublished uploads.\nIf unset: include everything."
          },
          "process_status": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Process Status",
            "description": "Search by the process status."
          },
          "is_owned": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Owned",
            "description": "If True: only include owned uploads.\nIf False: only include shared uploads.\nIf unset: include everything."
          }
        },
        "type": "object",
        "title": "UploadProcDataQuery"
      },
      "UploadProcDataQueryResponse": {
        "properties": {
          "query": {
            "$ref": "#/components/schemas/UploadProcDataQuery"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationResponse"
          },
          "data": {
            "items": {
              "$ref": "#/components/schemas/UploadProcData"
            },
            "type": "array",
            "title": "Data",
            "description": "The upload data as a list. Each item is a dictionary with the data for each\nupload."
          }
        },
        "type": "object",
        "required": [
          "query",
          "pagination"
        ],
        "title": "UploadProcDataQueryResponse"
      },
      "UploadProcDataResponse": {
        "properties": {
          "upload_id": {
            "type": "string",
            "title": "Upload Id",
            "description": "Unique id of the upload."
          },
          "data": {
            "$ref": "#/components/schemas/UploadProcData",
            "description": "The upload data as a dictionary."
          }
        },
        "type": "object",
        "title": "UploadProcDataResponse"
      },
      "UploadRequestOptions": {
        "properties": {
          "pagination": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UploadProcDataPagination"
              },
              {
                "type": "null"
              }
            ]
          },
          "query": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UploadProcDataQuery"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "title": "UploadRequestOptions"
      },
      "UploadResponseOptions": {
        "properties": {
          "pagination": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PaginationResponse"
              },
              {
                "type": "null"
              }
            ]
          },
          "query": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UploadProcDataQuery"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "title": "UploadResponseOptions"
      },
      "UploadRole": {
        "type": "string",
        "enum": [
          "main_author",
          "reviewer",
          "coauthor"
        ],
        "title": "UploadRole"
      },
      "User": {
        "properties": {
          "name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Name"
          },
          "first_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "First Name",
            "description": "The users first name (including all other given names)"
          },
          "last_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Name",
            "description": "The users last name"
          },
          "email": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Email"
          },
          "affiliation": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Affiliation",
            "description": "The name of the company and institutes the user identifies with"
          },
          "affiliation_address": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Affiliation Address",
            "description": "The address of the given affiliation"
          },
          "user_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "User Id",
            "description": "The unique, persistent keycloak UUID"
          },
          "username": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Username",
            "description": "The unique, persistent, user chosen username"
          },
          "created": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Created",
            "description": "The time the account was created"
          },
          "repo_user_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Repo User Id",
            "description": "Optional, legacy user id from the old NOMAD CoE repository."
          },
          "is_admin": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Admin",
            "description": "Bool that indicated, iff the user the use admin user"
          },
          "is_oasis_admin": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Oasis Admin",
            "default": false
          }
        },
        "type": "object",
        "title": "User"
      },
      "UserGroup": {
        "properties": {
          "group_id": {
            "type": "string",
            "title": "Group Id",
            "description": "Unique id of the group."
          },
          "group_name": {
            "type": "string",
            "title": "Group Name",
            "description": "Name of the group.",
            "default": "Default Group Name"
          },
          "owner": {
            "type": "string",
            "title": "Owner",
            "description": "User id of the group owner."
          },
          "members": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Members",
            "description": "User ids of the group members (includes owner)."
          }
        },
        "type": "object",
        "required": [
          "group_id",
          "owner"
        ],
        "title": "UserGroup"
      },
      "UserGroupEdit": {
        "properties": {
          "group_name": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 32,
                "minLength": 3,
                "pattern": "^[a-zA-Z0-9][a-zA-Z0-9 ._\\-]+[a-zA-Z0-9]$"
              },
              {
                "type": "null"
              }
            ],
            "title": "Group Name",
            "description": "Name of the group."
          },
          "members": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "uniqueItems": true
              },
              {
                "type": "null"
              }
            ],
            "title": "Members",
            "description": "User ids of the group members (includes owner)."
          }
        },
        "type": "object",
        "title": "UserGroupEdit"
      },
      "UserGroupPagination": {
        "properties": {
          "page_size": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page Size",
            "description": "The page size, e.g. the maximum number of items contained in one response.\nA `page_size` of 0 will return no results.",
            "default": 10
          },
          "order_by": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Order By",
            "description": "The results are ordered by the values of this field. If omitted, default\nordering is applied."
          },
          "order": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Direction"
              },
              {
                "type": "null"
              }
            ],
            "description": "The ordering direction of the results based on `order_by`. Its either\nascending `asc` or descending `desc`. Default is `asc`.",
            "default": "asc"
          },
          "page_after_value": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page After Value",
            "description": "This attribute defines the position after which the page begins, and is used\nto navigate through the total list of results.\n\nWhen requesting the first page, no value should be provided for\n`page_after_value`. Each response will contain a value `next_page_after_value`,\nwhich can be used to obtain the next page (by setting `page_after_value` in\nyour next request to this value).\n\nThe field is encoded as a string, and the format of `page_after_value` and\n`next_page_after_value` depends on which API method is used.\n\nSome API functions additionally allows a simplified navigation, by specifying\nthe page number in the key `page`. It is however always possible to use\n`page_after_value` and `next_page_after_value` to iterate through the results."
          },
          "page": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page",
            "description": "The number of the page (1-based). When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used."
          },
          "page_offset": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Page Offset",
            "description": "The number of skipped entries. When provided in a request, this attribute\ncan be used instead of `page_after_value` to jump to a particular results page.\n\n**NOTE #1**: the option to request pages by submitting the `page_offset` number is\nlimited. There are api calls where this attribute cannot be used for indexing,\nor where it can only be used partially. **If you want to just iterate through\nall the results, always use the `page_after_value` and `next_page_after_value`!**\n\n**NOTE #2**: Only one, `page`, `page_offset` or `page_after_value`, can be used."
          }
        },
        "type": "object",
        "title": "UserGroupPagination"
      },
      "UserGroupQuery": {
        "properties": {
          "group_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Group Id",
            "description": "Search groups by their full id (scalar or list)."
          },
          "user_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "User Id",
            "description": "Search groups by their owner's or members' ids."
          },
          "search_terms": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Search Terms",
            "description": "Search groups by parts of their name."
          }
        },
        "type": "object",
        "title": "UserGroupQuery"
      },
      "UserGroupResponse": {
        "properties": {
          "pagination": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/PaginationResponse"
              },
              {
                "type": "null"
              }
            ]
          },
          "data": {
            "items": {
              "$ref": "#/components/schemas/UserGroup"
            },
            "type": "array",
            "title": "Data"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "UserGroupResponse"
      },
      "Users": {
        "properties": {
          "data": {
            "items": {
              "$ref": "#/components/schemas/User"
            },
            "type": "array",
            "title": "Data"
          }
        },
        "type": "object",
        "required": [
          "data"
        ],
        "title": "Users"
      },
      "ValidationError": {
        "properties": {
          "loc": {
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ]
            },
            "type": "array",
            "title": "Location"
          },
          "msg": {
            "type": "string",
            "title": "Message"
          },
          "type": {
            "type": "string",
            "title": "Error Type"
          }
        },
        "type": "object",
        "required": [
          "loc",
          "msg",
          "type"
        ],
        "title": "ValidationError"
      },
      "WrapModeEnum": {
        "type": "string",
        "enum": [
          "original",
          "wrap",
          "unwrap"
        ],
        "title": "WrapModeEnum"
      }
    },
    "securitySchemes": {
      "OAuth2PasswordBearer": {
        "type": "oauth2",
        "flows": {
          "password": {
            "scopes": {},
            "tokenUrl": "/prod/v1/api/v1/auth/token"
          }
        }
      }
    }
  }
}
